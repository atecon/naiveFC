<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="naiveFC" needs-time-series-data="true" minver="2018a" lives-in-subdir="true">
<author email="atecon@cryptolab.net">Artur Tarassow</author>
<version>0.11</version>
<date>2018-10-31</date>
<description>Simple forecasting methods</description>
<tags>C53</tags>
<label>naive forecast(s)</label>
<menu-attachment>MAINWIN/Model/&quot;Time series&quot;</menu-attachment>
<help>
pdfdoc:naiveFC.pdf
</help>
<gretl-function name="meanf" type="matrix">
 <params count="6">
  <param name="y" type="series" const="true">
<description>Actuals</description>
  </param>
  <param name="h" type="int" min="1" default="10">
<description>Forecast horizon</description>
  </param>
  <param name="level" type="scalar" min="64" max="99" default="90">
<description>Confidence level</description>
  </param>
  <param name="fan" type="bool" default="0"/>
  <param name="nboot" type="int" min="0" default="0"/>
  <param name="blength" type="int" min="2" default="4">
<description>Block length bootstrap</description>
  </param>
 </params>
<code># forecasts of all future values are equal to the mean of the historical data
# Returns forecasts and prediction intervals for an iid model applied to y
/* R func:
meanf(y, h = 10, level = c(80, 95), fan = FALSE, lambda = NULL, biasadj = FALSE, bootstrap = FALSE, npaths = 5000, x = y)
*/
if nboot&gt;0
  print_noboot()
endif
matrix ci = genci(level,fan)
if nboot==0
  #matrix ymean = ones(h,cols(ci)+1) .* ( mean(y) ~ NA ~ NA ) # ~ quantile({y},ci)' )
  matrix ymean = ones(h,1) .* mean(y)
else
  /*
  matrix yb = vec( re_sample({y}, nboot, blength) )
  matrix ymean = ones(h,cols(ci)+1) .* ( meanc(yb) ~ quantile(yb,ci)' )
  */
endif
cnameset(ymean, gen_colnames(ci))
rnameset(ymean, rownam(h))
return ymean
</code>
</gretl-function>
<gretl-function name="rwf" type="matrix">
 <params count="7">
  <param name="y" type="series" const="true">
<description>Actuals</description>
  </param>
  <param name="h" type="int" min="1" default="10">
<description>Forecast horizon</description>
  </param>
  <param name="drift" type="bool" default="0">
<description>0=Random-Walk wo drift, 1=w drift</description>
  </param>
  <param name="level" type="scalar" min="64" max="99" default="90">
<description>Confidence level</description>
  </param>
  <param name="fan" type="bool" default="0"/>
  <param name="nboot" type="int" min="0" default="0"/>
  <param name="blength" type="int" min="2" default="4">
<description>Block length bootstrap</description>
  </param>
 </params>
<code># na√Øve forecast is optimal when data follow a random walk
# these are also called random walk forecasts
/* R func:
https://www.rdocumentation.org/packages/forecast/versions/8.4/topics/rwf
rwf(y, h = 10, drift = FALSE, level = c(80, 95), fan = FALSE, lambda = NULL, biasadj = FALSE, bootstrap = FALSE, npaths = 5000, x = y)
*/
if nboot&gt;0
  print_noboot()
endif
matrix ci = genci(level,fan)
#matrix fc = ones(h,3) .* ( y[$t2] ~ NA ~ NA )
smpl y --no-missing
matrix fc = ones(h,1) .* y[$t2]
if drift
  # equivalent to an ARIMA(0,1,0) model with an optional drift coefficient
  scalar avg = (y[$t2]-y[$t1])/(nobs(y)-1)	# average growth rate (drift)
  fc[,1] = fc[,1] .+ cum(ones(h,1))*avg	# TODO: consider intervals later
endif
cnameset(fc, gen_colnames(ci))
rnameset(fc, rownam(h))
return fc
</code>
</gretl-function>
<gretl-function name="snaive" type="matrix">
 <params count="6">
  <param name="y" type="series" const="true">
<description>Series</description>
  </param>
  <param name="h" type="int" min="1" default="10">
<description>Horizon</description>
  </param>
  <param name="level" type="scalar" min="64" max="99" default="90">
<description>Confidence level</description>
  </param>
  <param name="fan" type="bool" default="0"/>
  <param name="nboot" type="int" min="0" default="0"/>
  <param name="blength" type="int" min="2" default="4">
<description>Block length bootstrap</description>
  </param>
 </params>
<code># returns forecasts and prediction intervals from an ARIMA(0,0,0)(0,1,0)
# model where m is the seasonal period.
/* R func:
https://www.rdocumentation.org/packages/cv.ts/versions/0.0.0.90105/topics/snaiveForecast
snaive(y, h = 2 * frequency(x), level = c(80, 95), fan = FALSE, lambda = NULL, biasadj = FALSE, bootstrap = FALSE, npaths = 5000, x = y)
*/
if nboot&gt;0
  print_noboot()
endif
seas_check(y)
matrix ci = genci(level,fan)
if fan==0
  # forecast simply equals last obs for each specific periodicity (month, quarter)
  fc = get_last_obsminor(y, h)
  # matrix fc = ones(h,3) .* ( fc ~ NA ~ NA )
  matrix fc = ones(h,1) .* fc
else
  funcerr &quot;Fan forecasts are not available, yet.&quot;
  /* NEEDS
  # forecast simply equals last obs for each specific periodicity (month, quarter)
  # FIXME: This destroys the seasonality structure
  matrix yb = re_sample({y}, nboot, blength)
  fc_b = zeros(h, nboot)
  loop i=1..nboot -q
    fc_b[,i] = snaive_stack(yb[,i], h)
  endloop
  #fc_mean:	 mean across each horizon
  #fc_ci:		quantiles across each horizon
  matrix fc = ones(h,cols(ci)+1) .* ( meanr(fc_b) ~ quantile(fc_b',ci)' )
  */
endif
cnameset(fc, gen_colnames(ci))
rnameset(fc, rownam(h))
return fc
</code>
</gretl-function>
<gretl-function name="avgfc_gui" type="matrix" pkg-role="gui-main">
 <params count="2">
  <param name="y" type="series" const="true">
<description>Series</description>
  </param>
  <param name="h" type="int" min="1" default="10">
<description>Horizon</description>
  </param>
 </params>
<code>matrix FC = avgfc(y,h)
printf &quot;%12.4f\n&quot;, FC
return FC
</code>
</gretl-function>
<gretl-function name="fcplot" type="void">
 <params count="6">
  <param name="y" type="series" const="true"/>
  <param name="fc" type="matrix"/>
  <param name="title" type="string" optional="true"/>
  <param name="ylab" type="string" optional="true"/>
  <param name="xlab" type="string" optional="true"/>
  <param name="filename" type="string" optional="true">
<description>'display' OR 'Path+filename'</description>
  </param>
 </params>
<code># Plot point forecast and quantiles
string title = !exists(title) ? &quot;&quot; : title
string ylab = !exists(ylab) ? &quot;&quot; : ylab
string xlab = !exists(xlab) ? &quot;&quot; : xlab
string out = !exists(filename) ? &quot;display&quot; : filename
set warnings off
matrix mplot = {y}
loop i=1..cols(fc) -q
  mplot ~= NA
endloop
mplot |= (NA ~ fc)
if cols(fc)&gt;1
  cnameset(mplot, strsplit(&quot;Actuals Point-FC Low High&quot;, &quot; &quot;))
else
  cnameset(mplot, strsplit(&quot;Actuals Point-FC&quot;, &quot; &quot;))
endif
set warnings on
ylo = min(y)-0.05*min(y)
yup = max(y)+0.05*max(y)
plot mplot
  options with-lines time-series single-yaxis
  literal set linetype 1 lc rgb &quot;grey&quot;
  literal set linetype 2 lc rgb &quot;red&quot; lw 2
  literal set linetype 3 lc rgb &quot;black&quot; lw 1.5
  literal set linetype 4 lc rgb &quot;black&quot; lw 1.5
  literal set key bottom below
  printf &quot;set yrange[%g:%g]&quot;, ylo, yup
  printf &quot;set ylabel \&quot;%s\&quot;&quot;, ylab
  printf &quot;set xlabel \&quot;%s\&quot;&quot;, xlab
  printf &quot;set title \&quot;%s\&quot;&quot;, title
end plot --output=@out
</code>
</gretl-function>
<gretl-function name="smeanf" type="matrix">
 <params count="6">
  <param name="y" type="series" const="true">
<description>Series</description>
  </param>
  <param name="h" type="int" min="1" default="10">
<description>Horizon</description>
  </param>
  <param name="level" type="scalar" min="64" max="99" default="90">
<description>Confidence level</description>
  </param>
  <param name="fan" type="bool" default="0"/>
  <param name="nboot" type="int" min="0" default="0"/>
  <param name="blength" type="int" min="2" default="4">
<description>Block length bootstrap</description>
  </param>
 </params>
<code># forecasts of all future values are equal to the mean of season of the historical data
# model where m is the seasonal period.
if nboot&gt;0
  print_noboot()
endif
seas_check(y)
matrix ci = genci(level, fan)
if fan==0
  # forecast simply equals the mean for each specific $obsminor periodicity (month, quarter etc.)
  fc = get_mean_obsminor(y, h)
  #matrix fc = ones(h,3) .* ( fc ~ NA ~ NA )
  matrix fc = ones(h,1) .* fc
else
  funcerr &quot;Fan forecasts are not available, yet.&quot;
  /* Not implemented yet
  # forecast simply equals last obs for each specific periodicity (month, quarter)
  # FIXME: This destroys the seasonality structure
  matrix yb = re_sample({y}, nboot, blength)
  fc_b = zeros(h, nboot)
  loop i=1..nboot -q
    fc_b[,i] = snaive_stack(yb[,i], h)
  endloop
  #fc_mean:	 mean across each horizon
  #fc_ci:		quantiles across each horizon
  matrix fc = ones(h,cols(ci)+1) .* ( meanr(fc_b) ~ quantile(fc_b',ci)' )
  */
endif
cnameset(fc, gen_colnames(ci))
rnameset(fc, rownam(h))
return fc
</code>
</gretl-function>
<gretl-function name="ar1f" type="matrix">
 <params count="6">
  <param name="y" type="series" const="true">
<description>Series</description>
  </param>
  <param name="h" type="int" min="1" default="10">
<description>Horizon</description>
  </param>
  <param name="level" type="scalar" min="64" max="99" default="90">
<description>Confidence level</description>
  </param>
  <param name="fan" type="bool" default="0"/>
  <param name="nboot" type="int" min="0" default="0"/>
  <param name="blength" type="int" min="2" default="4">
<description>Block length bootstrap</description>
  </param>
 </params>
<code>if nboot&gt;0
  print_noboot()
endif
matrix ci = genci(level,fan)
smpl y --no-missing
ols y 0 y(-1) --quiet				# estimation via OLS
matrix fc = recfc(y, $coeff, h)		# iterative forecast
cnameset(fc, gen_colnames(ci))
rnameset(fc, rownam(h))
return fc
</code>
</gretl-function>
<gretl-function name="avgfc" type="matrix">
 <params count="6">
  <param name="y" type="series" const="true">
<description>Series</description>
  </param>
  <param name="h" type="int" min="1" default="10">
<description>Horizon</description>
  </param>
  <param name="level" type="scalar" min="64" max="99" default="90">
<description>Confidence level</description>
  </param>
  <param name="fan" type="bool" default="0"/>
  <param name="nboot" type="int" min="0" default="0"/>
  <param name="blength" type="int" min="2" default="4">
<description>Block length bootstrap</description>
  </param>
 </params>
<code># Computes the mean (average) and cross-sectional (across forecast methods)
# standard deviation at each horizon using all simple forecast methods
# available.
if nboot&gt;0
  print_noboot()
endif
# Base models
strings M = defarray(&quot;meanf(y,h)&quot;, &quot;rwf(y,h)&quot;, &quot;rwf(y,h,1)&quot;, &quot;ar1f(y,h)&quot;)
if $pd&gt;1	# for seasonal data only
  M += &quot;smeanf(y,h)&quot;
  M += &quot;snaive(y,h)&quot;
endif
matrix fc = zeros(h,nelem(M))
loop i=1..nelem(M) -q
  string s = sprintf(&quot;%s&quot;, M[i])
  fc[,i] = @s[,1]	# only point-fc
endloop
fc = meanr(fc) ~ sdc(fc', rows(fc')-1)' ~ fc
if $pd == 1
  cnameset(fc, strsplit(&quot;average-fc sd meanf rwf rwf+drift AR(1)&quot;, &quot; &quot;))
else
  cnameset(fc, strsplit(&quot;average-fc sd meanf rwf rwf+drift AR(1) smean snaive&quot;, &quot; &quot;))
endif
rnameset(fc, rownam(h))
return fc
</code>
</gretl-function>
<gretl-function name="gen_colnames" type="strings" private="1">
 <params count="1">
  <param name="ci" type="matrix"/>
 </params>
<code># construct column names
strings c = defarray(&quot;point&quot;)
/* confidence intervals are not supported yet
loop i=1..cols(ci) -q
  c += sprintf(&quot; q%d&quot;, ci[i]*100)
endloop
*/
return c
</code>
</gretl-function>
<gretl-function name="rownam" type="strings" private="1">
 <params count="1">
  <param name="h" type="scalar"/>
 </params>
<code># construct row names (horizons)
strings r = array(h)
loop i=1..h -q
  r[i] = sprintf(&quot; h=%d&quot;, i)
endloop
return r
</code>
</gretl-function>
<gretl-function name="get_last_obsminor" type="matrix" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="h" type="int"/>
 </params>
<code># obtain last k (quarterly=4, monthly=12, etc. obs)
smpl y --no-missing
smpl ($t2-$pd+1) $t2	# last $pd values
return stack_fc({y}, h)
</code>
</gretl-function>
<gretl-function name="genci" type="matrix" private="1">
 <params count="2">
  <param name="level" type="scalar" min="1" max="99" default="90">
<description>confidence sign. level</description>
  </param>
  <param name="fan" type="bool" default="0"/>
 </params>
<code># generate confidence interval(s)
if !fan
  scalar lo = (100-level)/2
  matrix ci = { lo, 100-lo }./100
else
  matrix ci = seq(2,99,3)/100
endif
return ci
</code>
</gretl-function>
<gretl-function name="stack_fc" type="matrix" private="1">
 <params count="2">
  <param name="fc" type="matrix">
<description>Forecast(s)</description>
  </param>
  <param name="h" type="int">
<description>Forecast horizon</description>
  </param>
 </params>
<code># construct h-step ahdead forecasts
matrix fc = vec(fc)
# stack forecasts
if h&gt;rows(fc)
  loop i=1..ceil(h/rows(fc)) -q
    fc |= fc
  endloop
  fc = fc[1:h]
else
  fc = fc[1:h]
endif
return fc
</code>
</gretl-function>
<gretl-function name="get_mean_obsminor" type="matrix" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="h" type="int"/>
 </params>
<code># obtain last k (quarterly=4, monthly=12, etc. obs)
series omin = $obsminor
scalar n = max(uniq(omin))
matrix ymeans = zeros(n, 1)
loop i=1..n -q	# filter by $obsminor
  smpl omin==$i --restrict --replace
  ymeans[i] = mean(y)
endloop
smpl full
return stack_fc(ymeans, h)
</code>
</gretl-function>
<gretl-function name="seas_check" type="void" private="1">
 <params count="1">
  <param name="y" type="series" const="true">
<description>Actuals</description>
  </param>
 </params>
<code>if $pd==1
  funcerr &quot;The method you requested is not available for annual data.&quot;
endif
</code>
</gretl-function>
<gretl-function name="print_noboot" type="void" private="1">
<code>funcerr &quot;Bootstrap confidence intervals are not supported, yet&quot;
</code>
</gretl-function>
<gretl-function name="recfc" type="matrix" private="1">
 <params count="3">
  <param name="y" type="series" const="true"/>
  <param name="bhat" type="matrix"/>
  <param name="h" type="int"/>
 </params>
<code>matrix fc = zeros(h,1)
fc[1] = bhat[1] + bhat[2]*y[$t2]
loop i=2..h -q
  fc[i] = bhat[1] + bhat[2]*fc[i-1]
endloop
return fc
</code>
</gretl-function>
<sample-script>
set verbose off
clear
include naiveFC.gfn --force

open AWM.gdt --quiet
series x = YGA		# output gap; for simplity named &quot;x&quot;
scalar h = 11		# set forecast horizon

# MEANFC
xmean = meanf(x, h)
xmean
fcplot(x, xmean, &quot;Mean Forecast&quot;, &quot;nice ylabel&quot;, &quot;nice xlabel&quot;)

# SMEANF:
smean = smeanf(x, h)
smean
fcplot(x, smean, &quot;Seasonal Mean Forecast&quot;)

# SNAIVE:
snaiv = snaive(x, h)
snaiv
fcplot(x, snaiv, &quot;Naive Seasonal Forecast&quot;)

# RW wo drift
rw = rwf(x, h)
rw
fcplot(x, rw, &quot;Random-Walk Forecast&quot;)

# RW with drift
rwd = rwf(x, h, 1)
rwd
fcplot(x, rwd, &quot;Random-Walk + Drift Forecast&quot;)

# AR(1)
ar_1 = ar1f(x, h)
ar_1
fcplot(x, ar_1, &quot;AR(1) Forecast&quot;)


# Average of Forecasts
avg_fc = avgfc(x, h)
avg_fc		# 1st col: point forecast, 2nd col: std. deviation
fcplot(x, avg_fc[,1], &quot;Avg. of Forecasts&quot;)
</sample-script>
</gretl-function-package>
</gretl-functions>
