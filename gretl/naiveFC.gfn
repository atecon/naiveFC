<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="naiveFC" needs-time-series-data="true" minver="2019b" lives-in-subdir="true">
<author email="atecon@posteo.de">Artur Tarassow</author>
<version>0.6</version>
<date>2019-06-01</date>
<description>Simple forecasting methods</description>
<tags>C53</tags>
<label>naive forecast(s)</label>
<menu-attachment>MAINWIN/Model/TSModels</menu-attachment>
<help>
pdfdoc:naiveFC.pdf
</help>
<depends count="1">
CvDataSplitter </depends>
<gretl-function name="naiveFC" type="bundle">
 <params count="3">
  <param name="y" type="series" const="true"/>
  <param name="which" type="string">
<description>Select forecasting method</description>
  </param>
  <param name="opts" type="bundle" optional="true">
<description>Bundle incl. optional parameters</description>
  </param>
 </params>
<code>/*=======================*/
/* Main package function */
/*=======================*/
# Set up the bundle
bundle self = default_naiveFC_opts(y)
if exists(opts)
  self = opts + self			# override defaults
endif
self.which = which
# Check whether method is applicable
initial_checks(&amp;self)
# Drop missings + determine number of obs.
drop_missings(y, &amp;self)
# smpl obsnum(self.t1_label) obsnum(self.t2_label) # restrict to valid set
# Add obs for forecasting
self.obs_added = nobs_to_add(y, &amp;self)
dataset addobs self.obs_added
series self.y = y		# update
# Call method
#==============
if self.type_roll==&quot;static&quot;
  matrix self.fc = call_method(&amp;self)
  # Compute (not yet for all methods implemented) forecast intervals
  if which != &quot;avgFC&quot;
    gen_fc_ival(&amp;self)
  endif
  # Add column/ row strings
  if which != &quot;avgFC&quot;
    cnameset(self.fc, gen_colnam(&amp;self))
  else
    cnameset(self.fc, self.method_names)
  endif
  rnameset(self.fc, gen_fcdates(&amp;self))
elif self.type_roll==&quot;rolling&quot; || self.type_roll==&quot;recursive&quot;
  NaiveThroughTime(&amp;self)
endif
if self.verbose
  summarize_naive_fc(&amp;self)
endif
# Drop some elements from self
delete self.fan
delete self.blength
delete self.nboot
if inbundle(self,&quot;obs_season&quot;)
  delete self.obs_season
endif
return self
</code>
</gretl-function>
<gretl-function name="naivePlot" type="void">
 <params count="1">
  <param name="self" type="bundleref">
<description>Bundle returned from naiveFC()</description>
  </param>
 </params>
<code>/* Function for plotting actual and forecast values over time. */
string out = self.filename
# No. of pre-forecast obs. to plot - default 25pct. of total obs.
scalar preobs_fc = !inbundle(self,&quot;preobs_fc&quot;) ? int(0.25*self.T) : self.preobs_fc
# Augment the dataset
dataset addobs self.obs_added
# Note, eventual missings at the beginning of the data passed to naiveFC() aren't considered.
smpl obsnum(self.t1_label) $t2				# restrict back
series y = self.y
delete self.y
# Set up the fcmat matrix holding results
if self.type_roll==&quot;static&quot;
  matrix fcmat = zeros(self.T, cols(self.fc))		# length equal to no, of obs. of the non-augmented sample
  fcmat = (fcmat.=0) ? NA : fcmat
  fcmat |= self.fc							# concatenate forecasts
else
  matrix fcmat = self.fc
endif
# Prepare lists for plotting
setinfo y --graph-name=&quot;Actuals&quot;
list lplot = y
if self.type_roll!=&quot;static&quot;						# rolling/ recursive window
  # Initialization
  scalar start = self.initfc-1
  smpl start start
  # Loop over diff. training sets; each produces h-step ahead forecasts
  loop i=1..rows(self.fc) -q
    start++
    smpl start (start+self.h-1)
    series fc_$i = fcmat[i,]
    str = sprintf(&quot;TrainSet=%d&quot;, $i)
    setinfo fc_$i --graph-name=&quot;@str&quot;
    lplot += fc_$i
  endloop
elif self.type_roll==&quot;static&quot;
  self.initfc = self.T+1
  loop i=1..cols(self.fc) -q
    series fc_$i = fcmat[,i]
    if self.which==&quot;avgFC&quot;
      if i!=2
        str = sprintf(&quot;%s&quot;, self.method_names[i])
        setinfo fc_$i --graph-name=&quot;@str&quot;
      endif
    else
      setinfo fc_$i --graph-name=&quot;Point-Fc&quot;
      if cols(self.fc)==3
        string s = sprintf(&quot;(%d pct.)&quot;, self.level*100)
        if i==2
          setinfo fc_$i --graph-name=&quot;Lower&quot;
        elif i==3
          setinfo fc_$i --graph-name=&quot;Upper&quot;
        endif
      endif
    endif
    lplot += fc_$i
    if self.which==&quot;avgFC&quot; &amp;&amp; i==2
      lplot -= fc_$i		# drop cross-sectional std. statistics
    endif
  endloop
endif
# Setup and plot
#===============
# incl. some pre-forecast periods obs. for plotting
smpl xmax((self.initfc-preobs_fc),1) $tmax
# y-range
scalar mini = min(min(lplot))
scalar maxi = max(max(lplot))
scalar ylo = mini-0.05*abs(mini)
scalar yup = maxi+0.05*abs(maxi)
# TODO: lplot may become A VERY long list -- think about a restriction showing
# only the k last forecasts
if cols(self.fc)!=3
  plot lplot
    options with-lp time-series single-yaxis
    literal set linetype 1 lc rgb &quot;black&quot; lw 1 pt -1
    literal set linetype 2 lc rgb &quot;red&quot; lw 1.25 pt 2 ps 0.5
    literal set linetype 3 lc rgb &quot;blue&quot; lw 1#.25
    literal set linetype 4 lc rgb &quot;black&quot; lw 1#.25
    literal set linetype 5 lc rgb &quot;grey&quot; lw 1#.25
    literal set linetype 6 lc rgb &quot;violet&quot; lw 1#.25 #pt 3 ps 0.5
    literal set linetype 7 lc rgb &quot;brown&quot; lw 1#.25 #pt 4 ps 0.5
    literal set linetype 8 lc rgb &quot;yellow&quot; lw 1#.25 #pt 5 ps 0.5
    literal set linetype 9 lc rgb &quot;red&quot; lw 1#.25 #pt 1 ps 0.5
    literal set linetype 10 lc rgb &quot;green&quot; lw 1#.25
    literal set linetype 10 lc rgb &quot;black&quot; lw 1#.25
    literal set key left bottom below
    #literal set key inside left bottom
    #put the border more to the background by applying it
    # only on the left and bottom part and put it and the tics in gray
    literal set style line 11 lc rgb &quot;#808080&quot; lt 1
    literal set border 3 back ls 11			# get rid of upper + left border
    literal set tics nomirror
    #add a slight grid to make it easier to follow the exact position of the curves
    literal set style line 12 lc rgb &quot;#808080&quot; lt 0 lw 1	# light grey color
    literal set grid back ls 12
    printf &quot;set yrange[%g:%g]&quot;, ylo, yup
    printf &quot;set ylabel \&quot;%s\&quot;&quot;, self.ylab
    printf &quot;set xlabel \&quot;%s\&quot;&quot;, self.xlab
    printf &quot;set title \&quot;%s\&quot;&quot;, self.title
  end plot --output=&quot;@out&quot;
else
  plot lplot
    options with-lines time-series single-yaxis
    literal set linetype 1 lc rgb &quot;black&quot; lw 1 pt -1
    literal set linetype 2 lc rgb &quot;red&quot; lw 1.25 pt 2 ps 0.5
    literal set linetype 3 lc rgb &quot;blue&quot; lw 1.25
    literal set linetype 4 lc rgb &quot;blue&quot; lw 1.25
    literal set key left bottom below
    #literal set key inside left bottom
    #put the border more to the background by applying it
    # only on the left and bottom part and put it and the tics in gray
    literal set style line 11 lc rgb &quot;#808080&quot; lt 1
    literal set border 3 back ls 11			# get rid of upper + left border
    literal set tics nomirror
    #add a slight grid to make it easier to follow the exact position of the curves
    literal set style line 12 lc rgb &quot;#808080&quot; lt 0 lw 1	# light grey color
    literal set grid back ls 12
    printf &quot;set yrange[%g:%g]&quot;, ylo, yup
    printf &quot;set ylabel \&quot;%s\&quot;&quot;, self.ylab
    printf &quot;set xlabel \&quot;%s\&quot;&quot;, self.xlab
    printf &quot;set title \&quot;%s\&quot;&quot;, self.title
  end plot --output=&quot;@out&quot;
endif
</code>
</gretl-function>
<gretl-function name="avgfc_gui" type="matrix" menu-only="1" pkg-role="gui-main">
 <params count="2">
  <param name="y" type="series" const="true">
<description>Series</description>
  </param>
  <param name="h" type="int" min="1" default="10">
<description>Horizon</description>
  </param>
 </params>
<code>/* Helper function for GUI access. */
matrix FC = avgfc(y,h)
printf &quot;%12.4f\n&quot;, FC
return FC
</code>
</gretl-function>
<gretl-function name="isseas" type="scalar" private="1">
<code># flag seasonality
return ($pd&gt;1) ? 1 : 0
</code>
</gretl-function>
<gretl-function name="gen_fc_ival" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Compute forecast interval assuming standard normal. */
if cols(self.fc)==2
  fc = self.fc
  factor = fc[,2]*critical(z, (1-self.level)/2)
  self.fc = fc[,1] ~ (fc[,1]-factor) ~ (fc[,1]+factor)
endif
</code>
</gretl-function>
<gretl-function name="gen_colnam" type="strings" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Construct column names */
strings s = defarray(&quot;Point-Fc&quot;)
if cols(self.fc)==3
  s += sprintf(&quot;Lower (%d)&quot;, self.level*100)
  s += sprintf(&quot;Upper (%d)&quot;, self.level*100)
endif
return s
</code>
</gretl-function>
<gretl-function name="gen_fcdates" type="strings" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code># construct date strings for forecasts
strings r = array(self.h)
# Here we explicitly consider the case when the last obs are missings
matrix date = {$obsdate}[1+obsnum(self.t2_label):]
loop i=1..self.h -q
  string sdate = sprintf(&quot;%d&quot;, date[i])
  if $pd==1
    r[i] = sprintf(&quot;%s&quot;, substr(sdate,1,4))
  elif $pd==4
    r[i] = sprintf(&quot;%s:%s&quot;, substr(sdate,1,4), substr(sdate,5,6))
  else
    r[i] = sprintf(&quot;%s-%s-%s&quot;, substr(sdate,1,4), substr(sdate,5,6), substr(sdate,7,8))
  endif
endloop
return r
</code>
</gretl-function>
<gretl-function name="gen_rownam" type="strings" private="1">
 <params count="1">
  <param name="h" type="scalar"/>
 </params>
<code># construct row names (horizons)
strings r = array(h)
loop i=1..h -q
  r[i] = sprintf(&quot; h=%d&quot;, i)
endloop
return r
</code>
</gretl-function>
<gretl-function name="print_noboot" type="void" private="1">
<code>funcerr &quot;Bootstrap confidence intervals are not supported, yet&quot;
</code>
</gretl-function>
<gretl-function name="default_naiveFC_opts" type="bundle" private="1">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Set default values */
bundle self = null
self.h = 10							# forecast horizon
self.level = 0.9					# probability level for forecast interval
self.fan = 0						# plot fan chart  (not supported yet)
self.nboot = 0						# no. of bootstrap replications  (not supported yet)
self.blength = 4					# Block length bootstrap  (not supported yet)
self.is_seas = isseas()				# check for seasonality
self.verbose = 1					# print details (default: True)
# For NaiveThroughTime()
self.type_roll = &quot;static&quot; 			# &quot;static&quot;, &quot;rolling&quot; or &quot;recursive&quot;
self.wsize = ceil(0.25*nobs(y))		# default window length
# For naivePlot()
string self.title = &quot;&quot;
string self.ylab = &quot;&quot;
string self.xlab = &quot;&quot;
string self.filename = &quot;display&quot;
return self
</code>
</gretl-function>
<gretl-function name="call_method" type="matrix" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Helper function for calling method. */
if self.which!=&quot;avgFC&quot;
  return  do_forecast(&amp;self, self.which)
else
  return avgf(&amp;self)
endif
</code>
</gretl-function>
<gretl-function name="do_forecast" type="matrix" private="1">
 <params count="2">
  <param name="self" type="bundleref"/>
  <param name="method" type="string"/>
 </params>
<code>/* Wrapper function for computing point forecast and intervals. */
if method==&quot;smeanFC&quot; || method==&quot;smedianFC&quot;
  catch period = $obsmicro
  if $error
    period = $obsminor
  endif
  list L = dummify(period)
endif
if self.which==&quot;ar1trendFC&quot; &amp;&amp; inbundle(self, &quot;w_trend&quot;) &amp;&amp; self.w_trend
  genr time
  #list L = time
endif
# Set the training set
if self.type_roll==&quot;static&quot;
  smpl obsnum(self.t1_label) obsnum(self.t2_label)
elif self.type_roll==&quot;rolling&quot; || self.type_roll==&quot;recursive&quot;
  # set to training set
  catch smpl ; ($t2-self.h)
  if $error
    funcerr &quot;Check your sample and window size.&quot;
  endif
endif
# Estimation
series y = self.y
if method==&quot;meanFC&quot;
  ols y 0 --quiet
  fcast ($t2+1) ($t2+self.h) --static --quiet
elif method==&quot;medianFC&quot;
  quantreg 0.5 y const --quiet
  fcast ($t2+1) ($t2+self.h) --static --quiet
elif method==&quot;smeanFC&quot;
  ols y const L --quiet
  fcast ($t2+1) ($t2+self.h) --static --quiet
elif method==&quot;smedianFC&quot;
  quantreg 0.5 y const L --quiet
  fcast ($t2+1) ($t2+self.h) --static --quiet
elif method==&quot;snaiveFC&quot; || method==&quot;snaivedriftFC&quot;
  string arima_opt = (method==&quot;snaiveFC&quot;) ? &quot;--nc&quot; : &quot;&quot;
  arima 0 0 0 ; 0 1 0 ; y @arima_opt --quiet
  fcast ($t2+1) ($t2+self.h) --dynamic --quiet
elif method==&quot;ar1FC&quot; || self.which==&quot;ar1trendFC&quot;
  # setup list of regressors
  list L = const y(-1)
  if inbundle(self, &quot;w_trend&quot;)
    L += trend
  endif
  ols y L --quiet
  fcast ($t2+1) ($t2+self.h) --dynamic --quiet
elif method==&quot;rwFC&quot; || method==&quot;rwdriftFC&quot;
  string arima_opt = (method==&quot;rwFC&quot;) ? &quot;--nc&quot; : &quot;&quot;
  arima 0 1 0 ; y @arima_opt --quiet
  fcast ($t2+1) ($t2+self.h) --dynamic --quiet
endif
/*
# Compute forecast
if self.which!=&quot;ar1trendFC&quot;
  fcast ($t2+1) ($t2+self.h) @fc_option --quiet
else
  fcast ($t2+1) ($t2+self.h) --dynamic --quiet
endif
*/
return $fcast ~ $fcse
</code>
</gretl-function>
<gretl-function name="initial_checks" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Helper function perfoming some initial checks */
strings methods = defarray(&quot;meanFC&quot;, &quot;medianFC&quot;, &quot;avgFC&quot;, &quot;rwFC&quot;, &quot;rwdriftFC&quot;, &quot;ar1FC&quot;, &quot;ar1trendFC&quot;)
strings seas_methods = defarray(&quot;smeanFC&quot;, &quot;smedianFC&quot;, &quot;snaiveFC&quot;, &quot;snaivedriftFC&quot;)
methods += seas_methods
# Check whether called method exists
scalar err = 1
loop i=1..nelem(methods) -q
  if methods[i]==self.which
    err=0
    break
  endif
endloop
if err==1
  funcerr &quot;The forecasting method you selected does not exist.&quot;
endif
if self.is_seas==0
  scalar err = 0
  loop i=1..nelem(seas_methods) -q
    if seas_methods[i]==self.which
      err=1
      break
    endif
  endloop
  if err==1
    funcerr &quot;The method you requested is not available for non-seasonal data.&quot;
  endif
endif
if self.wsize &lt; $pd
  printf &quot;\nError:\n&quot;
  printf &quot;Window size = %d\n&quot;, self.wsize
  printf &quot;Periodicity = %d\n&quot;, $pd
  funcerr &quot;The size of the moving window cannot be smaller than the underlying periodicity.&quot;
endif
if self.nboot&gt;0
  print_noboot()
endif
if (self.type_roll==&quot;rolling&quot; || self.type_roll==&quot;recursive&quot;) &amp;&amp; self.which==&quot;avgFC&quot;
  printf &quot;Error: Automatic forecast averaging ('avgfc') is currently not compatible\n&quot;
  printf &quot;with moving forecasts.\n&quot;
  funcerr &quot;Re-specify.&quot;
endif
</code>
</gretl-function>
<gretl-function name="summarize_naive_fc" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Print summarising information */
printf &quot;****************************************************\n&quot;
printf &quot;\t\tNaive Forecasting Method\n&quot;
printf &quot;\nForecasting method: \t\t\t%s\n&quot;, self.which
printf &quot;Start valid data set: \t\t\t%s\n&quot;, self.t1_label
printf &quot;End valid data set: \t\t\t%s\n&quot;, self.t2_label
printf &quot;Number of observations: \t\t%d\n&quot;, obsnum(self.t2_label)-obsnum(self.t1_label)
printf &quot;Forecast horizon: \t\t\t%d\n&quot;, self.h
if self.type_roll==&quot;static&quot;
  printf &quot;First observation forecasted: \t\t%s\n&quot;, obslabel(obsnum(self.t2_label)+1)
  if self.which!=&quot;avgFC&quot;
    printf &quot;Width forecast interval: \t\t%d pct.\n&quot;, self.level*100
  endif
else
  printf &quot;Moving window length: \t\t\t%d\n&quot;, self.wsize
  printf &quot;Number of %s forecasts: \t\t%d\n&quot;, self.type_roll, rows(self.fc)
  printf &quot;First observation forecasted (h=1): \t%s\n&quot;, obslabel(self.initfc)
endif
printf &quot;****************************************************\n&quot;
printf &quot;\n&quot;
</code>
</gretl-function>
<gretl-function name="nobs_to_add" type="scalar" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Determine the number of additional observations to add to the dataset. */
smpl y --contiguous
t2_new = $t2				# don't consider eventual missings in the data passed to naiveFC()
return self.h - ($tmax-t2_new)
</code>
</gretl-function>
<gretl-function name="drop_missings" type="void" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Drop missing values + construct a contiguous data set. */
self.T_all = $nobs  # no. of obs of the original dataset passed, may incl. missings
smpl y --contiguous
self.t1_label = obslabel($t1)
self.t2_label = obslabel($t2)
self.T = $nobs		# no. of valid obs before adding obs. for forecasting purpose
if self.T&lt;self.T_all &amp;&amp; !self.verbose
  printf &quot;\nWarning: The time-series sample has been restricted\n&quot;
  printf &quot;due to %d missing values in the original dataset.\n&quot;, (self.T_all-$nobs)
  printf &quot;Information on the new contiguous set:\n&quot;
  printf &quot;Start date: %s\n&quot;, obslabel($t1)
  printf &quot;End date: %s\n&quot;, obslabel($t2)
  printf &quot;\n&quot;
endif
</code>
</gretl-function>
<gretl-function name="avgf" type="matrix" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Computes the mean (average) and cross-sectional
(across forecast methods) standard deviation at
each horizon using all simple forecast methods
available. */
# Models for both seasonal and non-seasonal frequencies (grab only point forecasts)
matrix FC = do_forecast(&amp;self, &quot;meanFC&quot;)[,1] ~ do_forecast(&amp;self, &quot;medianFC&quot;)[,1] ~ do_forecast(&amp;self, &quot;rwFC&quot;)[,1] ~ do_forecast(&amp;self, &quot;rwdriftFC&quot;)[,1] ~ do_forecast(&amp;self, &quot;ar1FC&quot;)[,1] ~ do_forecast(&amp;self, &quot;ar1trendFC&quot;)[,1]
# Models for seasonal frequencies only
if self.is_seas
  FC ~= do_forecast(&amp;self, &quot;smeanFC&quot;)[,1] ~ do_forecast(&amp;self, &quot;smedianFC&quot;)[,1] ~ do_forecast(&amp;self, &quot;snaiveFC&quot;)[,1] ~ do_forecast(&amp;self, &quot;snaivedriftFC&quot;)[,1]
endif
# Cross-sectional forecast-combination statistics
FC = meanr(FC) ~ sdc(FC', rows(FC')-1)' ~ FC
# Add column names
strings method_names = strsplit(&quot;Average-FC SD Mean Median RW RW+Drift AR(1) AR(1)+Trend&quot;, &quot; &quot;)
if self.is_seas
  method_names += strsplit(&quot;Seas-Mean Seas-Median Seas-Naive Seas-Naive+Drift&quot;, &quot; &quot;)
endif
self.method_names = method_names
return FC
</code>
</gretl-function>
<gretl-function name="NaiveThroughTime" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* This function estimates the point forecasts either in (i) a rolling or
(ii) a recursive manner and stores a sequence of point forecasts */
if $nobs&lt;self.wsize
  printf &quot;\nError: The window size you selected (wsize=%d) exceeds the\n           no. of valid observations.\n&quot;, self.wsize
  funcerr &quot;Re-specify.&quot;
endif
include CvDataSplitter.gfn		# load another external package
series y = self.y
list X = y						# a list must be passed to data splitter
# Set data splitter using the valid observation set w.o. obs. addiotnally added for forecasting
smpl obsnum(self.t1_label) obsnum(self.t2_label)
bundle cv = null
list cv.X = X
string cv.cv_type = (self.type_roll==&quot;rolling&quot;) ? &quot;rolwin&quot; : &quot;recwin&quot;
scalar cv.win_size = self.wsize
CvDataSplitter(&amp;cv)
/* Required seto, as CvDataSplitter() doesn't consider the very last obs in
the final training set for 'rolwin' and 'recwin'. */
cv.X_train += cv.X_train[cv.n_folds] | ({$t2}~{y[$t2]})
cv.n_folds++
/*	For debugging only
matrices X_train = cv.X_train
loop i=1..cv.n_folds -q
  eval X_train[i]
  if i==cv.n_folds
    stop
  endif
endloop
*/
# Loop over training sets
matrix self.fc = zeros(cv.n_folds, self.h)
loop lwin=1..cv.n_folds -q
  mat = cv.X_train[lwin]
  smpl minc(mat[,1]) maxc(mat[,1])		# read time index of the training set
  # 1st obs being forecasted (h=1) based on information up to (self.initfc-1)
  scalar self.initfc = (lwin==1) ? (1+maxc(mat[,1])) : self.initfc
  self.fc[lwin,] = call_method(&amp;self)[,1]'	# compute point forecast
endloop
# Attach column names
cnameset(self.fc, gen_rownam(self.h))
# Attach rownames: on rows we put date strings referring to
# the information set (time/ date) based on which the h-step
# ahead forecast is computed for.
strings self.fcperiods = array(cv.n_folds)
loop i=1..cv.n_folds -q
  # NOTE: obslabel(self.initfc+$i-2): for i==1 the data refers to the 1st day
  # based on which the first h=1,...,H OoS-forecasts are made.
  self.fcperiods[i] = sprintf(&quot;%s&quot;, obslabel(self.initfc+$i-2) )
endloop
rnameset(self.fc, self.fcperiods)
</code>
</gretl-function>
<gretl-function name="avgfc" type="matrix" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="h" type="int">
<description>Forecast horizon</description>
  </param>
 </params>
<code>/* Wrapper called by avgfc_gui. */
# Models for both seasonal and non-seasonal frequencies
bundle self = default_naiveFC_opts(y)
series self.y = y
scalar self.h = h
string self.which=&quot;avgFC&quot;
# Check whether method is applicable
initial_checks(&amp;self)
# Drop missings + determine number of obs.
drop_missings(y, &amp;self)
# smpl obsnum(self.t1_label) obsnum(self.t2_label) # restrict to valid set
# Add obs for forecasting
self.obs_added = nobs_to_add(y, &amp;self)
dataset addobs self.obs_added
# update
series self.y = y
matrix FC = meanf(&amp;self)
FC ~= medianf(&amp;self) ~ rwf(&amp;self)
self.w_drift = 1
FC ~= rwf(&amp;self) ~ ar1f(&amp;self)[,1]
self.w_trend = 1
FC ~= ar1f(&amp;self)[,1]
# Models for seasonal frequencies only
if self.is_seas
  FC ~= smeanf(&amp;self) ~ smedianf(&amp;self) ~ snaive(&amp;self) ~ snaivedrift(&amp;self)
endif
# Cross-sectional forecast-combination statistics
FC = meanr(FC) ~ sdc(FC', rows(FC')-1)' ~ FC
# Add column names
strings method_names = strsplit(&quot;Average-FC SD Mean Median RW RW+Drift AR(1) AR(1)+Trend&quot;, &quot; &quot;)
if self.is_seas
  method_names += strsplit(&quot;Seas-Mean Seas-Median Seas-Naive&quot;, &quot; &quot;)
endif
method_names = method_names
# Add row + column names
cnameset(FC, method_names)
rnameset(FC, gen_fcdates(&amp;self)) #gen_rownam(self.h))
if self.verbose
  summarize_naive_fc(&amp;self)
endif
return FC
</code>
</gretl-function>
<sample-script>
clear
set verbose off

include naiveFC.gfn --force

# Select an example
#==================
scalar runEX = 2

# Load data
if runEX==1
    open nysewk.gdt -q		# daily, 7d
    series y = close
elif runEX==2
    open AWM.gdt -q			# quarterly
    series y = YGA
elif runEX==3
    open hendry_jae.gdt -q	# annual
    series y = diff(gdp)
elif runEX==4
    open hall.gdt -q		# monthly
    series y = ewr
endif

#=======================
# Static naive forecasts
#=======================

# Forecast combination
bundle b = null
b = naiveFC(y, &quot;avgFC&quot;)		# compute forecasts
naivePlot(&amp;b)				# plot forecast results
print b
eval b.fc					# print forecast results

# Forecast combination but up to h=15 forecast periods
bundle opt = null					# set specific options
scalar opt.h = 15
bundle b = naiveFC(y, &quot;avgFC&quot;, opt)
b.preobs_fc = 5					# optional: set no. of pre.-forecast periods obs. to plot
naivePlot(&amp;b)

# Mean forecast
bundle b = naiveFC(y, &quot;meanFC&quot;)
naivePlot(&amp;b)
eval b.fc

# Median forecast
bundle b = naiveFC(y, &quot;medianFC&quot;)
naivePlot(&amp;b)
eval b.fc

# Random-Walk
bundle b = naiveFC(y, &quot;rwFC&quot;)
naivePlot(&amp;b)
eval b.fc

# Random-Walk + Drift
bundle b = naiveFC(y, &quot;rwdriftFC&quot;)
naivePlot(&amp;b)
eval b.fc

# AR(1)
b = null
bundle b = naiveFC(y, &quot;ar1FC&quot;)
naivePlot(&amp;b)
eval b.fc

# AR(1) + Trend
bundle b = naiveFC(y, &quot;ar1trendFC&quot;)
naivePlot(&amp;b)
eval b.fc

# Seasonal mean
bundle b = naiveFC(y, &quot;smeanFC&quot;)
naivePlot(&amp;b)
eval b.fc

# Seasonal median
bundle b = naiveFC(y, &quot;smedianFC&quot;)
naivePlot(&amp;b)
eval b.fc

# Seasonal naive without drift
bundle b = naiveFC(y, &quot;snaiveFC&quot;)
naivePlot(&amp;b)
eval b.fc

# Seasonal naive with drift
bundle b = naiveFC(y, &quot;snaivedriftFC&quot;)
naivePlot(&amp;b)
eval b.fc


/* ACTIVATE IF WANTED: may take a while
#=========================
# Moving-window forecasts
#=========================
bundle opts = null					# setup additional options
opts.type_roll = &quot;rolling&quot; 			# &quot;rolling&quot; / &quot;recursive&quot; -&gt; type of moving-window forecasting  (optional)
opts.wsize = xmax($pd, 80) 			# moving window length (optional)
#opts.verbose = 0					# Don't print details (optional)

# Select methods 
methods = defarray(&quot;meanFC&quot;) #, &quot;medianFC&quot;, &quot;rwFC&quot;, &quot;rwdriftFC&quot;, &quot;smeanFC&quot;, &quot;smedianFC&quot;, &quot;snaiveFC&quot;, \
#  &quot;snaivedriftFC&quot;, &quot;ar1FC&quot;, &quot;ar1trendFC&quot;)
loop i=1..nelem(methods) -q
    bundle b = null
    eval methods[i]
    bundle b = naiveFC(y, methods[i], opts)
    eval b.fc
    
    # Plot (optional)
    b.preobs_fc = 5					# set no. of pre.-forecast periods obs. to plot
    naivePlot(&amp;b)
endloop

*/
</sample-script>
</gretl-function-package>
</gretl-functions>
