set verbose off

function scalar isseas (void)
    # flag seasonality
    return ($pd>1) ? 1 : 0
end function


function strings gen_colnam (matrix ci)
    # construct column names
    strings c = defarray("Point-Fc")
    /* confidence intervals are not supported yet
       loop i=1..cols(ci) -q
       c += sprintf(" q%d", ci[i]*100)
       endloop
    */
    return c
end function


function strings gen_rownam (scalar h)
    # construct row names (horizons)
    strings r = array(h)
    loop i=1..h -q
        r[i] = sprintf(" h=%d", i)
    endloop
    return r
end function


function void print_noboot()
    funcerr "Bootstrap confidence intervals are not supported, yet"
end function


function void gen_season_series (bundle *self)
/* Generates a series indicating the separate seasonal
    periods. */
    list s = seasonals() 	# returns e.g. S1...S52 for weekly data
    series obs_season = NA
    if nelem(s)==$pd
        loop i=1..$pd -q
            obs_season = (S$i == 1) ? i : obs_season
        endloop
        self.obs_season = obs_season
        #return self
    else
        funcerr "Periodicity ($pd) does not correspond to what seasonals() in fact returns."
    endif
end function


function matrix get_mean_obsminor (bundle *self)
/* Helper function for obtaining for each periodicity
    (quarterly=4,monthly=12, weekly=52, etc.) the mean/ median value.*/
    # TODO: in principle one could get the mean for instance for
    # weekly data on the monthly, weekly or daily frequency level.

    string ops = (self.use_median==1) ? "median" : "mean"
    # construct seasonal indicator series
    gen_season_series(&self)
    matrix ybar = aggregate(self.y, self.obs_season, @ops)[,3] # $pd by 1 vector
    return stack_fc(&self, ybar)
end function


function matrix stack_fc (bundle *self, matrix ybar)
/* Check which value $obsminor takes for the last obs.
    Do some re-ordering. */
    matrix val_obs_season = values(self.obs_season)

    # Re-order fc to make sure that 1st forecast
    # corresponds to the right month, quarter etc.
    if self.obs_season[$tmax] < max(val_obs_season)		# last quarter/month/day-of-week
        matrix selmat = 0 * vec(seq(min(val_obs_season), max(val_obs_season)) )
        scalar counter = self.obs_season[$tmax] + 1
        loop i=1..rows(selmat) -q
            selmat[counter] = $i #val_obs_season[i]			# set position after $tmax
            counter = (counter==max(val_obs_season)) ? 1 : (counter+1)
        endloop
        ybar_sorted = msortby(ybar~selmat,2)[,1]
    endif

    # Construct h-step ahead forecasts
    scalar k = ceil(self.h/rows(ybar_sorted))		# No. of necessary stackings
    ybar = ones(rows(ybar_sorted),k) .* ybar_sorted	# pd by k
    return vec(ybar)[1:self.h]
end function


function bundle default_naiveFC_opts (const series y)
    # Set default values

    bundle self = null
    self.h = 10							# forecast horizon
    self.level = 90						# Confidence level (not supported yet)
    self.fan = 0						# plot fan chart  (not supported yet)
    self.nboot = 0						# no. of bootstrap replications  (not supported yet)
    self.blength = 4					# Block length bootstrap  (not supported yet)
    self.is_seas = isseas()
    self.verbose = 1					# print details (default: True)

    # For NaiveThroughTime()
    self.type_roll = "static" 			# "static", "rolling" or "recursive"
    self.wsize = ceil(0.25*nobs(y))		# default window length

    return self
end function


function matrix call_method (bundle *self)
    /* Helper function for running actual model. */

    if self.which=="meanFC"
        return meanf(&self)
    elif self.which=="medianFC"
        return medianf(&self)
    elif self.which=="ar1FC"
        return ar1f(&self)
    elif self.which=="ar1trendFC"
        self.w_trend = 1
        return ar1f(&self)
    elif self.which=="rwFC"
        return rwf(&self)
    elif self.which=="rwdFC"
        self.w_drift = 1
        return rwf(&self)

        # For seasonal series only
        #------------------------
    elif self.which=="smeanFC"
        return smeanf(&self)
    elif self.which=="smedianFC"
        self.use_median = 1
        return smeanf(&self)
    elif self.which=="snaiveFC"
        self.use_median = 1
        return snaive(&self)
    elif self.which=="avgFC" # forecast combination
        return avgf(&self)
    endif

end function


function matrix NaiveThroughTime (bundle *self)
/* This function estimates the point estimates in either (i) a
    rolling or (ii) recursive manner and stores these point estimates. */

    # Data set settings
    #-------------------
    # add new obs. for built-in estimation and forecast methods e.g. "ols", "arima"
    dataset addobs self.h

    scalar self.initobs = $t1
    scalar self.obsend = self.initobs + self.wsize
    scalar self.nsteps = $t2 - self.obsend - self.h		# no. of windows
    smpl self.initobs self.obsend
    if self.verbose
        printf "\n*********************************************************************\n"
        printf "Initial effective sample used: %s to %s (T=%d)\n", obslabel($t1), obslabel($t2), ($t2-$t1)
        printf "Number of %s estimations = %d\n", self.type_roll, self.nsteps
        printf "Initial 1-step ahead forecast will be computed for %s\n", obslabel($t2+1)
    endif

    matrix FC = zeros(self.nsteps, self.h)

    # START ESTIMATION
    #==================
    loop lwin = 1..self.nsteps -q

        if lwin == self.nsteps
            scalar self.lastfc = 1+$t2	# last obs. used for forecast being forecasted
            if self.verbose
                printf "Last forecast will be computed for %s\n", obslabel(self.lastfc)
                printf "*********************************************************************\n"
                printf "\n"
            endif
        endif

        smpl $t1 $t2
        if lwin == 1
            scalar self.initfc = 1+$t2			# 1st obs being forecasted (h=1)
        endif

        # COMPUTE and store FCs
        FC[lwin,] = call_method(&self)'

        # Shift in time
        if lwin < self.nsteps
            if self.type_roll == "recursive"
                smpl ; +1
            elif self.type_roll == "rolling"
                smpl +1 +1
            endif
        endif

    endloop		# END bwin-loop

    # adjust rows to make sure that each 'h' refers to the same period being forecasted
    matrix FCret = FC[,1]
    loop i=1..(self.h-1) -q
        FCret ~= mlag(FC[,i+1],$i, NA)
    endloop

    return FCret

end function


function matrix ar1f (bundle *self)
/* Returns forecasts from an AR(1) model
    either with or without linear trend. */

    scalar h = self.h
    series y = self.y
    t2 = $t2

    if self.type_roll=="static"
        # add new obs.
        dataset addobs self.h
    endif

    # setup list of regressors
    list L = 0 y(-1)
    if inbundle(self, "w_trend")
        if self.w_trend
            genr time
            L += time
        endif
    endif

    # set training set
    smpl ; t2
    # Estimate
    ols y L --quiet
    
    # Set test set and forecast
    string start = obslabel(1+t2)
    string ende = obslabel(t2+self.h)
    fcast @start @ende --dynamic --quiet

    return $fcast #~ $fcse
end function


function void initial_checks (bundle *self)
    /* Helper function perfoming some initial checks */

    if self.is_seas==0
        funcerr "The method you requested is not available for annual data."
    endif

    if self.nboot>0
        print_noboot()
    endif

    if (self.type_roll=="rolling" || self.type_roll=="recursive") && self.which=="avgFC"
        printf "Error: Automatic forecast averaging ('avgfc') is currently not compatible\n"
        printf "with moving forecasts."
        funcerr ""
    endif
end function


function bundle naiveFC (const series y,
                         string which "Select method",
                         bundle opts[null])

    /*=======================*/
    /* Main package function */
    /*=======================*/

    # Set up the bundle
    bundle self = default_naiveFC_opts(y)
    if exists(opts)
        # override defaults
        self = opts + self
    endif

    self.which = which

    # Check whether method is applicable
    initial_checks(&self)

    # drop missings
    T = $nobs
    smpl y --contiguous
    if $nobs<T && self.verbose
        printf "\nThe contiguous time-series sample has been restricted\n"
        printf "due to %d missing values in the original dataset.\n", (T-$nobs)
        printf "\n"
    endif

    series self.y = y

    # call method
    #==============
    if self.type_roll=="static"

        matrix fc = call_method(&self)
        # add column/ row strings
        if which != "avgFC"
            cnameset(fc, gen_colnam(fc))
        else
            cnameset(fc, self.method_names)
        endif
        rnameset(fc, gen_rownam(self.h))


    elif self.type_roll=="rolling" || self.type_roll=="recursive"
        /* NaiveThroughTime */

        matrix fc = NaiveThroughTime(&self)

        # add column/ row strings
        cnameset(fc, gen_rownam(self.h))
        # attach rownames: on rows we put date strings
        strings fcperiods = array(self.nsteps)
        loop i=1..self.nsteps -q
            fcperiods[i] = sprintf("%s", obslabel(self.initfc+$i-1) )
        endloop
        rnameset(fc, fcperiods)
    endif

    # attache output matrix to bundle
    self.fc = fc

    return self
end function


function matrix avgf (bundle *self)
/* Computes the mean (average) and cross-sectional
   (across forecast methods) standard deviation at
   each horizon using all simple forecast methods
    available.*/

    # Models for both seasonal and non-seasonal frequencies
    matrix FC = meanf(&self)
    FC ~= medianf(&self)
    FC ~= rwf(&self)
    self.w_drift = 1
    FC ~= rwf(&self)
    FC ~= ar1f(&self)
    self.w_trend = 1
    FC ~= ar1f(&self)

    # Models for both seasonal frequencies only
    if self.is_seas
        self.use_median = 0
        FC ~= smeanf(&self)
        self.use_median = 1
        FC ~= smeanf(&self)
        FC ~= snaive(&self)
    endif

    # cross-sectional forecast-combination statistics
    FC = meanr(FC) ~ sdc(FC', rows(FC')-1)' ~ FC

    # Add column names
    strings method_names = strsplit("Average-FC SD Mean Median RW RW+Drift AR(1) AR(1)+Trend", " ")
    if self.is_seas
        method_names += strsplit("Seas-Mean Seas-Median Seas-Naive", " ")
    endif
    self.method_names = method_names

    return FC
end function


function matrix meanf (bundle *self)
/* Forecasts of all future values are equal to the mean
    of the historical data*/
    return ones(self.h, 1) .* mean(self.y)
end function


function matrix medianf (bundle *self)
/* Forecasts of all future values are equal to the median
    # of the historical data*/
    return ones(self.h, 1) .* median(self.y)
end function


function matrix smeanf (bundle *self)
/* Forecasts of all future values are equal to the mean of
   the respective historical seasonal period
    where m is the seasonal period.*/
    return get_mean_obsminor(&self)
end function


function matrix rwf (bundle *self)
/* Naïve forecast is optimal when data follow a random-walk
    or random-walk + drift. */
    matrix fc = ones(self.h,1) .* self.y[$t2]
    if inbundle(self,"w_drift")
        if self.w_drift
            # equivalent to an ARIMA(0,1,0) model with an optional drift coefficient
            scalar avg = (self.y[$t2]-self.y[$t1])/(nobs(self.y)-1)	# average growth rate
            return fc .+ cum(ones(self.h,1)) * avg
        else
            return fc
        endif
    else
        return fc
    endif
end function


function matrix snaive (bundle *self)
/* Returns forecasts from an ARIMA(0,0,0)(0,1,0)
    model where m is the seasonal period.*/
    series y = self.y
    t2 = $t2
    if self.type_roll=="static"
        # add new obs.
        dataset addobs self.h
    endif

    # set to training set
    smpl ; t2
    # Estimate
    arima 0 0 0 ; 0 1 0 ; y --quiet

    # Set test set and forecast
    string start = obslabel(1+t2)
    string ende = obslabel(t2+self.h)
    # Forecast
    fcast @start @ende --dynamic --quiet
    return $fcast #~ $fcse
end function


function void naivePlot (bundle *self "Bundle returned from naiveFC()")
    /* Function for plotting actual and forecast values over time. */

    # Plot point forecast
    string title = !inbundle(self,"title") ? "" : self.title
    string ylab = !inbundle(self,"ylab") ? "" : self.ylab
    string xlab = !inbundle(self,"xlab") ? "" : self.xlab
    string out = !inbundle(self,"filename") ? "display" : self.filename
    scalar T = $nobs
    # no. of pre-forecast obs. to plot
    scalar preobs_fc = !inbundle(self,"preobs_fc") ? int(0.25 * T) : self.preobs_fc

    series y = self.y

    # Add future obs.
    dataset addobs self.h		# automatically increases $t2
    /* Doesn't work
       scalar t2 = $t2
       string start = obslabel(t2+1)
       string ende = obslabel($t2)
       start
       ende
       smpl (t2+1) ;
    */
    # workaround
    matrix zeromat = zeros(T,cols(self.fc))
    zeromat = (zeromat.=0) ? NA : zeromat
    matrix mfc = (zeromat | self.fc)
    scalar init_date = xmax(($nobs-preobs_fc-self.h),1)
    smpl init_date ; #($nobs-preobs_fc-self.h) ;

    # Prepare lists for plotting
    setinfo y --graph-name="Actuals"
    list lplot = y
    loop i=1..cols(self.fc) -q
        if i!=2			#i==2 refers to S.D.
            series fc_$i = mfc[,i]
            if self.which=="avgFC"
                str = sprintf("%s", self.method_names[i])
                setinfo fc_$i --graph-name="@str"
            else
                setinfo fc_$i --graph-name="Point-Fc"
            endif
            lplot += fc_$i
        endif
    endloop

    # Setup and plot
    mini = min(min(lplot))
    maxi = max(max(lplot))
    scalar ylo = mini-0.05*mini
    scalar yup = maxi+0.05*maxi
    plot lplot
        options with-lp time-series single-yaxis
        literal set linetype 1 lc rgb "black" lw 1 pt -1
        literal set linetype 2 lc rgb "red" lw 1.25 #pt 2 ps 0.5
        literal set linetype 3 lc rgb "blue" lw 1.25
        literal set linetype 4 lc rgb "black" lw 1.25
        literal set linetype 5 lc rgb "grey" lw 1.25
        literal set linetype 6 lc rgb "violet" lw 1.25 #pt 3 ps 0.5
        literal set linetype 7 lc rgb "brown" lw 1.25 #pt 4 ps 0.5
        literal set linetype 8 lc rgb "yellow" lw 1.25 #pt 5 ps 0.5
        literal set linetype 9 lc rgb "red" lw 1.25 #pt 1 ps 0.5
        literal set linetype 10 lc rgb "green" lw 1.25
        literal set linetype 10 lc rgb "black" lw 1.25
        literal set key left bottom below
        #literal set key inside left bottom
        #put the border more to the background by applying it
        # only on the left and bottom part and put it and the tics in gray
        literal set style line 11 lc rgb "#808080" lt 1
        literal set border 3 back ls 11			# get rid of upper + left border
        literal set tics nomirror
        #add a slight grid to make it easier to follow the exact position of the curves
        literal set style line 12 lc rgb "#808080" lt 0 lw 1	# light grey color
        literal set grid back ls 12
        printf "set yrange[%g:%g]", ylo, yup
        printf "set ylabel \"%s\"", ylab
        printf "set xlabel \"%s\"", xlab
        printf "set title \"%s\"", title
    end plot --output="@out"
end function



# Example
#============
clear

scalar runEX = 2

if runEX==1
    open nysewk.gdt -q
    series y = close
elif runEX==2
    open denmark.gdt -q
    series y = diff(LRM)
endif

# Call methods
#==================
bundle opt = null
scalar opt.h = 15
bundle b = naiveFC(y, "avgFC", opt)

# Plot realization and forecast(s)
b.preobs_fc = 25				# set no. of pre.-forecast periods obs. to plot
naivePlot(&b)
eval b.fc
stop

bundle b = naiveFC(close, "medianFC")
eval b.fc

bundle b = naiveFC(close, "rwFC")
eval b.fc
bundle b = naiveFC(close, "rwdFC")
eval b.fc

bundle b = naiveFC(close, "smeanFC")
eval b.fc
bundle b = naiveFC(close, "smedianFC")
eval b.fc
bundle b = naiveFC(close, "snaiveFC")		# seems buggy!
eval b.fc
#naivePlot(&b)			#
#stop

bundle b = naiveFC(close, "ar1FC")
eval b.fc
bundle b = naiveFC(close, "ar1trendFC")
eval b.fc

# Forecast combination
bundle b = naiveFC(close, "avgFC")
eval b.fc
stop

# Rolling-window forecasting
#===========================
bundle opts = null				# setup additional options
opts.type_roll = "rolling"		# type of moving-window forecasting
opts.wsize = 100				# window length
opts.verbose = 0				# don't print details

bundle b = naiveFC(close, "meanFC", opts)
#eval b.fc







