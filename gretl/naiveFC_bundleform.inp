set verbose off

function scalar isseas (void)
    # flag seasonality
    return ($pd>1) ? 1 : 0
end function


function strings gen_colnam (matrix ci)
    # construct column names
    strings c = defarray("Point-Fc")
    /* confidence intervals are not supported yet
       loop i=1..cols(ci) -q
       c += sprintf(" q%d", ci[i]*100)
       endloop
    */
    return c
end function


function strings gen_rownam (scalar h)
    # construct row names (horizons)
    strings r = array(h)
    loop i=1..h -q
        r[i] = sprintf(" h=%d", i)
    endloop
    return r
end function


function void print_noboot()
    funcerr "Bootstrap confidence intervals are not supported, yet"
end function


function void gen_season_series (bundle *self)
/* Generates a series indicating the separate seasonal
    periods. */
    list s = seasonals() 	# returns e.g. S1...S52 for weekly data
    series obs_season = NA
    if nelem(s)==$pd
        loop i=1..$pd -q
            obs_season = (S$i == 1) ? i : obs_season
        endloop
        self.obs_season = obs_season
        #return self
    else
        funcerr "Periodicity ($pd) does not correspond to what seasonals() in fact returns."
    endif
end function


function matrix get_mean_obsminor (bundle *self, int use_median[0])
/* Helper function for obtaining for each periodicity
    (quarterly=4,monthly=12, weekly=52, etc.) the mean/ median value.*/
    # TODO: in principle one could get the mean for instance for
    # weekly data on the monthly, weekly or daily frequency level.

    string ops = (use_median==1) ? "median" : "mean"
    # construct seasonal indicator series
    gen_season_series(&self)
    matrix ybar = aggregate(self.y, self.obs_season, @ops)[,3] # $pd by 1 vector
    return stack_fc(&self, ybar)
end function


function matrix stack_fc (bundle *self, matrix ybar)
/* Check which value $obsminor takes for the last obs.
    Do some re-ordering. */
    matrix val_obs_season = values(self.obs_season)

    # Re-order fc to make sure that 1st forecast
    # corresponds to the right month, quarter etc.
    if self.obs_season[$tmax] < max(val_obs_season)		# last quarter/month/day-of-week
        matrix selmat = 0 * vec(seq(min(val_obs_season), max(val_obs_season)) )
        scalar counter = self.obs_season[$tmax] + 1
        loop i=1..rows(selmat) -q
            selmat[counter] = $i #val_obs_season[i]			# set position after $tmax
            counter = (counter==max(val_obs_season)) ? 1 : (counter+1)
        endloop
        ybar = msortby(ybar~selmat,2)[,1]
    endif

    # Construct h-step ahead forecasts
    scalar k = ceil(self.h/rows(ybar))		# No. of necessary stackings
    ybar = ones(rows(ybar),k) .* ybar	# pd by k
    return vec(ybar)[1:self.h]
end function


function bundle default_naiveFC_opts (const series y)
    # Set default values

    bundle self = null
    self.h = 10							# forecast horizon
    self.level = 90						# Confidence level (not supported yet)
    self.fan = 0						# plot fan chart  (not supported yet)
    self.nboot = 0						# no. of bootstrap replications  (not supported yet)
    self.blength = 4					# Block length bootstrap  (not supported yet)
    self.is_seas = isseas()
    self.verbose = 1					# print details (default: True)

    # For NaiveThroughTime()
    self.type_roll = "static" 			# "static", "rolling" or "recursive"
    self.wsize = ceil(0.25*nobs(y))		# default window length

    return self
end function


function matrix call_method (bundle *self)
    /* Helper function for running actual model. */

    if self.which=="meanFC"
        return meanf(&self)
    elif self.which=="medianFC"
        return medianf(&self)
    elif self.which=="ar1FC"
        return ar1f(&self)
    elif self.which=="ar1trendFC"
        self.w_trend = 1
        return ar1f(&self)
    elif self.which=="rwFC"
        return rwf(&self)
    elif self.which=="rwdFC"
        self.w_drift = 1
        return rwf(&self)

        # For seasonal series only
        #------------------------
    elif self.which=="smeanFC"
        return smeanf(&self)
    elif self.which=="smedianFC"
        return smedianf(&self)
    elif self.which=="snaiveFC"
        #        self.use_median = 1
        return snaive(&self)
    elif self.which=="avgFC" # forecast combination
        return avgf(&self)
    endif

end function


function matrix ar1f (bundle *self)
/* Returns forecasts from an AR(1) model
    either with or without linear trend. */

    scalar h = self.h
    series y = self.y
    t2 = $t2

    if self.type_roll=="static"
        # add new obs.
        dataset addobs self.h
    elif self.type_roll=="rolling" || self.type_roll=="recursive"
        # when called via NaiveThroughTime(), 'dataset' cmd
        # is not applicable
        t2 -= self.h
    endif

    # setup list of regressors
    list L = 0 y(-1)
    if inbundle(self, "w_trend")
        if self.w_trend
            genr time
            L += time
        endif
    endif

    # set training set
    smpl ; t2
    # Estimate
    ols y L --quiet

    # Set test set and forecast
    string start = obslabel(1+t2)
    string ende = obslabel(t2+self.h)
    fcast @start @ende --dynamic --quiet

    return $fcast #~ $fcse
end function


function matrix snaive (bundle *self)
/* Returns forecasts from an ARIMA(0,0,0)(0,1,0)
    model where m is the seasonal period.*/
    series y = self.y
    t2 = $t2

    if self.type_roll=="static"
        # add new obs.
        dataset addobs self.h
    elif self.type_roll=="rolling" || self.type_roll=="recursive"
        # when called via NaiveThroughTime(), 'dataset' cmd
        # is not applicable
        t2 -= self.h
    endif

    # set to training set
    smpl ; t2

    # Estimate
    arima 0 0 0 ; 0 1 0 ; y --quiet

    # Set test set and forecast
    string start = obslabel(1+t2)
    string ende = obslabel(t2+self.h)
    # Forecast
    fcast @start @ende --dynamic --quiet
    return $fcast #~ $fcse
end function


function void initial_checks (bundle *self)
    /* Helper function perfoming some initial checks */

    strings methods = defarray("meanFC", "medianFC", "avgFC", "rwFC", "rwdFC", \
      "smeanFC", "smedianFC", "snaiveFC", "ar1FC", "ar1trendFC")
    scalar warn = 1
    loop i=1..nelem(methods) -q
        if methods[i]==self.which
            warn=0
            break
        endif
    endloop
    if warn==1
        funcerr "The forecasting method you selected does not exist."
    endif

    if self.is_seas==0
        funcerr "The method you requested is not available for non-seasonal data."
    endif

    if self.nboot>0
        print_noboot()
    endif

    if (self.type_roll=="rolling" || self.type_roll=="recursive") && self.which=="avgFC"
        printf "Automatic forecast averaging ('avgfc') is currently not compatible\n"
        printf "with moving forecasts."
        funcerr ""
    endif
end function


function bundle naiveFC (const series y,
                         string which "Select method",
                         bundle opts[null])

    /*=======================*/
    /* Main package function */
    /*=======================*/

    # Set up the bundle
    bundle self = default_naiveFC_opts(y)
    if exists(opts)
        # override defaults
        self = opts + self
    endif

    self.which = which

    # Check whether method is applicable
    initial_checks(&self)

    # drop missings
    T = $nobs
    smpl y --contiguous
    if $nobs<T && self.verbose
        printf "\nThe contiguous time-series sample has been restricted\n"
        printf "due to %d missing values in the original dataset.\n", (T-$nobs)
        printf "\n"
    endif

    series self.y = y

    # call method
    #==============
    if self.type_roll=="static"

        matrix fc = call_method(&self)
        # add column/ row strings
        if which != "avgFC"
            cnameset(fc, gen_colnam(fc))
        else
            cnameset(fc, self.method_names)
        endif
        rnameset(fc, gen_rownam(self.h))

        # attache output matrix to bundle
        self.fc = fc

    elif self.type_roll=="rolling" || self.type_roll=="recursive"
        /* NaiveThroughTime */

        #matrix fc = NaiveThroughTime(&self)
        NaiveThroughTime(&self)

        /*
           # add column/ row strings
           cnameset(fc, gen_rownam(self.h))
           # attach rownames: on rows we put date strings
           strings fcperiods = array(self.nsteps)
           loop i=1..self.nsteps -q
           fcperiods[i] = sprintf("%s", obslabel(self.initfc+$i-1) )
           endloop
           rnameset(fc, fcperiods)
        */
    endif


    return self
end function


function matrix avgf (bundle *self)
/* Computes the mean (average) and cross-sectional
   (across forecast methods) standard deviation at
   each horizon using all simple forecast methods
    available.*/

    # Models for both seasonal and non-seasonal frequencies
    matrix FC = meanf(&self)
    FC ~= medianf(&self)
    FC ~= rwf(&self)
    self.w_drift = 1
    FC ~= rwf(&self)
    FC ~= ar1f(&self)
    self.w_trend = 1
    FC ~= ar1f(&self)

    # Models for both seasonal frequencies only
    if self.is_seas
        FC ~= smeanf(&self)
        FC ~= smedianf(&self)
        FC ~= snaive(&self)
    endif

    # cross-sectional forecast-combination statistics
    FC = meanr(FC) ~ sdc(FC', rows(FC')-1)' ~ FC

    # Add column names
    strings method_names = strsplit("Average-FC SD Mean Median RW RW+Drift AR(1) AR(1)+Trend", " ")
    if self.is_seas
        method_names += strsplit("Seas-Mean Seas-Median Seas-Naive", " ")
    endif
    self.method_names = method_names

    return FC
end function


function matrix meanf (bundle *self)
/* Forecasts of all future values are equal to the mean
    of the historical data*/
    return ones(self.h, 1) .* mean(self.y)
end function


function matrix medianf (bundle *self)
/* Forecasts of all future values are equal to the median
    # of the historical data*/
    return ones(self.h, 1) .* median(self.y)
end function


function matrix smeanf (bundle *self)
/* Forecasts of all future values are equal to the mean of
   the respective historical seasonal period
    where m is the seasonal period.*/
    return get_mean_obsminor(&self)
end function

function matrix smedianf (bundle *self)
/* Forecasts of all future values are equal to the median of
   the respective historical seasonal period
    where m is the seasonal period.*/
    return get_mean_obsminor(&self,1)
end function


function matrix rwf (bundle *self)
/* Naïve forecast is optimal when data follow a random-walk
    or random-walk + drift. */
    matrix fc = ones(self.h,1) .* self.y[$t2]
    if inbundle(self,"w_drift")
        if self.w_drift
            # equivalent to an ARIMA(0,1,0) model with an optional drift coefficient
            scalar avg = (self.y[$t2]-self.y[$t1])/(nobs(self.y)-1)	# average growth rate
            return fc .+ cum(ones(self.h,1)) * avg
        else
            return fc
        endif
    else
        return fc
    endif
end function


function void NaiveThroughTime (bundle *self)
/* This function estimates the point estimates in either (i) a
    rolling or (ii) recursive manner and stores these point estimates. */

    if $nobs<self.wsize
        funcerr "The window size you selected exceeds the no. of valid observations."
    endif

    include CvDataSplitter.gfn 		# TODO: make a required package!

    series y = self.y
    list X = y

    # Set data splitter
    bundle cv = null
    list cv.X = X
    string cv.cv_type = (self.type_roll=="rolling") ? "rolwin" : "recwin"
    scalar cv.win_size = self.wsize
    CvDataSplitter(&cv)							# actual call

    matrix fc = zeros(cv.n_folds, self.h)		# store forecast results

    loop lwin=1..cv.n_folds -q

        mat = cv.X_train[lwin]

        smpl minc(mat[,1]) maxc(mat[,1])		# read time index
        # 1st obs being forecasted (h=1)
        scalar self.initfc = (lwin==1) ? (1+maxc(mat[,1])) : self.initfc

        series y = mat[,2]						# read-realization

        if self.type_roll=="rolling" || self.type_roll=="recursive"
            smpl ; +xmin(self.h, ($tmax-maxc(mat[,1])))
        endif

        fc[lwin,] = call_method(&self)'			# compute forecast
    endloop

    # Adjust rows to make sure that each horizon 'h' refers
    # to the same period being forecasted
    matrix self.fc = fc[,1]
    loop i=1..(self.h-1) -q
        self.fc ~= mlag(fc[,i+1],$i, NA)
    endloop

    # attach column names
    cnameset(self.fc, rownam(self.h))
    # attach rownames: on rows we put date strings
    strings self.fcperiods = array(cv.n_folds)
    loop i=1..cv.n_folds -q
        self.fcperiods[i] = sprintf("%s", obslabel(self.initfc+$i-1) )
    endloop
    rnameset(self.fc, self.fcperiods)

end function


function void naivePlot (bundle *self "Bundle returned from naiveFC()")
    /* Function for plotting actual and forecast values over time. */

    # Plot point forecast
    string title = !inbundle(self,"title") ? "" : self.title
    string ylab = !inbundle(self,"ylab") ? "" : self.ylab
    string xlab = !inbundle(self,"xlab") ? "" : self.xlab
    string out = !inbundle(self,"filename") ? "display" : self.filename
    scalar T = $nobs
    # no. of pre-forecast obs. to plot
    scalar preobs_fc = !inbundle(self,"preobs_fc") ? int(0.25 * T) : self.preobs_fc

    series y = self.y

    # Add future obs.
    if self.type_roll=="static"
        matrix fcmat = zeros(T,cols(self.fc))
        fcmat = (fcmat.=0) ? NA : fcmat
        dataset addobs self.h		# automatically increases $t2
        /* Doesn't work
           scalar t2 = $t2
           string start = obslabel(t2+1)
           string ende = obslabel($t2)
           start
           ende
           smpl (t2+1) ;
         */
        # workaround
        matrix fcmat |= self.fc
        smpl xmax(($nobs-preobs_fc-self.h),1);   
    else
        #smpl xmax((self.initfc-preobs_fc-self.h),1) ;
        #smpl xmax((self.initfc-preobs_fc-self.h),1) ; 
        smpl self.initfc ;
        matrix fcmat = self.fc
    endif

    # Prepare lists for plotting
    setinfo y --graph-name="Actuals"
    list lplot = y
    loop i=1..cols(self.fc) -q
        if i!=2			#i==2 refers to S.D.
            series fc_$i = fcmat[,i]
            if self.which=="avgFC"
                str = sprintf("%s", self.method_names[i])
                setinfo fc_$i --graph-name="@str"
            else
                if self.type_roll=="static"
                    setinfo fc_$i --graph-name="Point-Fc"
                else
                    str = sprintf("h=%d", $i)
                    setinfo fc_$i --graph-name="@str"
                endif                
            endif
            lplot += fc_$i
        endif
    endloop
    
#    print lplot -o
#    stop
    
    # Setup and plot
    scalar mini = min(min(lplot))
    scalar maxi = max(max(lplot))
    scalar ylo = mini-0.05*mini
    scalar yup = maxi+0.05*maxi
    smpl (-preobs_fc) ; 
    plot lplot
        options with-lp time-series single-yaxis
        literal set linetype 1 lc rgb "black" lw 1 pt -1
        literal set linetype 2 lc rgb "red" lw 1.25 #pt 2 ps 0.5
        literal set linetype 3 lc rgb "blue" lw 1.25
        literal set linetype 4 lc rgb "black" lw 1.25
        literal set linetype 5 lc rgb "grey" lw 1.25
        literal set linetype 6 lc rgb "violet" lw 1.25 #pt 3 ps 0.5
        literal set linetype 7 lc rgb "brown" lw 1.25 #pt 4 ps 0.5
        literal set linetype 8 lc rgb "yellow" lw 1.25 #pt 5 ps 0.5
        literal set linetype 9 lc rgb "red" lw 1.25 #pt 1 ps 0.5
        literal set linetype 10 lc rgb "green" lw 1.25
        literal set linetype 10 lc rgb "black" lw 1.25
        literal set key left bottom below
        #literal set key inside left bottom
        #put the border more to the background by applying it
        # only on the left and bottom part and put it and the tics in gray
        literal set style line 11 lc rgb "#808080" lt 1
        literal set border 3 back ls 11			# get rid of upper + left border
        literal set tics nomirror
        #add a slight grid to make it easier to follow the exact position of the curves
        literal set style line 12 lc rgb "#808080" lt 0 lw 1	# light grey color
        literal set grid back ls 12
        printf "set yrange[%g:%g]", ylo, yup
        printf "set ylabel \"%s\"", ylab
        printf "set xlabel \"%s\"", xlab
        printf "set title \"%s\"", title
    end plot --output="@out"
end function


# Example
#============
clear

scalar runEX = 2

if runEX==1
    open nysewk.gdt -q
    series y = close
elif runEX==2
    open denmark.gdt -q
    series y = diff(LRM)
endif

# Call methods
#==================

# Forecast combination
#bundle b = naiveFC(y, "avgFC")		# compute forecasts
#naivePlot(&b)						# plot results
#eval b.fc							# plot resulting bundle

/*
   # Forecast combination but up to h=15 forecast periods
   bundle opt = null					# set specific options
   scalar opt.h = 15
   bundle b = naiveFC(y, "avgFC", opt)
   b.preobs_fc = 25					# set no. of pre.-forecast periods obs. to plot
   naivePlot(&b)
   eval b.fc

   # Separate forecast methods
   bundle b = naiveFC(y, "medianFC")
   naivePlot(&b)
   eval b.fc

   bundle b = naiveFC(y, "rwFC")
   naivePlot(&b)
   eval b.fc

   bundle b = naiveFC(y, "rwdFC")
   naivePlot(&b)
   eval b.fc

   bundle b = naiveFC(y, "smeanFC")
   naivePlot(&b)
   eval b.fc

   bundle b = naiveFC(y, "smedianFC")
   naivePlot(&b)
   eval b.fc

   bundle b = naiveFC(y, "snaiveFC")
   naivePlot(&b)
   eval b.fc

   bundle b = naiveFC(y, "ar1FC")
   naivePlot(&b)
   eval b.fc

   bundle b = naiveFC(y, "ar1trendFC")
   naivePlot(&b)
   eval b.fc
*/

# Rolling-window forecasting
#===========================
#include CvDataSplitter.gfn 		# TODO: make a required package!

bundle opts = null				# setup additional options
opts.type_roll = "recursive" 		#"rolling" / "recursive" -> type of moving-window forecasting
opts.wsize = int(0.75*$nobs)				# window length
opts.verbose = 0				# don't print details

bundle b = naiveFC(y, "snaiveFC", opts)
#print b
#eval b.fc
naivePlot(&b)


