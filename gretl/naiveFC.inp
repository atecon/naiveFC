set verbose off

function scalar isseas (void)
    # flag seasonality
    return ($pd>1) ? 1 : 0
end function


function strings gen_colnam (matrix ci)
    # construct column names
    strings c = defarray("Point-Fc")
    /* confidence intervals are not supported yet
       loop i=1..cols(ci) -q
       c += sprintf(" q%d", ci[i]*100)
       endloop
    */
    return c
end function


function strings gen_rownam (scalar h)
    # construct row names (horizons)
    strings r = array(h)
    loop i=1..h -q
        r[i] = sprintf(" h=%d", i)
    endloop
    return r
end function


function void print_noboot()
    funcerr "Bootstrap confidence intervals are not supported, yet"
end function


function void gen_season_series (bundle *self)
/* Generates a series indicating the separate seasonal
    periods. */
    list s = seasonals() 	# returns e.g. S1...S52/53 for weekly data
    series obs_season = NA

    if nelem(s)>=$pd
        loop i=1..$pd -q
            obs_season = (S$i == 1) ? i : obs_season
        endloop
        self.obs_season = obs_season
        #return self
    else
        funcerr "Periodicity ($pd) does not correspond to what seasonals() in fact returns."
    endif
end function


function matrix get_mean_obsminor (bundle *self, int use_median[0])
/* Helper function for obtaining for each periodicity
    (quarterly=4,monthly=12, weekly=52, etc.) the mean/ median value.*/
    # TODO: in principle one could get the mean for instance for
    # weekly data on the monthly, weekly or daily frequency level.

    string ops = (use_median==1) ? "median" : "mean"
    # construct seasonal indicator series
    gen_season_series(&self)
    matrix ybar = aggregate(self.y, self.obs_season, @ops)[,3] # $pd by 1 vector
    return stack_fc(&self, ybar)
end function


function matrix stack_fc (bundle *self, matrix ybar)
/* Check which value $obsminor takes for the last obs.
    Do some re-ordering. */
    matrix val_obs_season = values(self.obs_season)

    # Re-order fc to make sure that 1st forecast
    # corresponds to the right month, quarter etc.
    if self.obs_season[$tmax] < max(val_obs_season)		# last quarter/month/day-of-week
        matrix selmat = 0 * vec(seq(min(val_obs_season), max(val_obs_season)) )
        scalar counter = self.obs_season[$tmax] + 1
        loop i=1..rows(selmat) -q
            selmat[counter] = $i #val_obs_season[i]			# set position after $tmax
            counter = (counter==max(val_obs_season)) ? 1 : (counter+1)
        endloop
        ybar = msortby(ybar~selmat,2)[,1]
    endif

    # Construct h-step ahead forecasts
    scalar k = ceil(self.h/rows(ybar))		# No. of necessary stackings
    ybar = ones(rows(ybar),k) .* ybar	# pd by k
    return vec(ybar)[1:self.h]
end function


function bundle default_naiveFC_opts (const series y)
    # Set default values

    bundle self = null
    self.h = 10							# forecast horizon
    self.level = 90						# Confidence level (not supported yet)
    self.fan = 0						# plot fan chart  (not supported yet)
    self.nboot = 0						# no. of bootstrap replications  (not supported yet)
    self.blength = 4					# Block length bootstrap  (not supported yet)
    self.is_seas = isseas()				# check for seasonality
    self.verbose = 1					# print details (default: True)

    # For NaiveThroughTime()
    self.type_roll = "static" 			# "static", "rolling" or "recursive"
    self.wsize = ceil(0.25*nobs(y))		# default window length

    return self
end function


function matrix call_method (bundle *self)
    /* Helper function for running actual model. */

    if self.which=="meanFC"
        return meanf(&self)
    elif self.which=="medianFC"
        return medianf(&self)
    elif self.which=="ar1FC"
        return ar1f(&self)
    elif self.which=="ar1trendFC"
        self.w_trend = 1
        return ar1f(&self)
    elif self.which=="rwFC"
        return rwf(&self)
    elif self.which=="rwdFC"
        self.w_drift = 1
        return rwf(&self)

        # For seasonal series only
        #------------------------
    elif self.which=="smeanFC"
        return smeanf(&self)
    elif self.which=="smedianFC"
        return smedianf(&self)
    elif self.which=="snaiveFC"
        #        self.use_median = 1
        return snaive(&self)
    elif self.which=="avgFC" # forecast combination
        return avgf(&self)
    endif

end function


function matrix ar1f (bundle *self)
/* Returns forecasts from an AR(1) model
    either with or without linear trend. */

    scalar h = self.h
    series y = self.y
    t2 = $t2

    if self.type_roll=="static"
        # add new obs.
        dataset addobs self.h
    elif self.type_roll=="rolling" || self.type_roll=="recursive"
        # When called via NaiveThroughTime(), 'dataset' cmd
        # is not applicable
        t2 -= self.h
    endif

    # setup list of regressors
    list L = const y(-1)
    if inbundle(self, "w_trend")
        if self.w_trend
            genr time
            L += time
        endif
    endif

    # set training set
    smpl ; t2
    # Estimate
    ols y L --quiet

    # Set test set and forecast
    string start = obslabel(1+t2)
    string ende = obslabel(t2+self.h)
    fcast @start @ende --dynamic --quiet

    return $fcast #~ $fcse
end function


function matrix snaive (bundle *self)
/* Returns forecasts from an ARIMA(0,0,0)(0,1,0)
    model where m is the seasonal period.*/
    series y = self.y
    t2 = $t2

    if self.type_roll=="static"
        # add new obs.
        dataset addobs self.h
    elif self.type_roll=="rolling" || self.type_roll=="recursive"
        # when called via NaiveThroughTime(), 'dataset' cmd
        # is not applicable
        t2 -= self.h
    endif

    # set to training set
    smpl ; t2

    # Estimate
    arima 0 0 0 ; 0 1 0 ; y --quiet

    # Set test set and forecast
    string start = obslabel(1+t2)
    string ende = obslabel(t2+self.h)
    # Forecast
    fcast @start @ende --dynamic --quiet
    return $fcast #~ $fcse
end function


function void initial_checks (bundle *self)
    /* Helper function perfoming some initial checks */


    strings methods = defarray("meanFC", "medianFC", "avgFC", "rwFC", "rwdFC", \
      "ar1FC", "ar1trendFC")
    strings seas_methods = defarray("smeanFC", "smedianFC", "snaiveFC")
    methods += seas_methods
    # Check whether called method exists
    scalar err = 1
    loop i=1..nelem(methods) -q
        if methods[i]==self.which
            err=0
            break
        endif
    endloop
    if err==1
        funcerr "The forecasting method you selected does not exist."
    endif

    if self.is_seas==0
        scalar err = 0
        loop i=1..nelem(seas_methods) -q
            if seas_methods[i]==self.which
                err=1
                break
            endif
        endloop
        if err==1
            funcerr "The method you requested is not available for non-seasonal data."
        endif
    endif

    if self.nboot>0
        print_noboot()
    endif

    if (self.type_roll=="rolling" || self.type_roll=="recursive") && self.which=="avgFC"
        printf "Error: Automatic forecast averaging ('avgfc') is currently not compatible\n"
        printf "with moving forecasts.\n"
        funcerr "Re-specify."
    endif
end function


function bundle naiveFC (const series y,
                         string which "Select method",
                         bundle opts[null])

    /*=======================*/
    /* Main package function */
    /*=======================*/

    # Set up the bundle
    bundle self = default_naiveFC_opts(y)
    if exists(opts)
        self = opts + self			# override defaults
    endif
    self.which = which

    # Check whether method is applicable
    initial_checks(&self)

    # Drop missings
    T = $nobs
    smpl y --contiguous
    if $nobs<T && self.verbose
        printf "\nThe contiguous time-series sample has been restricted\n"
        printf "due to %d missing values in the original dataset.\n", (T-$nobs)
        printf "\n"
    endif
    series self.y = y

    # Call method
    #==============
    if self.type_roll=="static"
        matrix self.fc = call_method(&self)

        # Add column/ row strings
        if which != "avgFC"
            cnameset(self.fc, gen_colnam(self.fc))
        else
            cnameset(self.fc, self.method_names)
        endif
        rnameset(self.fc, gen_rownam(self.h))

    elif self.type_roll=="rolling" || self.type_roll=="recursive"
        NaiveThroughTime(&self)
    endif

    return self
end function


function matrix avgf (bundle *self)
/* Computes the mean (average) and cross-sectional
   (across forecast methods) standard deviation at
   each horizon using all simple forecast methods
    available.*/

    # Models for both seasonal and non-seasonal frequencies
    matrix FC = meanf(&self)
    FC ~= medianf(&self) ~ rwf(&self)
    self.w_drift = 1
    FC ~= rwf(&self) ~ ar1f(&self)
    self.w_trend = 1
    FC ~= ar1f(&self)

    # Models for seasonal frequencies only
    if self.is_seas
        FC ~= smeanf(&self) ~ smedianf(&self) ~ snaive(&self)
    endif

    # Cross-sectional forecast-combination statistics
    FC = meanr(FC) ~ sdc(FC', rows(FC')-1)' ~ FC

    # Add column names
    strings method_names = strsplit("Average-FC SD Mean Median RW RW+Drift AR(1) AR(1)+Trend", " ")
    if self.is_seas
        method_names += strsplit("Seas-Mean Seas-Median Seas-Naive", " ")
    endif
    self.method_names = method_names

    return FC
end function


function matrix meanf (bundle *self)
/* Forecasts of all future values are equal to the mean
    of the historical data*/
    return ones(self.h, 1) .* mean(self.y)
end function


function matrix medianf (bundle *self)
/* Forecasts of all future values are equal to the median
    # of the historical data*/
    return ones(self.h, 1) .* median(self.y)
end function


function matrix smeanf (bundle *self)
/* Forecasts of all future values are equal to the mean of
   the respective historical seasonal period
    where m is the seasonal period.*/
    return get_mean_obsminor(&self)
end function

function matrix smedianf (bundle *self)
/* Forecasts of all future values are equal to the median of
   the respective historical seasonal period
    where m is the seasonal period.*/
    return get_mean_obsminor(&self,1)
end function


function matrix rwf (bundle *self)
/* Naïve forecast is optimal when data follow a random-walk
    or random-walk + drift. */
    matrix fc = ones(self.h,1) .* self.y[$t2]
    if inbundle(self, "w_drift")
        if self.w_drift
            # equivalent to an ARIMA(0,1,0) model with an optional drift coefficient
            scalar avg = (self.y[$t2]-self.y[$t1])/(nobs(self.y)-1)	# average growth rate
            return fc .+ cum(ones(self.h,1)) * avg
        else
            return fc
        endif
    else
        return fc
    endif
end function


function void NaiveThroughTime (bundle *self)
/* This function estimates the point estimates in either (i) a
    rolling or (ii) recursive manner and stores these point estimates. */

    if $nobs<self.wsize
        printf "\nError: The window size you selected (=%d) exceeds the\n\
          no. of valid observations.\n", self.wsize
        funcerr "Re-specify."
    endif

    include CvDataSplitter.gfn 		# TODO: make a required package!

    series y = self.y
    list X = y						# a list must be passed to data splitter

    # Set data splitter
    bundle cv = null
    list cv.X = X
    string cv.cv_type = (self.type_roll=="rolling") ? "rolwin" : "recwin"
    scalar cv.win_size = self.wsize
    CvDataSplitter(&cv)							# actual call

    /* Needed as CvDataSplitter() doesn't consider the very last obs in
    the final training set for 'rolwin' and 'recwin'. */
    cv.X_train += cv.X_train[cv.n_folds] | ({$tmax}~{y[$tmax]})
    cv.n_folds++

    /*	For debugging only
       matrices X_train = cv.X_train
       loop i=1..cv.n_folds -q
       eval X_train[i]
       if i==cv.n_folds
       stop
       endif
       endloop
    */

    # Loop over training sets
    matrix self.fc = zeros(cv.n_folds, self.h)
    loop lwin=1..cv.n_folds -q
        mat = cv.X_train[lwin]
        smpl minc(mat[,1]) maxc(mat[,1])		# read time index of the training set

        # 1st obs being forecasted (h=1) based on information up to (self.initfc-1)
        scalar self.initfc = (lwin==1) ? (1+maxc(mat[,1])) : self.initfc

        self.fc[lwin,] = call_method(&self)'	# compute forecast
    endloop

    # Attach column names
    cnameset(self.fc, gen_rownam(self.h))
    # Attach rownames: on rows we put date strings referring to
    # the information set (time/ date) based on which the h-step
    # ahead forecast is computed for.
    strings self.fcperiods = array(cv.n_folds)
    loop i=1..cv.n_folds -q
        # NOTE: obslabel(self.initfc+$i-2): for i==1 the data refers to the 1st day
        # based on which the first h=1,...,H OoS-forecasts are made!
        self.fcperiods[i] = sprintf("%s", obslabel(self.initfc+$i-2) )
    endloop
    rnameset(self.fc, self.fcperiods)
end function


function void naivePlot (bundle *self "Bundle returned from naiveFC()")
    /* Function for plotting actual and forecast values over time. */

    # Plot point forecast
    string title = !inbundle(self,"title") ? "" : self.title
    string ylab = !inbundle(self,"ylab") ? "" : self.ylab
    string xlab = !inbundle(self,"xlab") ? "" : self.xlab
    string out = !inbundle(self,"filename") ? "display" : self.filename
    scalar T = $nobs
    # No. of pre-forecast obs. to plot - default 25pct. of total obs.
    scalar preobs_fc = !inbundle(self,"preobs_fc") ? int(0.25*T) : self.preobs_fc

    # Augment the dataset
    dataset addobs self.h
    series y = self.y

    # Set up the fcmat matrix holding results
    if self.type_roll=="static"
        matrix fcmat = zeros(T, cols(self.fc))		# length equal to no, of obs. of the non-augmented sample
        fcmat = (fcmat.=0) ? NA : fcmat
        fcmat |= self.fc							# concatenate forecasts
    else
        matrix fcmat = self.fc
    endif

    # Prepare lists for plotting
    setinfo y --graph-name="Actuals"
    list lplot = y

    if self.type_roll!="static"						# rolling/ recursive window
        # Initialization
        scalar start = self.initfc-1
        smpl start start
        # Loop over diff. training sets; each produces h-step ahead forecasts
        loop i=1..rows(self.fc) -q
            if self.type_roll != "static"
                start++
                smpl start (start+self.h-1)
                series fc_$i = fcmat[i,]
                str = sprintf("TrainSet=%d", $i)
                setinfo fc_$i --graph-name="@str"
                lplot += fc_$i
            endif
        endloop

    elif self.type_roll=="static"
        self.initfc = T+1								# no yet defined for this case

        loop i=1..cols(self.fc) -q
            if i!=2 && self.type_roll=="static"			#i==2 refers to S.D.
                series fc_$i = fcmat[,i]
                if self.which=="avgFC"
                    str = sprintf("%s", self.method_names[i])
                    setinfo fc_$i --graph-name="@str"
                else
                    if self.type_roll=="static"
                        setinfo fc_$i --graph-name="Point-Fc"
                    else
                        str = sprintf("h=%d", $i)
                        setinfo fc_$i --graph-name="@str"
                    endif
                endif
                lplot += fc_$i
            endif
        endloop
    endif

    # Setup and plot
    #===============
    # incl. some pre-forecast periods obs. for plotting
    smpl xmax((self.initfc-preobs_fc),1) $tmax
    # y-range
    scalar mini = min(min(lplot))
    scalar maxi = max(max(lplot))
    scalar ylo = mini-0.05*abs(mini)
    scalar yup = maxi+0.05*abs(maxi)
    # TODO: lplot may become A VERY long list -- think about a restriction showing
    # only the k last forecasts
    plot lplot
        options with-lp time-series single-yaxis
        literal set linetype 1 lc rgb "black" lw 1 pt -1
        literal set linetype 2 lc rgb "red" lw 1.25 pt 2 ps 0.5
        literal set linetype 3 lc rgb "blue" lw 1#.25
        literal set linetype 4 lc rgb "black" lw 1#.25
        literal set linetype 5 lc rgb "grey" lw 1#.25
        literal set linetype 6 lc rgb "violet" lw 1#.25 #pt 3 ps 0.5
        literal set linetype 7 lc rgb "brown" lw 1#.25 #pt 4 ps 0.5
        literal set linetype 8 lc rgb "yellow" lw 1#.25 #pt 5 ps 0.5
        literal set linetype 9 lc rgb "red" lw 1#.25 #pt 1 ps 0.5
        literal set linetype 10 lc rgb "green" lw 1#.25
        literal set linetype 10 lc rgb "black" lw 1#.25
        literal set key left bottom below
        #literal set key inside left bottom
        #put the border more to the background by applying it
        # only on the left and bottom part and put it and the tics in gray
        literal set style line 11 lc rgb "#808080" lt 1
        literal set border 3 back ls 11			# get rid of upper + left border
        literal set tics nomirror
        #add a slight grid to make it easier to follow the exact position of the curves
        literal set style line 12 lc rgb "#808080" lt 0 lw 1	# light grey color
        literal set grid back ls 12
        printf "set yrange[%g:%g]", ylo, yup
        printf "set ylabel \"%s\"", ylab
        printf "set xlabel \"%s\"", xlab
        printf "set title \"%s\"", title
    end plot --output="@out"
end function


function matrix avgfc_gui (const series y "Series",
                           int h[1::10] "Horizon")
    matrix FC = avgfc(y,h)
    printf "%12.4f\n", FC
    return FC
end function
