function strings colnam (matrix ci)
    # construct column names
    strings c = defarray("point")
    /* confidence intervals are not supported yet
       loop i=1..cols(ci) -q
       c += sprintf(" q%d", ci[i]*100)
       endloop
    */
    return c
end function

function strings rownam (scalar h)
    # construct row names (horizons)
    strings r = array(h)
    loop i=1..h -q
        r[i] = sprintf(" h=%d", i)
    endloop
    return r
end function


function matrix get_last_obsminor (const series y, int h)
    # obtain last k (quarterly=4, monthly=12, etc. obs)
    smpl y --no-missing
    smpl ($t2-$pd+1) $t2	# last $pd values
    return stack_fc({y}, h)
end function

/*
   function matrix re_sample (const matrix y, int nboot, int blength)
   # NOTE: requires SB.gfn package
   # not considered yet

   matrix bb=zeros(nobs(y),nboot)
   loop boot=1..nboot --quiet
   bb[,boot]=SB(y,blength)
   endloop
   return bb
   end function
*/

function matrix genci (scalar level[1:99:90] "confidence sign. level",
                       bool fan[0])
    # generate confidence interval(s)
    if !fan
        scalar lo = (100-level)/2
        matrix ci = { lo, 100-lo }./100
    else
        matrix ci = seq(2,99,3)/100
    endif
    return ci
end function

function matrix stack_fc (matrix fc "Forecast(s)",
      int h "Forecast horizon")
    # construct h-step ahdead forecasts
    matrix fc = vec(fc)
    # stack forecasts
    if h>rows(fc)
        loop i=1..ceil(h/rows(fc)) -q
            fc |= fc
        endloop
        fc = fc[1:h]
    else
        fc = fc[1:h]
    endif
    return fc
end function

function matrix get_mean_obsminor (const series y, int h)
    # obtain last k (quarterly=4, monthly=12, etc. obs)
    series omin = $obsminor
    scalar n = max(uniq(omin))
    matrix ymeans = zeros(n, 1)

    loop i=1..n -q	# filter by $obsminor
        smpl omin==$i --restrict --replace
        ymeans[i] = mean(y)
    endloop
    smpl full
    return stack_fc(ymeans, h)
end function


function void fcplot (const series y, matrix fc,                      
                      string title[null],
                      string ylab[null],
                      string xlab[null],
                      string filename[null] "'display' OR 'Path+filename'")

    # Plot point forecast and quantiles
    string title = !exists(title) ? "" : title
    string ylab = !exists(ylab) ? "" : ylab
    string xlab = !exists(xlab) ? "" : xlab
    string out = !exists(filename) ? "display" : filename

    set warnings off
    matrix mplot = {y}
    loop i=1..cols(fc) -q
        mplot ~= NA
    endloop
    mplot |= (NA ~ fc)
    if cols(fc)>1
        cnameset(mplot, strsplit("Actuals Point-FC Low High", " "))
    else
        cnameset(mplot, strsplit("Actuals Point-FC", " "))
    endif
    set warnings on

    ylo = min(y)-0.05*min(y)
    yup = max(y)+0.05*max(y)
    plot mplot
        options with-lines time-series single-yaxis
        literal set linetype 1 lc rgb "black"
        literal set linetype 2 lc rgb "red" lw 2
        literal set linetype 3 lc rgb "black" lw 1.5
        literal set linetype 4 lc rgb "black" lw 1.5
        literal set key bottom below
        #put the border more to the background by applying it
        # only on the left and bottom part and put it and the tics in gray
        literal set style line 11 lc rgb "#808080" lt 1
        literal set border 3 back ls 11			# get rid of upper + left border
        literal set tics nomirror
        #add a slight grid to make it easier to follow the exact position of the curves
        literal set style line 12 lc rgb "#808080" lt 0 lw 1	# light grey color
        literal set grid back ls 12
        printf "set yrange[%g:%g]", ylo, yup
        printf "set ylabel \"%s\"", ylab
        printf "set xlabel \"%s\"", xlab
        printf "set title \"%s\"", title
    end plot --output=@out
end function



function void nttplot (bundle *b "Filled bundle after NaiveThroughTime()",
                      string title[null],
                      string ylab[null],
                      string xlab[null],
                      string filename[null] "'display' OR 'Path+filename'")

    if !inbundle(b, "FC")
        funcerr "Bundle does not contain the forecast results. Call NaiveThroughTime() first."
    endif    

    # Plot point forecast and quantiles
    string title = !exists(title) ? "" : title
    string ylab = !exists(ylab) ? "" : ylab
    string xlab = !exists(xlab) ? "" : xlab
    string out = !exists(filename) ? "display" : filename

    set warnings off
    /* using matrices instead of series
    smpl b.initfc b.lastfc
    matrix mplot = {b.y} ~ b.FC
    rnameset(mplot, b.fcperiods)
    strings S = defarray("Actuals")
    S += rownam(b.h)
    cnameset(mplot, S)
    set warnings on
    */
    smpl full
    smpl b.initfc b.lastfc
    series y = b.y
    list L = y
    loop i=1..b.h -q
        series fc_h$i = b.FC[,i]
        setinfo fc_h$i --graph-name="h=$i"
        L += fc_h$i
    endloop
    
    ylo = min(b.y)-0.01*min(b.y)
    yup = max(b.y)+0.01*max(b.y)
    plot L 	# mplot
        options with-lines time-series single-yaxis        
        #put the border more to the background by applying it
        # only on the left and bottom part and put it and the tics in gray
        literal set style line 11 lc rgb "#808080" lt 1
        literal set border 3 back ls 11			# get rid of upper + left border
        literal set tics nomirror
        #add a slight grid to make it easier to follow the exact position of the curves
        literal set style line 12 lc rgb "#808080" lt 0 lw 1	# light grey color
        literal set grid back ls 12
        literal set key bottom below
        literal set linetype 1 lc rgb "#808080"	lw 2 # actuals
        printf "set yrange[%g:%g]", ylo, yup
        printf "set ylabel \"%s\"", ylab
        printf "set xlabel \"%s\"", xlab
        printf "set title \"%s\"", title
    end plot --output=@out
end function



function void seas_check (const series y "Actuals")
    if $pd==1
        funcerr "The method you requested is not available for annual data."
    endif
end function

function void print_noboot()
    funcerr "Bootstrap confidence intervals are not supported, yet"
end function


function matrix meanf (const series y "Actuals",
                       int h[1::10] "Forecast horizon",
                       scalar level[64:99:90] "Confidence level",
                       bool fan[0],
                       int nboot[0::0],
                       int blength[2::4] "Block length bootstrap")
    # forecasts of all future values are equal to the mean of the historical data
    # Returns forecasts and prediction intervals for an iid model applied to y
    /* R func:
       meanf(y, h = 10, level = c(80, 95), fan = FALSE, lambda = NULL,
       biasadj = FALSE, bootstrap = FALSE, npaths = 5000, x = y)
    */

    if nboot>0
        print_noboot()
    endif

    matrix ci = genci(level,fan)

    if nboot==0
        #matrix ymean = ones(h,cols(ci)+1) .* ( mean(y) ~ NA ~ NA ) # ~ quantile({y},ci)' )
        matrix ymean = ones(h,1) .* mean(y)
    else
    /*
       matrix yb = vec( re_sample({y}, nboot, blength) )
       matrix ymean = ones(h,cols(ci)+1) .* ( meanc(yb) ~ quantile(yb,ci)' )
        */
    endif
    cnameset(ymean, colnam(ci))
    rnameset(ymean, rownam(h))
    return ymean
end function

function matrix medianf (const series y "Actuals",
                       int h[1::10] "Forecast horizon",
                       scalar level[64:99:90] "Confidence level",
                       bool fan[0],
                       int nboot[0::0],
                       int blength[2::4] "Block length bootstrap")
    # forecasts of all future values are equal to the median
    # of the historical data
    # Returns forecasts and prediction intervals for an
    # iid model applied to y
    /* R func:
       meanf(y, h = 10, level = c(80, 95), fan = FALSE, lambda = NULL,
       biasadj = FALSE, bootstrap = FALSE, npaths = 5000, x = y)
    */

    if nboot>0
        print_noboot()
    endif

    matrix ci = genci(level,fan)

    if nboot==0
        #matrix ymean = ones(h,cols(ci)+1) .* ( mean(y) ~ NA ~ NA ) # ~ quantile({y},ci)' )
        matrix ymean = ones(h,1) .* median(y)
    else
    /*
       matrix yb = vec( re_sample({y}, nboot, blength) )
       matrix ymean = ones(h,cols(ci)+1) .* ( meanc(yb) ~ quantile(yb,ci)' )
    */
    endif
    cnameset(ymean, colnam(ci))
    rnameset(ymean, rownam(h))
    return ymean
end function


function matrix smeanf (const series y "Series",
                        int h[1::10] "Horizon",
                        scalar level[64:99:90] "Confidence level",
                        bool fan[0],
                        int nboot[0::0],
                        int blength[2::4] "Block length bootstrap")

    # forecasts of all future values are equal to the mean of season of the historical data
    # model where m is the seasonal period.

    if nboot>0
        print_noboot()
    endif

    seas_check(y)

    matrix ci = genci(level, fan)

    if fan==0
        # forecast simply equals the mean for each specific $obsminor periodicity (month, quarter etc.)
        fc = get_mean_obsminor(y, h)
        #matrix fc = ones(h,3) .* ( fc ~ NA ~ NA )
        matrix fc = ones(h,1) .* fc
    else
        funcerr "Fan forecasts are not available, yet."

        /* Not implemented yet
           # forecast simply equals last obs for each specific periodicity (month, quarter)
           # FIXME: This destroys the seasonality structure
           matrix yb = re_sample({y}, nboot, blength)
           fc_b = zeros(h, nboot)
           loop i=1..nboot -q
           fc_b[,i] = snaive_stack(yb[,i], h)
           endloop
           #fc_mean:	 mean across each horizon
           #fc_ci:		quantiles across each horizon
           matrix fc = ones(h,cols(ci)+1) .* ( meanr(fc_b) ~ quantile(fc_b',ci)' )
        */
    endif
    cnameset(fc, colnam(ci))
    rnameset(fc, rownam(h))
    return fc
end function


function matrix rwf (const series y "Actuals",
                     int h[1::10] "Forecast horizon",
                     bool drift[0] "0=Random-Walk wo drift, 1=w drift",
                     scalar level[64:99:90] "Confidence level",
                     bool fan[0],
                     int nboot[0::0],
                     int blength[2::4] "Block length bootstrap")

    # naÃ¯ve forecast is optimal when data follow a random walk
    # these are also called random walk forecasts
    /* R func:
       https://www.rdocumentation.org/packages/forecast/versions/8.4/topics/rwf
       rwf(y, h = 10, drift = FALSE, level = c(80, 95), fan = FALSE,
       lambda = NULL, biasadj = FALSE, bootstrap = FALSE, npaths = 5000,
       x = y)
    */

    if nboot>0
        print_noboot()
    endif

    matrix ci = genci(level,fan)

    #matrix fc = ones(h,3) .* ( y[$t2] ~ NA ~ NA )
    smpl y --no-missing
    matrix fc = ones(h,1) .* y[$t2]

    if drift
        # equivalent to an ARIMA(0,1,0) model with an optional drift coefficient
        scalar avg = (y[$t2]-y[$t1])/(nobs(y)-1)	# average growth rate (drift)
        fc[,1] = fc[,1] .+ cum(ones(h,1))*avg	# TODO: consider intervals later
    endif

    cnameset(fc, colnam(ci))
    rnameset(fc, rownam(h))
    return fc
end function


function matrix snaive (const series y "Series",
                        int h[1::10] "Horizon",
                        scalar level[64:99:90] "Confidence level",
                        bool fan[0],
                        int nboot[0::0],
                        int blength[2::4] "Block length bootstrap")

    # returns forecasts and prediction intervals from an ARIMA(0,0,0)(0,1,0)
    # model where m is the seasonal period.
    /* R func:
       https://www.rdocumentation.org/packages/cv.ts/versions/0.0.0.90105/topics/snaiveForecast
       snaive(y, h = 2 * frequency(x), level = c(80, 95), fan = FALSE,
       lambda = NULL, biasadj = FALSE, bootstrap = FALSE, npaths = 5000, x = y)
    */

    if nboot>0
        print_noboot()
    endif

    seas_check(y)

    matrix ci = genci(level,fan)

    if fan==0
        # forecast simply equals last obs for each specific periodicity (month, quarter)
        fc = get_last_obsminor(y, h)
        # matrix fc = ones(h,3) .* ( fc ~ NA ~ NA )
        matrix fc = ones(h,1) .* fc

    else
        funcerr "Fan forecasts are not available, yet."
        /* NEEDS
           # forecast simply equals last obs for each specific periodicity (month, quarter)
           # FIXME: This destroys the seasonality structure
           matrix yb = re_sample({y}, nboot, blength)
           fc_b = zeros(h, nboot)
           loop i=1..nboot -q
           fc_b[,i] = snaive_stack(yb[,i], h)
           endloop
           #fc_mean:	 mean across each horizon
           #fc_ci:		quantiles across each horizon
           matrix fc = ones(h,cols(ci)+1) .* ( meanr(fc_b) ~ quantile(fc_b',ci)' )
        */
    endif
    cnameset(fc, colnam(ci))
    rnameset(fc, rownam(h))
    return fc
end function

function matrix ar1f (const series y "Series",
                      int h[1::10] "Horizon",
                      scalar level[64:99:90] "Confidence level",
                      bool fan[0],
                      int nboot[0::0],
                      int blength[2::4] "Block length bootstrap")

    if nboot>0
        print_noboot()
    endif
    matrix ci = genci(level,fan)

    smpl y --no-missing
    ols y 0 y(-1) --quiet				# estimation via OLS
    matrix fc = recfc(y, $coeff, h)		# iterative forecast

    cnameset(fc, colnam(ci))
    rnameset(fc, rownam(h))
    return fc
end function


function matrix recfc(const series y, matrix bhat, int h)
    matrix fc = zeros(h,1)
    fc[1] = bhat[1] + bhat[2]*y[$t2]
    loop i=2..h -q
        fc[i] = bhat[1] + bhat[2]*fc[i-1]
    endloop
    return fc
end function

function matrix avgfc_gui (const series y "Series",
                           int h[1::10] "Horizon")
    matrix FC = avgfc(y,h)
    printf "%12.4f\n", FC
    return FC
end function

function matrix avgfc (const series y "Series",
                       int h[1::10] "Horizon",
                       scalar level[64:99:90] "Confidence level",
                       bool fan[0],
                       int nboot[0::0],
                       int blength[2::4] "Block length bootstrap")

    # Computes the mean (average) and cross-sectional (across forecast methods)
    # standard deviation at each horizon using all simple forecast methods
    # available.

    if nboot>0
        print_noboot()
    endif

    # Base models
    strings M = defarray("meanf(y,h)", "rwf(y,h)", "rwf(y,h,1)", "ar1f(y,h)")
    if $pd>1	# for seasonal data only
        M += "smeanf(y,h)"
        M += "snaive(y,h)"
    endif

    matrix fc = zeros(h,nelem(M))
    loop i=1..nelem(M) -q
        string s = sprintf("%s", M[i])
        fc[,i] = @s[,1]	# only point-fc
    endloop
    fc = meanr(fc) ~ sdc(fc', rows(fc')-1)' ~ fc
    if $pd == 1
        cnameset(fc, strsplit("average-fc sd meanf rwf rwf+drift AR(1)", " "))
    else
        cnameset(fc, strsplit("average-fc sd meanf rwf rwf+drift AR(1) smean snaive", " "))
    endif
    rnameset(fc, rownam(h))
    return fc
end function


# public functions
function void NaiveThroughTime (bundle *b, string which, bool verbose[1])

    # This function estimates the point estimates in either (i) a rolling or (ii) recursive manner
    # and stores these point estimates

    # Estimator:
    b.which = which # "meanf", etc.

    if !inbundle(b, "y")
        funcerr "!!! Provide suitable series ('y')."
    endif
    if !inbundle(b, "wsize")
        printf "\nWe set the window-length to 0.25*T = %d observations.\n", ceil(0.25*nobs(b.y))
        scalar b.wsize = ceil(0.25*nobs(b.y))
    endif
    if !inbundle(b, "h")
        printf "\nWe set the forecast horizon to h=12.\n"
        scalar b.h = 12
    endif

    if !inbundle(b, "type_roll") 	# former fcroll (scalar))
        string b.type_roll = "rolling" # "recursive"
        #printf "*** %s regressions will be estimated\n", b.type_roll
    endif


    # Data set settings
    #-------------------
    series y = b.y
    smpl y --no-missing
    scalar b.initobs = $t1
    scalar b.obsend = b.initobs + b.wsize
    scalar b.nsteps = $t2 - b.obsend	# no. of windows
    smpl b.initobs b.obsend
    if verbose
        printf "\n*********************************************************************\n"
        printf "Initial effective sample used: %s to %s (T=%d)\n", obslabel($t1), obslabel($t2), ($t2-$t1)
        printf "Number of %s estimations = %d\n", b.type_roll, b.nsteps
        printf "Initial 1-step ahead forecast will be computed for %s\n", obslabel($t2+1)
    endif

    matrix FC = zeros(b.nsteps, b.h)

    # START ESTIMATION
    # scalar roundcount=0			# incremental counter
    loop lwin=1..b.nsteps -q

        if lwin == b.nsteps
            scalar b.lastfc = 1+$t2	# last obs. used for forecast being forecasted
            if verbose
                printf "Last forecast will be computed for %s\n", obslabel(b.lastfc)
                printf "*********************************************************************\n"
                printf "\n"
            endif

        endif

        smpl $t1 $t2
        if lwin == 1
            scalar b.initfc = 1+$t2			# 1st obs being forecasted (h=1)
        endif

        # COMPUTE and store FCs
        if which=="rwfd"
            FC[lwin,] = rwf(y, b.h, 1)'
        elif which=="avgfc"
            FC[lwin,] = @which(y, b.h)[,1]'
        else
            FC[lwin,] = @which(y, b.h)'
        endif

        # Shift in time
        if lwin < b.nsteps
            if b.type_roll == "recursive"
                smpl ; +1
            elif b.type_roll == "rolling"
                smpl +1 +1
            endif
        endif

        /*	Print how far you are...
           if roundcount == ceil(0.1*b.nsteps)
           printf "\n%d pct. of all %s-windows finished\n", $lwin/b.nsteps*100, b.type_roll
           flush
           roundcount=0
           else
           roundcount++
           endif
        */

    endloop		# END bwin-loop

    # adjust rows to make sure that each 'h' refers to the same period being forecasted
    matrix b.FC = FC[,1]
    loop i=1..(b.h-1) -q
        b.FC ~= mlag(FC[,i+1],$i, NA)
    endloop

    # attach column names
    cnameset(b.FC, rownam(b.h))
    # attach rownames: on rows we put date strings
    strings b.fcperiods = array(b.nsteps)
    loop i=1..b.nsteps -q
        b.fcperiods[i] = sprintf("%s", obslabel(b.initfc+$i-1) )
    endloop
    rnameset(b.FC, b.fcperiods)

end function
