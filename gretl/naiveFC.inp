function scalar isSeas (void)
    /* flag seasonality */
    return ($pd>1) ? 1 : 0
end function

function void genFcIval (bundle *self)
    /* Compute forecast interval assuming standard normal. */
    if cols(self.fc)==2
        fc = self.fc
        factor = fc[,2]*critical(z, (1-self.level)/2)
        self.fc = fc[,1] ~ (fc[,1]-factor) ~ (fc[,1]+factor)
    endif
end function

function strings genColnam (bundle *self)
    /* Construct column names */
    strings s = defarray(self.which) #defarray("Point-Fc")
    if cols(self.fc)==3
        s += sprintf("Lo (%.1f)", (1-self.level)/2*100)
        s += sprintf("Up (%.1f)", (1-(1-self.level)/2)*100)
    endif
    return s
end function

function strings genFcDates (bundle *self)
    /* construct date strings for forecasts */
    strings r = array(self.h)
    # Here we explicitly consider the case when the last obs are missings
    matrix date = {$obsdate}[1+obsnum(self.t2_label):]
    loop i=1..self.h -q
        string sdate = sprintf("%d", date[i])
        if $pd==1
            r[i] = sprintf("%s", substr(sdate,1,4))
        elif $pd==4
            r[i] = sprintf("%s:%s", substr(sdate,1,4),
              substr(sdate,5,6))
        else
            r[i] = sprintf("%s-%s-%s", substr(sdate,1,4),
              substr(sdate,5,6), substr(sdate,7,8))
        endif
    endloop
    return r
end function


function strings genRownam (scalar h)
    /* construct row names (horizons) */
    strings r = array(h)
    loop i=1..h -q
        r[i] = sprintf(" h=%d", i)
    endloop
    return r
end function


function void printNoboot()
    funcerr "Bootstrap confidence intervals are not supported, yet"
end function


function bundle defaultNaiveFcOpts (const series y)
    /* Set default values */

    bundle self = null
    self.h = 10							# forecast horizon
    self.level = 0.9					# probability level for forecast interval
    self.fan = 0						# plot fan chart  (not supported yet)
    self.nboot = 0						# no. of bootstrap replications  (not supported yet)
    self.blength = 4					# Block length bootstrap  (not supported yet)
    self.is_seas = isSeas()				# check for seasonality
    self.verbose = 1					# print details (default: True)

    # For NaiveThroughTime()
    self.type_roll = "static" 			# "static", "rolling" or "recursive"
    self.wsize = ceil(0.25*nobs(y))		# default window length

    # For naivePlot()
    string self.title = ""
    string self.ylab = ""
    string self.xlab = ""
    string self.filename = "display"

    return self
end function


function matrix callMethod (bundle *self)
    /* Helper function for calling method. */

    if self.which!="avgFC"
        return  doForecast(&self, self.which)
    else
        return avgf(&self)
    endif    
end function


function matrix doForecast (bundle *self, string method)
    /* Wrapper function for computing point forecast and intervals. */

    if method=="smeanFC" || method=="smedianFC"
        catch period = $obsmicro
        if $error 
            period = $obsminor
        endif
        list L = dummify(period)
    endif
    if method=="ar1trendFC" && inbundle(self, "w_trend") && self.w_trend
        genr time
        #list L = time
    endif    


    # Set the training set
    if self.type_roll=="static"
        smpl obsnum(self.t1_label) obsnum(self.t2_label)

    elif self.type_roll=="rolling" || self.type_roll=="recursive"
        # set to training set
        catch smpl ; ($t2-self.h)
        if $error
            funcerr "Check your sample and window size."
        endif
    endif

    # Estimation
    series y = self.y

    if method=="meanFC"
        ols y 0 --quiet
        fcast ($t2+1) ($t2+self.h) --static --quiet

    elif method=="medianFC"
        quantreg 0.5 y const --quiet
        fcast ($t2+1) ($t2+self.h) --static --quiet

    elif method=="smeanFC"
        ols y const L --quiet
        fcast ($t2+1) ($t2+self.h) --static --quiet        
        
    elif method=="smedianFC"
        quantreg 0.5 y const L --quiet
        fcast ($t2+1) ($t2+self.h) --static --quiet

    elif method=="snaiveFC" || method=="snaivedriftFC"
        string arima_opt = (method=="snaiveFC") ? "--nc" : ""
        arima 0 0 0 ; 0 1 0 ; y @arima_opt --quiet
        fcast ($t2+1) ($t2+self.h) --dynamic --quiet
        
    elif method=="ar1FC" || method=="ar1trendFC"
        # setup list of regressors
        list L = const y(-1)
        if inbundle(self, "w_trend")
            L += trend
        endif
        ols y L --quiet
        fcast ($t2+1) ($t2+self.h) --dynamic --quiet
        
    elif method=="rwFC" || method=="rwdriftFC"
        string arima_opt = (method=="rwFC") ? "--nc" : ""
        arima 0 1 0 ; y @arima_opt --quiet
        fcast ($t2+1) ($t2+self.h) --dynamic --quiet
    endif

    return $fcast ~ $fcse
end function


function void initialChecks (bundle *self)
    /* Helper function perfoming some initial checks */

    strings methods = defarray("meanFC", "medianFC", "avgFC", "rwFC", "rwdriftFC", \
      "ar1FC", "ar1trendFC")
    strings seas_methods = defarray("smeanFC", "smedianFC", "snaiveFC", "snaivedriftFC")
    methods += seas_methods
    # Check whether called method exists
    scalar err = 1
    loop i=1..nelem(methods) -q
        if methods[i]==self.which
            err=0
            break
        endif
    endloop
    if err==1
        funcerr "The forecasting method you selected does not exist."
    endif

    if self.is_seas==0
        scalar err = 0
        loop i=1..nelem(seas_methods) -q
            if seas_methods[i]==self.which
                err=1
                break
            endif
        endloop
        if err==1
            funcerr "The method you requested is not available for non-seasonal data."
        endif
    endif

    if self.wsize < $pd
        printf "\nError:\n"
        printf "Window size = %d\n", self.wsize
        printf "Periodicity = %d\n", $pd
        funcerr "The size of the moving window cannot be smaller than the underlying periodicity."
    endif

    if self.nboot>0
        printNoboot()
    endif

    if (self.type_roll=="rolling" || self.type_roll=="recursive") && self.which=="avgFC"
        printf "Error: Automatic forecast averaging ('avgfc') is currently not compatible\n"
        printf "with moving forecasts.\n"
        funcerr "Re-specify."
    endif
end function


function bundle naiveFC (const series y,
                         string which "Select forecasting method",
                         bundle opts[null] "Bundle incl. optional parameters")

    /*=======================*/
    /* Main package function */
    /*=======================*/

    # Set up the bundle
    bundle self = defaultNaiveFcOpts(y)
    if exists(opts)
        self = opts + self			# override defaults
    endif
    self.which = which

    # Check whether method is applicable
    initialChecks(&self)

    # Drop missings + determine number of obs.
    dropMissings(y, &self)
    # smpl obsnum(self.t1_label) obsnum(self.t2_label) # restrict to valid set

    # Add obs for forecasting
    self.obs_added = nobsToAdd(y, &self)
    dataset addobs self.obs_added
    
    series self.y = y		# update

    # Call method
    #==============
    if self.type_roll=="static"
        matrix self.fc = callMethod(&self)

        # Compute (not yet for all methods implemented) forecast intervals
        if which != "avgFC"
            genFcIval(&self)
        endif

        # Add column/ row strings
        if which != "avgFC"
            cnameset(self.fc, genColnam(&self))
        else
            cnameset(self.fc, self.method_names)
        endif
        
        rnameset(self.fc, genFcDates(&self))

    elif self.type_roll=="rolling" || self.type_roll=="recursive"
        NaiveThroughTime(&self)
    endif

    if self.verbose
        summarizeNaiveFc(&self)
    endif

    # Drop some elements from self
    delete self.fan
    delete self.blength
    delete self.nboot
    if inbundle(self,"obs_season")
        delete self.obs_season
    endif

    return self
end function


function void summarizeNaiveFc (bundle *self)
    /* Print summarising information */
    printf "****************************************************\n"
    printf "\t\tNaive Forecasting Method\n"
    printf "\nForecasting method: \t\t\t%s\n", self.which
    printf "Start valid data set: \t\t\t%s\n", self.t1_label
    printf "End valid data set: \t\t\t%s\n", self.t2_label
    printf "Number of observations: \t\t%d\n", obsnum(self.t2_label)-obsnum(self.t1_label)
    printf "Forecast horizon: \t\t\t%d\n", self.h
    if self.type_roll=="static"
        printf "First observation forecasted: \t\t%s\n", obslabel(obsnum(self.t2_label)+1)
        if self.which!="avgFC"
            printf "Width forecast interval: \t\t%d pct.\n", self.level*100
        endif
    else
        printf "Moving window length: \t\t\t%d\n", self.wsize
        printf "Number of %s forecasts: \t\t%d\n", self.type_roll, rows(self.fc)
        printf "First observation forecasted (h=1): \t%s\n", obslabel(self.initfc)
    endif
    printf "****************************************************\n"
    printf "\n"
end function



function scalar nobsToAdd (const series y, bundle *self)
    /* Determine the number of additional observations to add to the dataset. */

    smpl y --contiguous
    t2_new = $t2				# don't consider eventual missings in the data passed to naiveFC()
    return self.h - ($tmax-t2_new)
end function


function void dropMissings (const series y, bundle *self)
    /* Drop missing values + construct a contiguous data set. */

    self.T_all = $nobs  # no. of obs of the original dataset passed, may incl. missings
    smpl y --contiguous
    self.t1_label = obslabel($t1)
    self.t2_label = obslabel($t2)
    self.T = $nobs		# no. of valid obs before adding obs. for forecasting purpose
    if self.T<self.T_all && !self.verbose
        printf "\nWarning: The time-series sample has been restricted\n"
        printf "due to %d missing values in the original dataset.\n", (self.T_all-$nobs)
        printf "Information on the new contiguous set:\n"
        printf "Start date: %s\n", obslabel($t1)
        printf "End date: %s\n", obslabel($t2)
        printf "\n"
    endif
end function


function matrix avgf (bundle *self)
/* Computes the mean (average) and cross-sectional
   (across forecast methods) standard deviation at
   each horizon using all simple forecast methods
    available. */

    # Models for both seasonal and non-seasonal frequencies (grab only point forecasts)
    matrix FC = doForecast(&self, "meanFC")[,1] \
      ~ doForecast(&self, "medianFC")[,1] ~ doForecast(&self, "rwFC")[,1] \
      ~ doForecast(&self, "rwdriftFC")[,1] ~ doForecast(&self, "ar1FC")[,1] ~ doForecast(&self, "ar1trendFC")[,1]

    # Models for seasonal frequencies only
    if self.is_seas      
        FC ~= doForecast(&self, "smeanFC")[,1] ~ doForecast(&self, "smedianFC")[,1] \
        ~ doForecast(&self, "snaiveFC")[,1]  ~ doForecast(&self, "snaivedriftFC")[,1]
    endif

    # Cross-sectional forecast-combination statistics
    FC = meanr(FC) ~ sdc(FC', rows(FC')-1)' ~ FC

    # Add column names
    strings method_names = strsplit("Average-FC SD Mean Median RW RW+Drift AR(1) AR(1)+Trend", " ")
    if self.is_seas
        method_names += strsplit("Seas-Mean Seas-Median Seas-Naive Seas-Naive+Drift", " ")
    endif
    self.method_names = method_names

    return FC
end function


function void NaiveThroughTime (bundle *self)
/* This function estimates the point forecasts either in (i) a rolling or
    (ii) a recursive manner and stores a sequence of point forecasts */

    if $nobs<self.wsize
        printf "\nError: The window size you selected (wsize=%d) exceeds the\n\
          no. of valid observations.\n", self.wsize
        funcerr "Re-specify."
    endif

    include CvDataSplitter.gfn		# load another external package

    series y = self.y
    list X = y						# a list must be passed to data splitter

    # Set data splitter using the valid observation set w.o. obs. addiotnally added for forecasting
    smpl obsnum(self.t1_label) obsnum(self.t2_label)
    bundle cv = null
    list cv.X = X
    string cv.cv_type = (self.type_roll=="rolling") ? "rolwin" : "recwin"
    scalar cv.win_size = self.wsize
    CvDataSplitter(&cv)

    /* Required seto, as CvDataSplitter() doesn't consider the very last obs in
    the final training set for 'rolwin' and 'recwin'. */
    cv.X_train += cv.X_train[cv.n_folds] | ({$t2}~{y[$t2]})
    cv.n_folds++

    /*	For debugging only
       matrices X_train = cv.X_train
       loop i=1..cv.n_folds -q
       eval X_train[i]
       if i==cv.n_folds
       stop
       endif
       endloop
    */

    # Loop over training sets
    matrix self.fc = zeros(cv.n_folds, self.h)
    loop lwin=1..cv.n_folds -q
        mat = cv.X_train[lwin]
        smpl minc(mat[,1]) maxc(mat[,1])		# read time index of the training set

        # 1st obs being forecasted (h=1) based on information up to (self.initfc-1)
        scalar self.initfc = (lwin==1) ? (1+maxc(mat[,1])) : self.initfc
        self.fc[lwin,] = callMethod(&self)[,1]'	# compute point forecast
    endloop

    # Attach column names
    cnameset(self.fc, genRownam(self.h))
    # Attach rownames: on rows we put date strings referring to
    # the information set (time/ date) based on which the h-step
    # ahead forecast is computed for.
    strings self.fcperiods = array(cv.n_folds)
    loop i=1..cv.n_folds -q
        # NOTE: obslabel(self.initfc+$i-2): for i==1 the data refers to the 1st day
        # based on which the first h=1,...,H OoS-forecasts are made.
        self.fcperiods[i] = sprintf("%s", obslabel(self.initfc+$i-2) )
    endloop
    rnameset(self.fc, self.fcperiods)
end function


function void naivePlot (bundle *self "Bundle returned from naiveFC()")
    /* Function for plotting actual and forecast values over time. */

    string out = self.filename

    # No. of pre-forecast obs. to plot - default 25pct. of total obs.
    scalar preobs_fc = !inbundle(self,"preobs_fc") ? int(0.25*self.T) : self.preobs_fc

    # Augment the dataset
    dataset addobs self.obs_added
    # Note, eventual missings at the beginning of the data passed to naiveFC() aren't considered.
    smpl obsnum(self.t1_label) $t2				# restrict back
    series y = self.y
    delete self.y


    # Set up the fcmat matrix holding results
    if self.type_roll=="static"
        matrix fcmat = zeros(self.T, cols(self.fc))		# length equal to no, of obs. of the non-augmented sample
        fcmat = (fcmat.=0) ? NA : fcmat
        fcmat |= self.fc							# concatenate forecasts
    else
        matrix fcmat = self.fc
    endif

    # Prepare lists for plotting
    setinfo y --graph-name="Actuals"
    list lplot = y

    if self.type_roll!="static"						# rolling/ recursive window
        # Initialization
        scalar start = self.initfc-1
        smpl start start
        # Loop over diff. training sets; each produces h-step ahead forecasts
        loop i=1..rows(self.fc) -q
                start++
                smpl start (start+self.h-1)
                series fc_$i = fcmat[i,]
                str = sprintf("TrainSet=%d", $i)
                setinfo fc_$i --graph-name="@str"
                lplot += fc_$i
        endloop

    elif self.type_roll=="static"
        self.initfc = self.T+1

        loop i=1..cols(self.fc) -q
            series fc_$i = fcmat[,i]

            if self.which=="avgFC"
                if i!=2
                    str = sprintf("%s", self.method_names[i])
                    setinfo fc_$i --graph-name="@str"
                endif
            else
                string meth = self.which
                setinfo fc_$i --graph-name="@meth"	#"Point-Fc"
                if cols(self.fc)==3
                    if i==2
                        string s = sprintf("%.1f", (1-self.level)/2*100 )
                        setinfo fc_$i --graph-name="@s"
                    elif i==3
                        string s = sprintf("%.1f", (1-(1-self.level)/2)*100 )
                        setinfo fc_$i --graph-name="@s"
                    endif
                endif
            endif
            lplot += fc_$i
            if self.which=="avgFC" && i==2
                lplot -= fc_$i		# drop cross-sectional std. statistics
            endif
        endloop
    endif

    # Setup and plot
    #===============
    # incl. some pre-forecast periods obs. for plotting
    smpl xmax((self.initfc-preobs_fc),1) $tmax
    # y-range
    scalar mini = min(min(lplot))
    scalar maxi = max(max(lplot))
    scalar ylo = mini-0.05*abs(mini)
    scalar yup = maxi+0.05*abs(maxi)
    # TODO: lplot may become A VERY long list -- think about a restriction showing
    # only the k last forecasts


    if cols(self.fc)!=3
        plot lplot
            options with-lp time-series single-yaxis
            literal set linetype 1 lc rgb "black" lw 1 pt -1
            literal set linetype 2 lc rgb "red" lw 1.25 pt 2 ps 0.5
            literal set linetype 3 lc rgb "blue" lw 1#.25
            literal set linetype 4 lc rgb "black" lw 1#.25
            literal set linetype 5 lc rgb "grey" lw 1#.25
            literal set linetype 6 lc rgb "violet" lw 1#.25 #pt 3 ps 0.5
            literal set linetype 7 lc rgb "brown" lw 1#.25 #pt 4 ps 0.5
            literal set linetype 8 lc rgb "yellow" lw 1#.25 #pt 5 ps 0.5
            literal set linetype 9 lc rgb "red" lw 1#.25 #pt 1 ps 0.5
            literal set linetype 10 lc rgb "green" lw 1#.25
            literal set linetype 10 lc rgb "black" lw 1#.25
            literal set key left bottom below
            #literal set key inside left bottom
            #put the border more to the background by applying it
            # only on the left and bottom part and put it and the tics in gray
            literal set style line 11 lc rgb "#808080" lt 1
            literal set border 3 back ls 11			# get rid of upper + left border
            literal set tics nomirror
            #add a slight grid to make it easier to follow the exact position of the curves
            literal set style line 12 lc rgb "#808080" lt 0 lw 1	# light grey color
            literal set grid back ls 12
            printf "set yrange[%g:%g]", ylo, yup
            printf "set ylabel \"%s\"", self.ylab
            printf "set xlabel \"%s\"", self.xlab
            printf "set title \"%s\"", self.title
        end plot --output="@out"
        
    else
        plot lplot
            options with-lines time-series single-yaxis
            literal set linetype 1 lc rgb "black" lw 1 pt -1
            literal set linetype 2 lc rgb "red" lw 1.25 pt 2 ps 0.5
            literal set linetype 3 lc rgb "blue" lw 1.25
            literal set linetype 4 lc rgb "blue" lw 1.25
            literal set key left bottom below
            #literal set key inside left bottom
            #put the border more to the background by applying it
            # only on the left and bottom part and put it and the tics in gray
            literal set style line 11 lc rgb "#808080" lt 1
            literal set border 3 back ls 11			# get rid of upper + left border
            literal set tics nomirror
            #add a slight grid to make it easier to follow the exact position of the curves
            literal set style line 12 lc rgb "#808080" lt 0 lw 1	# light grey color
            literal set grid back ls 12
            printf "set yrange[%g:%g]", ylo, yup
            printf "set ylabel \"%s\"", self.ylab
            printf "set xlabel \"%s\"", self.xlab
            printf "set title \"%s\"", self.title
        end plot --output="@out"
    endif
end function


function matrix GUI_naiveFC (const series y "Dependent variable",
                           int which[1:11:1] "Model type" {"meanFC", "medianFC", "rwFC", "rwdriftFC", "ar1FC", "ar1trendFC", "smeanFC", "smedianFC", "snaiveFC", "snaivedriftFC", "avgFC"},
                           int h[1::10] "Forecast horizon",
                           bool Plot[1] "Plot forecast")
    /* Helper function for GUI access. */
    
    # map integer value to string
    strings methods=defarray("meanFC", "medianFC", "rwFC", "rwdriftFC", "ar1FC", "ar1trendFC", "smeanFC", "smedianFC", "snaiveFC", "snaivedriftFC", "avgFC")

    bundle opts = null
    bundle self = null
    opts.h = h
    self = naiveFC(y, methods[which], opts)
    
    # output
    printf "%12.4f\n", self.fc    
    if Plot
        naivePlot(&self)        
    endif    

    return self.fc    
end function

