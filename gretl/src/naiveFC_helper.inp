function scalar series_is_always_zero (const series y)
/* Check whether values on comprise zeros.
    return: 1 if y includes on zeros, otherweise 0. */

    return (sum(y) == 0) ? 1 : 0
end function


function void yaxis_ranges (const list plotlist,
                            scalar *ylo,
                            scalar *yup)
    /* */

    scalar mini = min(min(plotlist))
    scalar maxi = max(max(plotlist))
    scalar ylo = mini - 0.05 * abs(mini)
    scalar yup = maxi + 0.05 * abs(maxi)
end function


function list list_of_forecasts (const bundle self,
                                 const matrix horizons,
                                 const string suffix)
    /* Wrapper actually calling specific functions. */

    list R = null
    strings models = getkeys(self.forecast_results)

    loop i=1..nelem(models) -q
        if self.type_moving_window == "static"
            list R += get_static_forecast_list(self, models[i], suffix)
        else
            list R += get_movwindow_forecast_list(horizons, self, models[i], suffix)
        endif
    endloop

    return R
end function

function list get_movwindow_forecast_list (const matrix horizons,
                                           const bundle self,
                                           const string model,
                                           const string suffix)
    /* Return sascade of h-step forecast_results. For 'rolling'
    and 'recursive' cases. */

    list R = null

    loop i=1..rows(horizons) -q
        scalar shift_periods = $i - 1

        R += genseries(sprintf("low_h%d_%s%s", horizons[i], \
          model, suffix), \
          mlag(self.forecast_results[model].forecasts_lower_bound[i,]', shift_periods, NA) )

        R += genseries(sprintf("point_h%d_%s%s", horizons[i], \
          model, suffix), \
          mlag(self.forecast_results[model].forecasts_point[i,]', shift_periods, NA) )

        R += genseries(sprintf("up_h%d_%s%s", horizons[i], \
          model, suffix), \
          mlag(self.forecast_results[model].forecasts_upper_bound[i,]', shift_periods, NA) )
    endloop

    return R
end function


# untested
function list get_static_forecast_list (const bundle self,
                                        const string model,
                                        const string suffix)
    /* Return single multi-step forecast_results for 'static'
    case. */

    list R = null

    R += genseries(sprintf("low_h1to%d_%s%s", self.horizon, \
      model, suffix), \
      self.forecast_results[model].forecasts_lower_bound)

    R += genseries(sprintf("point_h1to%d_%s%s", self.horizon, \
      model, suffix), \
      self.forecast_results[model].forecasts_point)

    R += genseries(sprintf("up_h1to%d_%s%s", self.horizon, \
      model, suffix), \
      self.forecast_results[model].forecasts_upper_bound)

    return R
end function


function scalar horizons_isok (const bundle self,
                               const matrix horizons)
    /* Check the vector 'horizons' is ok. Relevant for
       get_naive_forecasts().
    : return: 1 if ok, 0 otherwise */

    if self.type_moving_window != "static"
        if minc(horizons) <= 0
            printError("You cannot select a negative forecast horizon.")
            return 0
        endif
        if maxc(horizons) > self.horizon
            printError(sprintf("The maximum forecast horizon you \n\
              selected (=%d) does exceed the horizon set before (=%d).", \
              maxc(horizons), self.horizon))
            return 0
        endif
    endif

    return 1
end function


function scalar sufficient_future_obs (bundle *self)
    /* */

    scalar tdiff = $tmax + self.n_sampleend_obs_replaced - self.t2_obsnum_y

    if tdiff < self.horizon
        printError(sprintf("Requested maximum forecast horizon exceeds\n\
          the number of available future periods. Either add observations\n\
          or decrease the maximum forecast horizon to %d",
          self.horizon - (self.horizon - tdiff)))
        self.error = 1
        return 1
    endif

    return 0
end function


# TODO: untested
function scalar get_sample_end (const bundle self)
    scalar sample_end = obsnum(self.t2_date_y)
    if self.type_moving_window == "static"
        scalar sample_end += self.horizon
    endif

    return sample_end
end function


function scalar replace_nan_value_by (void)
/* Set value for replacing future unknown values
    of series to be forecasted by a specific value. */
    return -9876543210
end function


# TODO: untested
function scalar repl_sampleend_missings_of_y (series *y, const bool verbose)
    /* Replace missing values of y at the sample end. */

    smpl y --no-missing
    scalar n_sampleend_obs_replaced = $tmax - $t2
    if n_sampleend_obs_replaced > 0
        smpl (1 + $t2) $tmax
        series y = replace_nan_value_by()
        smpl full
    endif

    if verbose
        printInfo(sprintf("Replaced %d missing values at the sample end of 'y'.", \
          n_sampleend_obs_replaced))
    endif

    return n_sampleend_obs_replaced
end function

function scalar valid_dates_of_y_and_xlist (bundle *self)
    /* Check that sufficient future values of exogenous variables exist. */

    if !nelem(self.xlist)
        return 0
    endif

    scalar tdiff_y_xlist = self.t2_obsnum_y - self.t2_obsnum_xlist

    if tdiff_y_xlist >= 0
        if tdiff_y_xlist > 0
            printError(sprintf("Sample ends earlier for exogenous regressors ('%s')\n\
              than for the endogenous %s ('%s').", self.t2_date_xlist,
              self.name_endo, self.t2_date_y))
        else
            printError(sprintf("Sample ends for both the exogenous regressors\n\
              and for the endogenous %s at observation '%s'.",
              self.name_endo, self.t2_date_y))
        endif
        printError("List of exogenous has insufficient future values.")

        self.error = 1
        return 1
    endif

    if tdiff_y_xlist < 0 && (abs(tdiff_y_xlist) <  self.horizon)
        printError(sprintf("You set the maximum forecast horizon to %d periods but\n\
          the sample of the exogenous regressors has only %d future\n\
          values left after period %s.\n\
          Either restrict the maximum forecast horizon to 'horizon = %d'\n\
          or add %d additional future values to the exogenous variables.", \
          self.horizon, abs(tdiff_y_xlist), self.t2_date_xlist, abs(tdiff_y_xlist),
          self.horizon-abs(tdiff_y_xlist)))

        self.error = 1
        return 1
    endif

    return 0
end function


function scalar estimate_model_and_forecast (const string est_command,
                                             const string fcast_command,
                                             const series y,
                                             const list xlist,
                                             const bundle train_obsnums,
                                             const bundle test_obsnums,
                                             const bundle self)
    /* Estimate model and return oos-forecast. */

    smpl train_obsnums.t1_obsnum train_obsnums.t2_obsnum

    catch @est_command
    if $error
        if self.verbose
            printError("Model estimation failed. Forecast values are set to \
              NA for the current sample.")
        endif
        return 1
    endif

    catch fcast test_obsnums.t1_test_obsnum test_obsnums.t2_test_obsnum @fcast_command
    if $error
        if self.verbose
            printError("Failed executing forecast command.")
        endif
        return 1
    endif

    return 0
end function



function bundle compute_avgerage_forecast (bundle *self)
/* Compute avgerage forecast combination across all models
   estimated. This is done foreach horizon and each moving
   window, respectively. We also compute averages of forecast
    intervals. */

    bundle avgfc = null

    if !inbundle(self, "forecast_results")
        printError("Bundle 'forecast_results' does not exist.")
        scalar self.error = 1
    endif
    if nelem(self.forecast_results) < 2
        printError("Average forecast combination requires at least two forecasting models.")
        scalar self.error = 1
    endif

    strings keys = get_name_of_intval_matrices(self)

    if !self.error
        bundle avgfc = initialize_avgfc_bundle(self)

        # Compute for lower ~ point ~ upper separate matrices
        # holding respective values across models
        loop i=1..nelem(keys) -q
            string key_name = keys[i]		# lower ~ point ~ upper
            # return array of n matrices holding interval_part for n models
            matrices @key_name = get_interval_forecast_matrices(keys[i], self)
        endloop

        loop i=1..nelem(keys) -q
            string key_name = keys[i]		# lower ~ point ~ upper
            avgfc[keys[i]] = avg_across_matrices(@key_name)
        endloop

    endif

    return avgfc
end function


# implicitly tested via compute_avgerage_forecast()
function matrix avg_across_matrices (const matrices mats)
    /* */

    scalar n_rows = rows(mats[1])	# equivalent to self.horizon
    scalar n_cols = cols(mats[1])	# equivalent to self.n_folds
    matrix averages = NA * zeros(n_rows, n_cols)

    loop i=1..n_rows -q
        matrix drilled = drill(mats, i)		# rows=models; cols=moving_window
        averages[i,] = meanc(drilled)		# avg. for horizon 'h' across all moving_windows
    endloop

    return averages
end function


# implicitly tested via compute_avgerage_forecast()
function matrices get_interval_forecast_matrices (const string interval_part,
                                                  const bundle self)
    /* Retrieve from forecast_results for all models estimated
       one of the matrices holding the interval forecast results: either
    lower bound, point fc, or upper bound. */

    matrices ret = array(nelem(self.models))

    loop i=1..nelem(self.models) -q
        ret[i] = self.forecast_results[self.models[i]]["@interval_part"]
    endloop

    return ret
end function


# implicitly tested via compute_avgerage_forecast()
function strings get_name_of_intval_matrices (const bundle self)
    /* Name of matrices holding interval forecasts. */

    return getkeys(self.forecast_results[self.models[1]])
end function


# implicitly tested via compute_avgerage_forecast()
function bundle initialize_avgfc_bundle (const bundle self)
    /* */

    strings keys = get_name_of_intval_matrices(self)
    bundle avgfc = null

    loop i=1..nelem(keys) -q
        string key_name = keys[i]		# lower ~ point ~ upper
        matrix avgfc[keys[i]] = NA * ones(self.horizon, self.n_folds)
    endloop

    return avgfc
end function



function void attach_column_labels (bundle *interval_forecasts,
                                    bundle self)
    /* Add date strings as column labels for indicating the date on
    which the estimates are conditioned on. */

    string date_first_trainset_end = obslabel(obsnum(self.t1_forecast_date) - 2)
    strings date_strings = future_date_strings(date_first_trainset_end, self.n_folds)

    strings keys = getkeys(interval_forecasts)
    loop i=1..nelem(keys) -q
        cnameset(interval_forecasts[keys[i]], date_strings)
    endloop
end function


# TODO: partly untested
function void attach_row_labels (bundle *interval_forecasts,
                                 bundle self)
    /* Add date strings as row labels for 'static' forecasts,
       or indicate the forecast horizon for moving-window
    forecasts. */

    if self.type_moving_window == "static"
        strings row_labels = future_date_strings(self.t2_train_date, self.horizon)
    else
        strings row_labels = array_of_horizon_labels(self.horizon)
    endif

    strings keys = getkeys(interval_forecasts)
    loop i=1..nelem(keys) -q
        rnameset(interval_forecasts[keys[i]], row_labels)
    endloop
end function


function strings array_of_horizon_labels (const int horizon[1::])
    /* Construct string array for indicating the forecast horizons. */

    strings r = array(horizon)
    loop i=1..horizon -q
        r[i] = sprintf("h=%d", i)
    endloop

    return r
end function


function strings future_date_strings (const string date_of_information_str "Obs. before 1st h=1 forecast",
                                      const int n_future_periods[1::])
    /* Construct date strings refering to the date for which a the
    h-step ahead forecast was made for.*/

    strings future_dates = array(n_future_periods)
    scalar date_of_information_num = obsnum(date_of_information_str)

    loop i=1..n_future_periods -q
        future_dates[i] = obslabel(date_of_information_num + $i)
    endloop

    return future_dates
end function


# TODO: untested
function bundle point_fc_and_factor_as_arrays (const matrices collected_point_fc_and_sderr,
                                               bundle *self)
    /* Using each model's point forecast and standard error, compute
    the forecast interval assuming standard normal. */

    bundle bout

    scalar m = nelem(collected_point_fc_and_sderr)
    matrices point_forecasts = array(m)
    matrices factors = array(m)

    loop i=1..m -q
        point_forecasts[i] = collected_point_fc_and_sderr[i][,1]
        factors[i] = fc_interval_width(collected_point_fc_and_sderr[i][,1], self.level)
    endloop

    bout.point_forecasts = point_forecasts
    bout.factors = factors

    return bout
end function


# FIXME: deprecated?
/*
   function scalar cv_window_length (const bundle self)
   # Compute window_length for calling CvDataSplitter().

   if self.type_moving_window == "static"
   scalar win_size = self.window_length 	# X_test already includes period to be forecasted
   else
   # The last self.horizon rows are reserved for the OoS evaluation
   scalar win_size = self.window_length + self.horizon
   endif

   return win_size
   end function
*/


# TODO: untested
function void x_train_test_mats_static_case (bundle *cv, const bundle self)
/* For the static case we only need the first fold returned by
    CvDataSplitter(). */

    if self.type_moving_window == "static"
        matrices cv.X_train = defarray(cv.X_train[1])
        matrices cv.X_test = defarray(cv.X_test[1])
        cv.n_folds = nelem(cv.X_test)
    endif
end function


# TODO: untested -- however, rather CvDataSplitter() should be tested!
function bundle prep_and_get_cv_folds (const bundle self)
    /* Prepare bundle for CvDataSplitter() and compute folds. */

    bundle cv					# Tried to put this into a bundle, but git issues with index series

    # y includes the additional n=horizon newly added observations for
    # the very last cv-dataset
    series y = self.y
    list xlist = self.xlist

    string cv.cv_type = (self.type_moving_window=="rolling") ? "rolwin" : "recwin"
    scalar cv.win_size = self.window_length
    list cv.X = y xlist

    CvDataSplitter(&cv)
    x_train_test_mats_static_case(&cv, self)

    return cv
end function


function scalar valid_window_length (bundle *self)
    /* Returns zero of window_length is valid. */

    if smplspan(self.t1_date_y, self.t2_date_y, $pd) < self.window_length
        printError(sprintf("The window size you selected (wsize=%d) exceeds the\n\
          number of valid observations in '%s'.", self.window_length, self.name_endo))

        return 1
    endif
    return 0
end function


function strings get_estimator_names (const bool is_seas "0=data has no seasonality, 1=it has")
    /* Obtain names of methods going to apply. */

    strings methods = strdrop(get_supported_nonseas_methods(), "avgfc")
    if is_seas
        methods += get_supported_seas_methods()
    endif

    return methods
end function


function void obslabels_and_nobs_to_bundle (const list y,
                                            bundle *self)
    smpl y --contiguous
    string self.t1_date = obslabel($t1)
    string self.t2_date = obslabel($t2)
    scalar self.T = $nobs
end function


function void printInfo (const string s)
    printf "\nInfo: %s\n", s
end function

function void printWarning (const string s)
    printf "\nWarning: %s\n", s
end function

function void printError (const string s)
    printf "\nError: %s\n", s
end function


function bundle set_bundle (const series y,
                            string which,
                            bundle opts[null])
    /* Compile self bundle by merging eventual information
    from opts-bundle. */

    if !exists(opts)
        bundle opts = null
    endif

    bundle self = default_values(y)
    self = opts + self			# override defaults
    self.which = tolower(which)
    if self.which != "avgfc"
        strings self.models = defarray(self.which)
    else
        strings self.models = self.supported_estimators
    endif

    self.forecast_results = prepare_forecast_bundles(&self)
    self.type_moving_window = tolower(self.type_moving_window)
    self.name_endo = argname(y)

    return self
end function

function strings get_supported_seas_methods (void)
    /* List all seasonal supported methods here. */

    return defarray("smeanfc", "smedianfc", "snaivefc", "snaivedriftfc")
end function

function strings get_supported_nonseas_methods (void)
    /* List all non-seasonal supported methods here. */

    return defarray("meanfc", "medianfc", "rwfc", "rwdriftfc", "ar1fc", \
      "ar1trendfc", "avgfc")
end function

function scalar data_has_seasonality (void)
    /* Flag seasonality of data set */

    return ($pd > 1) ? 1 : 0
end function

function matrix fc_interval_width (const matrix fc_sd "Std. error of forecast",
                                   const scalar level[0.001:0.999:] "confidence level")
    /* Compute width for a given condifdence level assuming standard normal. */

    return fc_sd * critical(z, (1 - level) / 2 )
end function


function strings gen_column_names (bundle *self)
    /* Construct column names */

    strings s = defarray(self.which)
    if self.which != "avgfc"
        s += sprintf("Lo (%.1f)", (1-self.level) / 2 * 100 )
        s += sprintf("Up (%.1f)", ( 1-(1-self.level)/2 ) * 100 )
    endif

    return s
end function


# TODO: Drop funcerr, instead return error but don't stop
function void print_no_bootstrap_support (void)
    printError("Bootstrap confidence intervals are not supported, yet")
end function


# TODO: untested
function bundle get_test_start_end_obsnums (const bundle train_obsnums,
                                            const bundle self)
    /* Compute start and end date of test sample based. */

    bundle ret = null
    scalar ret.t1_test_obsnum = 1 + train_obsnums.t2_obsnum
    scalar ret.t2_test_obsnum = ret.t1_test_obsnum + self.horizon_current - 1

    return ret
end function


function bundle get_train_start_end_obsnums (const bundle self)
    /* Return obs. numbers for trainings set. */

    bundle ret = null
    if self.type_moving_window == "static"
        # these are simply in-sample dates
        ret.t1_obsnum = obsnum(self.t1_date_y)
        ret.t2_obsnum = obsnum(self.t2_date_y)
    else
        scalar ret.t2_obsnum = $t2 - self.horizon_current
        scalar ret.t1_obsnum = 1 + ret.t2_obsnum - self.window_length
    endif

    return ret
end function


function series get_highest_period_series (void)
    /* Return series holding highest available frequency. */

    catch series period = $obsmicro
    if $error
        catch series period = $obsminor
        if $error
            series period = $obsmajor
        endif
    endif

    return period
end function


function list add_intercept_to_list (void)
    /* Add intercept to list. */

    list xlist = const

    return xlist
end function


function list add_ohe_periods_to_list (void)
    /* Add list of dummyfied frequency components to list. */

    series period = get_highest_period_series()
    list xlist = dummify(period)

    return xlist
end function


function list add_linear_trend_to_list (void)
    /* Add linear trend to list. */

    genr time
    list xlist = time

    return xlist
end function

