# TODO: untested
function void attach_row_labels (bundle *interval_forecasts,
                                 bundle self)
/* Add date strings as row labels for 'static' forecasts,
   or indicate the forecast horizon for moving-window
    forecasts. */
   
    if self.type_moving_window == "static"
        strings row_labels = future_date_strings(self.t2_label, self.horizon)
    else
        strings row_labels = array_of_horizon_labels(self.horizon)
    endif

    strings keys = getkeys(interval_forecasts)
    loop i=1..nelem(keys) -q
        rnameset(interval_forecasts[keys[i]], row_labels)
    endloop
end function


function strings array_of_horizon_labels (const int horizon[1::])
    /* Construct string array for indicating the forecast horizons. */

    strings r = array(horizon)
    loop i=1..horizon -q
        r[i] = sprintf(" h=%d", i)
    endloop

    return r
end function


function strings future_date_strings (const string date_of_information_str "Obs. before 1st h=1 forecast",
                                       const int n_future_periods[0::])
    /* Construct date strings refering to the date for which a the
    h-step ahead forecast was made for.*/

    strings future_dates = array(n_future_periods)
    scalar date_of_information_num = obsnum(date_of_information_str)

    loop i=1..n_future_periods -q
        future_dates[i] = date_plus_x_as_obslabel(date_of_information_num, $i)
    endloop

    return future_dates
end function


# TODO: untested
function bundle point_fc_and_factor_as_arrays (const matrices fc_and_sd,
                                               bundle *self)
    /* Using each model's point forecast and standard error, compute
    the forecast interval assuming standard normal. */

    bundle bout

    scalar m = nelem(fc_and_sd)
    matrices point_forecasts = array(m)
    matrices factors = array(m)

    loop i=1..m -q
        point_forecasts[i] = fc_and_sd[i][,1]
        factors[i] = fc_interval_width(fc_and_sd[i][,1], self.level)
    endloop

    bout.point_forecasts = point_forecasts
    bout.factors = factors

    return bout
end function


# TODO: untested -- however, rather CvDataSplitter() should be tested!
function bundle prep_and_get_cv_folds (bundle *self)
    /* Prepare bundle for CvDataSplitter() and compute folds. */

    bundle cv					# Tried to put this into a bundle, but git issues with index series
    series y = self.y		# This assignment is needed!
    list X = y				# y includes the additional n=horizon newly added observations for the very last cv-dataset   
    string cv.cv_type = (self.type_moving_window=="rolling") ? "rolwin" : "recwin"
    scalar cv.win_size = self.window_length + self.horizon		# The last self.horizon rows are reserved for the OoS evaluation
    list cv.X = X

    CvDataSplitter(&cv)
    add_last_xtrain_fold(y, &cv)

    return cv
end function

# TODO: untested
function scalar samples_for_y_and_xlist_match (const series y, const list xlist, bundle *self)
    /* Returns zero if samples of y and xlist are ok. */

    if nelem(xlist) == 0
        return 0
    endif
    bundle obsdetails_y
    bundle obsdetails_x

    obslabels_and_nobs_to_bundle(y, &obsdetails_y)	# no. of valid obs before adding obs. for forecasting purpose
    obslabels_and_nobs_to_bundle(x, &obsdetails_x)	# no. of valid obs before adding obs. for forecasting purpose
    scalar tdiff = diff_t2_of_y_and_x(y, xlist)

    if tdiff > && (tdiff < self.horizon)
        printError(sprintf("The last valid observation of series %s is %s.", \
          self.name_endo, obsdetails_y.t2_label))
        printError(sprintf("You requested a %d-step ahead sequence of forecasts.", \
          self.horizon))
        printError(sprintf"The last valid observation of the contiguous sample\n\
          for the additional regressors is %s.", obsdetails_x.t2_label)
        printError("It is not possible to compute the requested h-steap ahead\n\
          sequence of forecasts.")
        printError(sprintf("Either reduce the forecast horizon to h=%d\n\
          or add future information for your 'xlist' variables.", tdiff))

        return 1
    elif tdiff <= 0
        printError("The 'xlist' variables include no valid future observations\n\
          but only missings.")
        printError(sprintf("Last valid observation of additional exogenous\n\
          regressors is %s", obsdetails_x.t2_label))

        return 1
    endif

    return 0
end function


function scalar valid_window_length (bundle *self)
    /* Returns zero of window_length is valid. */

    if smplspan(self.t1_label, self.t2_label, $pd) < self.window_length
        printError(sprintf("The window size you selected (wsize=%d) exceeds the\n\
          number of valid observations in '%s'.", self.window_length, self.name_endo))

        return 1
    endif
    return 0
end function


function strings get_estimator_names (const bool is_seas "0=data has no seasonality, 1=it has")
    /* Obtain names of methods going to apply. */

    strings methods = strdrop(get_supported_nonseas_methods(), "avgfc")
    if is_seas
        methods += get_supported_seas_methods()
    endif

    return methods
end function


function void obslabels_and_nobs_to_bundle (const list y,
                                            bundle *self)
    smpl y --contiguous
    string self.t1_label = obslabel($t1)
    string self.t2_label = obslabel($t2)
    scalar self.T = $nobs
end function


function scalar diff_t2_of_y_and_x (const series y, const list xlist)
    /* Compute difference of valid obs in y and x. */

    scalar tdiff = NA

    if nelem(xlist)
        bundle b = null
        list L = y
        obslabels_and_nobs_to_bundle(L, &b)
        scalar t2_y = obsnum(b.t2_label)
        
        bundle b = null
        obslabels_and_nobs_to_bundle(xlist, &b)
        scalar t2_x = obsnum(b.t2_label)

        scalar tdiff = t2_x - t2_y
    endif

    return tdiff
end function


function void printInfo (const string s)
    printf "\nInfo: %s\n", s
end function

function void printWarning (const string s)
    printf "\nWarning: %s\n", s
end function

function void printError (const string s)
    printf "\nError: %s\n", s
end function


function bundle set_bundle (const series y,
                            string which,
                            bundle opts[null])
    /* Compile self bundle by merging eventual information
    from opts-bundle. */

    if !exists(opts)
        bundle opts = null
    endif

    bundle self = default_values(y)
    self = opts + self			# override defaults
    self.which = tolower(which)
    self.type_moving_window = tolower(self.type_moving_window)
    self.name_endo = argname(y)

    return self
end function

function strings get_supported_seas_methods (void)
    /* List all seasonal supported methods here. */

    return defarray("smeanfc", "smedianfc", "snaivefc", "snaivedriftfc")
end function

function strings get_supported_nonseas_methods (void)
    /* List all non-seasonal supported methods here. */

    return defarray("meanfc", "medianfc", "rwfc", "rwdriftfc", "ar1fc", \
      "ar1trendfc", "avgfc")
end function

function scalar data_has_seasonality (void)
    /* Flag seasonality of data set */

    return ($pd > 1) ? 1 : 0
end function

function matrix fc_interval_width (const matrix fc_sd "Std. error of forecast",
                                   const scalar level[0.001:0.999:] "confidence level")
    /* Compute width for a given condifdence level assuming standard normal. */

    return fc_sd * critical(z, (1 - level) / 2 )
end function


function strings gen_column_names (bundle *self)
    /* Construct column names */

    strings s = defarray(self.which)
    if self.which != "avgfc"
        s += sprintf("Lo (%.1f)", (1-self.level) / 2 * 100 )
        s += sprintf("Up (%.1f)", ( 1-(1-self.level)/2 ) * 100 )
    endif

    return s
end function


# TODO: Drop funcerr, instead return error but don't stop
function void print_no_bootstrap_support (void)
    printError("Bootstrap confidence intervals are not supported, yet")
end function


function bundle get_train_start_end_obsnums (bundle *self)
    /* Return obs. numbers for trainings set. */

    bundle ret = null
    if self.type_moving_window == "static"
        ret.t1_obsnum = obsnum(self.t1_label)
        ret.t2_obsnum = obsnum(self.t2_label)
    else
        scalar ret.t2_obsnum = $t2 - self.horizon
        scalar ret.t1_obsnum = 1 + ret.t2_obsnum - self.window_length
    endif

    return ret
end function


function series get_highest_period_series (void)
    /* Return series holding highest available frequency. */

    catch series period = $obsmicro
    if $error
        catch series period = $obsminor
        if $error
            series period = $obsmajor
        endif
    endif

    return period
end function


function list add_intercept_to_list (void)
    /* Add intercept to list. */

    list xlist = const
    
    return xlist
end function


function list add_ohe_periods_to_list (void)
    /* Add list of dummyfied frequency components to list. */

    series period = get_highest_period_series()
    list xlist = dummify(period)
    
    return xlist
end function


function list add_linear_trend_to_list (void)
    /* Add linear trend to list. */

    genr time
    list xlist = time

    return xlist
end function


function string date_plus_x_as_obslabel (const int obs_num[1::] "Obs-number",
                                         const int x "days to add")
    /* Return the date for which the first 1-step ahead forecast is made for. */
    return obslabel(obs_num + x)
end function


function scalar nobs_to_add_to_dataset (const list y,
                                        const scalar horizon "maximal forecast horizon")
    /* Determine the number of additional observations to add to the dataset. */

    smpl y --contiguous		# don't consider eventual missings in the data passed to naiveFC()
    add_n_new_obs = horizon - ($tmax - $t2)

    printInfo(sprintf("Added %d additional observations at the sample end.", add_n_new_obs))

    return add_n_new_obs
end function


function matrices get_movwin_low_up_matrices (const matrix point_forecasts,
                                              const matrix factors)
    /* Compute for all horizons and moving windows the intervals
    for the forecast. */

    matrices lower_and_upper = array(2)
    matrix lower_and_upper[1] = point_forecasts .- factors
    matrix lower_and_upper[2] = point_forecasts .+ factors

    return lower_and_upper
end function
