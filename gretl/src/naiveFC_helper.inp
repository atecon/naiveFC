function bundle compute_avgerage_forecast (bundle *self)
    /* Compute avgerage forecast combination across all models
    estimated. This is done foreach horizon and each moving
    window, respectively. We also compute averages of forecast
    intervals. */

    bundle avgfc = null

    if !inbundle(self, "forecast_results")
        printError("Bundle 'forecast_results' does not exist.")
        scalar self.error = 1
    endif
    if nelem(self.forecast_results) < 2
        printError("Average forecast combination requires at least two forecasting models.")
        scalar self.error = 1
    endif

    strings keys = get_name_of_intval_matrices(self)

    if !self.error
        bundle avgfc = initialize_avgfc_bundle(self)

        # Compute for lower ~ point ~ upper separate matrices
        # holding respective values across models
        loop i=1..nelem(keys) -q
            string key_name = keys[i]		# lower ~ point ~ upper
            # return array of n matrices holding interval_part for n models
            matrices @key_name = get_interval_forecast_matrices(keys[i], self)
        endloop

        loop i=1..nelem(keys) -q
            string key_name = keys[i]		# lower ~ point ~ upper
            avgfc[keys[i]] = avg_across_matrices(@key_name)
        endloop

    endif

    return avgfc
end function


# implicitly tested via compute_avgerage_forecast()
function matrix avg_across_matrices (const matrices mats)
    /* */

    scalar n_rows = rows(mats[1])	# equivalent to self.horizon
    scalar n_cols = cols(mats[1])	# equivalent to self.n_folds
    matrix averages = NA * zeros(n_rows, n_cols)

    loop i=1..n_rows -q
        matrix drilled = drill(mats, i)		# rows=models; cols=moving_window
        averages[i,] = meanc(drilled)		# avg. for horizon 'h' across all moving_windows
    endloop

    return averages
end function


# implicitly tested via compute_avgerage_forecast()
function matrices get_interval_forecast_matrices (const string interval_part,
                                                  const bundle self)
    /* Retrieve from forecast_results for all models estimated
       one of the matrices holding the interval forecast results: either
    lower bound, point fc, or upper bound. */

    matrices ret = array(nelem(self.models))

    loop i=1..nelem(self.models) -q
        ret[i] = self.forecast_results[self.models[i]]["@interval_part"]
    endloop

    return ret
end function


# implicitly tested via compute_avgerage_forecast()
function strings get_name_of_intval_matrices (const bundle self)
    /* Name of matrices holding interval forecasts. */

    return getkeys(self.forecast_results[self.models[1]])
end function


# implicitly tested via compute_avgerage_forecast()
function bundle initialize_avgfc_bundle (const bundle self)
    /* */

    strings keys = get_name_of_intval_matrices(self)
    bundle avgfc = null

    loop i=1..nelem(keys) -q
        string key_name = keys[i]		# lower ~ point ~ upper
        matrix avgfc[keys[i]] = NA * ones(self.horizon, self.n_folds)
    endloop

    return avgfc
end function



# TODO: untested
function void add_last_xtrain_fold (const series y,
                                    bundle *cv,
                                    const bundle self)
    /* As CvDataSplitter() doesn't consider the very last obs in
    the final training set for 'rolwin' and 'recwin', this must be added. */

    if self.type_moving_window != "static"
        cv.X_train += cv.X_train[cv.n_folds] | ({$t2, y[$t2]})
        cv.n_folds++
    endif
end function

function scalar periods_back_for_future_dates (const string type_moving_window)
    /* Helper for getting correct conditioning date for attach_column_labels(). */

    if type_moving_window == "static"
        return 2
    else
        return 1
    else
        funcerr "Unknown value  for variable 'type_moving_window' passed."
    endif
end function


# TODO: untested
function void attach_column_labels (bundle *interval_forecasts,
                                    bundle self)
    /* Add date strings as column labels for indicating the date on
    which the estimates are conditioned on. */

    scalar periods_back = periods_back_for_future_dates(self.type_moving_window)

    string date_first_trainset_end = \
      date_plus_x_as_obslabel(obsnum(self.t1_forecast_date), -periods_back)
    strings date_strings = future_date_strings(date_first_trainset_end, self.n_folds)

    strings keys = getkeys(interval_forecasts)
    loop i=1..nelem(keys) -q
        cnameset(interval_forecasts[keys[i]], date_strings)
    endloop
end function


# TODO: untested
function void attach_row_labels (bundle *interval_forecasts,
                                 bundle self)
    /* Add date strings as row labels for 'static' forecasts,
       or indicate the forecast horizon for moving-window
    forecasts. */

    if self.type_moving_window == "static"
        strings row_labels = future_date_strings(self.t2_train_date, self.horizon)
    else
        strings row_labels = array_of_horizon_labels(self.horizon)
    endif

    strings keys = getkeys(interval_forecasts)
    loop i=1..nelem(keys) -q
        rnameset(interval_forecasts[keys[i]], row_labels)
    endloop
end function


function strings array_of_horizon_labels (const int horizon[1::])
    /* Construct string array for indicating the forecast horizons. */

    strings r = array(horizon)
    loop i=1..horizon -q
        r[i] = sprintf(" h=%d", i)
    endloop

    return r
end function


function strings future_date_strings (const string date_of_information_str "Obs. before 1st h=1 forecast",
                                      const int n_future_periods[1::])
    /* Construct date strings refering to the date for which a the
    h-step ahead forecast was made for.*/

    strings future_dates = array(n_future_periods)
    scalar date_of_information_num = obsnum(date_of_information_str)

    loop i=1..n_future_periods -q
        future_dates[i] = date_plus_x_as_obslabel(date_of_information_num, $i)
    endloop

    return future_dates
end function


# TODO: untested
function bundle point_fc_and_factor_as_arrays (const matrices collected_point_fc_and_sderr,
                                               bundle *self)
    /* Using each model's point forecast and standard error, compute
    the forecast interval assuming standard normal. */

    bundle bout

    scalar m = nelem(collected_point_fc_and_sderr)
    matrices point_forecasts = array(m)
    matrices factors = array(m)

    loop i=1..m -q
        point_forecasts[i] = collected_point_fc_and_sderr[i][,1]
        factors[i] = fc_interval_width(collected_point_fc_and_sderr[i][,1], self.level)
    endloop

    bout.point_forecasts = point_forecasts
    bout.factors = factors

    return bout
end function


# TODO: untested
function scalar cv_window_length (const bundle self)
    /* Compute window_length for calling CvDataSplitter(). */

    if self.type_moving_window == "static"
        scalar win_size = self.window_length 	# X_test already includes period to be forecasted
    else
        # The last self.horizon rows are reserved for the OoS evaluation
        scalar win_size = self.window_length + self.horizon
    endif

    return win_size
end function

# TODO: untested
function void x_train_test_mats_static_case (bundle *cv, const bundle self)
/* For the static case we only need the first fold returned by
    CvDataSplitter(). */

    if self.type_moving_window == "static"
        matrices cv.X_train = defarray(cv.X_train[1])
        matrices cv.X_test = defarray(cv.X_test[1])
        cv.n_folds = nelem(cv.X_test)
    endif
end function


# TODO: untested -- however, rather CvDataSplitter() should be tested!
function bundle prep_and_get_cv_folds (bundle *self)
    /* Prepare bundle for CvDataSplitter() and compute folds. */

    bundle cv					# Tried to put this into a bundle, but git issues with index series

    series y = self.y		# This assignment is needed!
    list X = y				# y includes the additional n=horizon newly added observations for the very last cv-dataset
    string cv.cv_type = (self.type_moving_window=="rolling") ? "rolwin" : "recwin"
    scalar cv.win_size = cv_window_length(self)
    list cv.X = X

    CvDataSplitter(&cv)
    x_train_test_mats_static_case(&cv, self)
    add_last_xtrain_fold(y, &cv, self)

    return cv
end function


# TODO: untested
function scalar samples_for_y_and_xlist_match (const series y, const list xlist, bundle *self)
    /* Returns zero if samples of y and xlist are ok. */

    if nelem(xlist) == 0
        return 0
    endif
    bundle obsdetails_y
    bundle obsdetails_x

    obslabels_and_nobs_to_bundle(y, &obsdetails_y)	# no. of valid obs before adding obs. for forecasting purpose
    obslabels_and_nobs_to_bundle(x, &obsdetails_x)	# no. of valid obs before adding obs. for forecasting purpose
    scalar tdiff = diff_t2_of_y_and_x(y, xlist)

    if tdiff > && (tdiff < self.horizon)
        printError(sprintf("The last valid observation of series %s is %s.", \
          self.name_endo, obsdetails_y.t2_label))
        printError(sprintf("You requested a %d-step ahead sequence of forecasts.", \
          self.horizon))
        printError(sprintf"The last valid observation of the contiguous sample\n\
          for the additional regressors is %s.", obsdetails_x.t2_label)
        printError("It is not possible to compute the requested h-steap ahead\n\
          sequence of forecasts.")
        printError(sprintf("Either reduce the forecast horizon to h=%d\n\
          or add future information for your 'xlist' variables.", tdiff))

        return 1
    elif tdiff <= 0
        printError("The 'xlist' variables include no valid future observations\n\
          but only missings.")
        printError(sprintf("Last valid observation of additional exogenous\n\
          regressors is %s", obsdetails_x.t2_label))

        return 1
    endif

    return 0
end function


function scalar valid_window_length (bundle *self)
    /* Returns zero of window_length is valid. */

    if smplspan(self.t1_date, self.t2_date, $pd) < self.window_length
        printError(sprintf("The window size you selected (wsize=%d) exceeds the\n\
          number of valid observations in '%s'.", self.window_length, self.name_endo))

        return 1
    endif
    return 0
end function


function strings get_estimator_names (const bool is_seas "0=data has no seasonality, 1=it has")
    /* Obtain names of methods going to apply. */

    strings methods = strdrop(get_supported_nonseas_methods(), "avgfc")
    if is_seas
        methods += get_supported_seas_methods()
    endif

    return methods
end function


function void obslabels_and_nobs_to_bundle (const list y,
                                            bundle *self)
    smpl y --contiguous
    string self.t1_date = obslabel($t1)
    string self.t2_date = obslabel($t2)
    scalar self.T = $nobs
end function


function scalar diff_t2_of_y_and_x (const series y, const list xlist)
    /* Compute difference of valid obs in y and x. */

    scalar tdiff = NA

    if nelem(xlist)
        bundle b = null
        list L = y
        obslabels_and_nobs_to_bundle(L, &b)
        scalar t2_y = obsnum(b.t2_date)

        bundle b = null
        obslabels_and_nobs_to_bundle(xlist, &b)
        scalar t2_x = obsnum(b.t2_date)

        scalar tdiff = t2_x - t2_y
    endif

    return tdiff
end function


function void printInfo (const string s)
    printf "\nInfo: %s\n", s
end function

function void printWarning (const string s)
    printf "\nWarning: %s\n", s
end function

function void printError (const string s)
    printf "\nError: %s\n", s
end function


function bundle set_bundle (const series y,
                            string which,
                            bundle opts[null])
    /* Compile self bundle by merging eventual information
    from opts-bundle. */

    if !exists(opts)
        bundle opts = null
    endif

    bundle self = default_values(y)
    self = opts + self			# override defaults
    self.which = tolower(which)
    if self.which != "avgfc"
        strings self.models = defarray(self.which)
    else
        strings self.models = self.supported_estimators
    endif
    if self.type_moving_window == "static"
        # make sure cv gets only a single fold
        scalar self.window_length = $tmax - self.horizon
    endif

    self.forecast_results = prepare_forecast_bundles(&self)
    self.type_moving_window = tolower(self.type_moving_window)
    self.name_endo = argname(y)

    return self
end function

function strings get_supported_seas_methods (void)
    /* List all seasonal supported methods here. */

    return defarray("smeanfc", "smedianfc", "snaivefc", "snaivedriftfc")
end function

function strings get_supported_nonseas_methods (void)
    /* List all non-seasonal supported methods here. */

    return defarray("meanfc", "medianfc", "rwfc", "rwdriftfc", "ar1fc", \
      "ar1trendfc", "avgfc")
end function

function scalar data_has_seasonality (void)
    /* Flag seasonality of data set */

    return ($pd > 1) ? 1 : 0
end function

function matrix fc_interval_width (const matrix fc_sd "Std. error of forecast",
                                   const scalar level[0.001:0.999:] "confidence level")
    /* Compute width for a given condifdence level assuming standard normal. */

    return fc_sd * critical(z, (1 - level) / 2 )
end function


function strings gen_column_names (bundle *self)
    /* Construct column names */

    strings s = defarray(self.which)
    if self.which != "avgfc"
        s += sprintf("Lo (%.1f)", (1-self.level) / 2 * 100 )
        s += sprintf("Up (%.1f)", ( 1-(1-self.level)/2 ) * 100 )
    endif

    return s
end function


# TODO: Drop funcerr, instead return error but don't stop
function void print_no_bootstrap_support (void)
    printError("Bootstrap confidence intervals are not supported, yet")
end function


function bundle get_train_start_end_obsnums (bundle *self)
    /* Return obs. numbers for trainings set. */

    bundle ret = null
    if self.type_moving_window == "static"
        ret.t1_obsnum = obsnum(self.t1_date)
        ret.t2_obsnum = obsnum(self.t2_date) - self.horizon
    else
        scalar ret.t2_obsnum = $t2 - self.horizon
        scalar ret.t1_obsnum = 1 + ret.t2_obsnum - self.window_length
    endif

    return ret
end function


function series get_highest_period_series (void)
    /* Return series holding highest available frequency. */

    catch series period = $obsmicro
    if $error
        catch series period = $obsminor
        if $error
            series period = $obsmajor
        endif
    endif

    return period
end function


function list add_intercept_to_list (void)
    /* Add intercept to list. */

    list xlist = const

    return xlist
end function


function list add_ohe_periods_to_list (void)
    /* Add list of dummyfied frequency components to list. */

    series period = get_highest_period_series()
    list xlist = dummify(period)

    return xlist
end function


function list add_linear_trend_to_list (void)
    /* Add linear trend to list. */

    genr time
    list xlist = time

    return xlist
end function


function string date_plus_x_as_obslabel (const int obs_num[1::] "Obs-number",
                                         const int x "days to add")
    /* Return the date for which the first 1-step ahead forecast is made for. */
    return obslabel(obs_num + x)
end function


function scalar nobs_to_add_to_dataset (const list y,
                                        const scalar horizon "maximal forecast horizon")
    /* Determine the number of additional observations to add to the dataset. */

    smpl y --contiguous		# don't consider eventual missings in the data passed to naiveFC()
    add_n_new_obs = horizon - ($tmax - $t2)

    printInfo(sprintf("Added %d additional observations at the sample end.", add_n_new_obs))

    return add_n_new_obs
end function

