<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="naiveFC" needs-time-series-data="true" minver="2019b" lives-in-subdir="true">
<author email="atecon@posteo.de">Artur Tarassow</author>
<version>0.9</version>
<date>2020-03-04</date>
<description>Simple forecasting methods</description>
<tags>C53</tags>
<label>naive forecast(s)</label>
<menu-attachment>MAINWIN/Model/TSModels</menu-attachment>
<help>
pdfdoc:naiveFC.pdf
</help>
<depends count="4">
CvDataSplitter string_utils extra StrucTiSM </depends>
<gretl-function name="naiveFC" type="bundle">
 <params count="3">
  <param name="y" type="series" const="true"/>
  <param name="which" type="string">
<description>Select forecasting method</description>
  </param>
  <param name="opts" type="bundle" optional="true">
<description>Bundle incl. optional parameters</description>
  </param>
 </params>
<code>/* Main package function */
if !exists(opts)
  bundle opts = null
endif
bundle self = set_bundle(y, which, opts)
do_initial_checks(&amp;self)	# TODO: return scalar capturing error instead of using pointer!
if self.error
  return self
endif
xlist_is_valid(&amp;self)
# Replace of missing at the sample end
# must be done here before 't1_and_t2_of_y_and_xlist'
self.n_sampleend_obs_replaced = repl_sampleend_missings_of_y(&amp;y, self.verbose)
t1_and_t2_of_y_and_xlist(y, &amp;self)
if self.type_moving_window == &quot;static&quot;
  # &quot;self.t2_date_y&quot; refers to in-sample end date of &quot;y&quot;
  scalar self.window_length = smplspan(self.t1_date_y, self.t2_date_y, $pd)
endif
scalar check = valid_dates_of_y_and_xlist(&amp;self)
if check
  Error(&quot;Problem with dating for y and/ or xlist.&quot;)
  return self
endif
scalar check = sufficient_future_obs(&amp;self)
if check
  return self
endif
smpl obsnum(self.t1_date_y) get_sample_end(self)		# get_sample_end(self) = in-sample end plus max(horizon)
series self.y = endogenous_series_in_logs(y, &amp;self)
if self.error == TRUE
  return self
endif
do_naive_forecasting(&amp;self)
if self.which == &quot;avgfc&quot;
  self.forecast_results.avgfc = compute_avgerage_forecast(&amp;self)
endif
summarize_naive_fc_results(&amp;self)
if self.endogenous_in_logs
  series self.y = exp(self.y)
endif
cleanup_bundle(&amp;self)
return self
</code>
</gretl-function>
<gretl-function name="plot_naive_forecasts" type="void">
 <params count="3">
  <param name="self" type="bundle" const="true">
<description>Bundle returned from naiveFC()</description>
  </param>
  <param name="horizons" type="matrix" optional="true" const="true">
<description>Select only specific horizons</description>
  </param>
  <param name="model" type="string" optional="true" const="true">
<description>Select a model in case of avgfc</description>
  </param>
 </params>
<code>/* Function for plotting realizations and interval forecasts. */
if self.which == &quot;avgfc&quot; &amp;&amp; !exists(model)
  funcerr &quot;You must specify for which model to plot the forecasts.&quot;
endif
series y = self.y
setinfo y --graph-name=&quot;Actuals&quot;
# re-set missing values back to NA
series y = (y == replace_nan_value_by() &amp;&amp; self.type_moving_window == &quot;static&quot;) ? NA : y
if !exists(horizons)
  matrix horizons = seq(1, self.horizon)
endif
list plotlist = y get_naive_forecasts(self, horizons)
list plotlist = get_specific_model_for_avgfc(self, plotlist, model)
# incl. some pre-forecast periods obs. for plotting
scalar start = xmax(obsnum(self.t1_forecast_date) - self.pre_fc_periods_to_plot, 1)
smpl start obsnum(self.t2_forecast_date)
call_plot(plotlist, self)
</code>
</gretl-function>
<gretl-function name="get_naive_forecasts" type="list">
 <params count="3">
  <param name="self" type="bundle" const="true"/>
  <param name="horizons" type="matrix" optional="true">
<description>Select specific horizons (moving-window only)</description>
  </param>
  <param name="suffix" type="string" optional="true" const="true">
<description>Suffix for series' names</description>
  </param>
 </params>
<code>/* Transform interval forecasts into a list of series and return this. */
list R = null
if !exists(suffix)
  string suffix = &quot;&quot;
endif
if !exists(horizons)
  matrix horizons = seq(1, self.horizon)
endif
matrix horizons = vec(horizons)
scalar err = horizons_isok(self, horizons)
if !err
  return R
endif
smpl obsnum(self.t1_forecast_date) obsnum(self.t2_forecast_date)	# don't drop
return list_of_forecasts(self, horizons, suffix)
</code>
</gretl-function>
<gretl-function name="GUI_naiveFC" type="matrix" menu-only="1" pkg-role="gui-main">
 <params count="5">
  <param name="y" type="series" const="true">
<description>Dependent variable</description>
  </param>
  <param name="xlist" type="list" optional="true" const="true">
<description>Additional exogenous (future values must be known)</description>
  </param>
  <param name="which" type="int" min="1" max="13" default="1">
<description>Model type</description>
<labels count="13">
"meanFC" "medianFC" "rwFC" "rwdriftFC" "ar1FC" "ar1trendFC" "ar1ma1fc" "smeanFC" "smedianFC" "snaiveFC" "snaivedriftFC" "avgFC" "airlinefc" </labels>
  </param>
  <param name="h" type="int" min="1" default="10">
<description>Forecast horizon</description>
  </param>
  <param name="Plot" type="bool" default="1">
<description>Plot forecast</description>
  </param>
 </params>
<code>/* Helper function for GUI access. */
# map integer value to string
strings methods = get_supported_nonseas_methods()
bundle opts = null
bundle self = null
opts.h = h
opts.xlist = xlist
self = naiveFC(y, methods[which], opts)
# output
printf &quot;%12.4f\n&quot;, self.fc
if Plot
  naivePlot(&amp;self)
endif
return self.fc
</code>
</gretl-function>
<gretl-function name="y_has_zero_negative_vals" type="scalar" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Check whether y includes zero or negative values.
return: 0 if not zero or negative values, otherwise 1. */
smpl y != replace_nan_value_by() --restrict
scalar ret = (sum(y &lt;= 0) &gt; 0) ? TRUE : FALSE
return ret
</code>
</gretl-function>
<gretl-function name="endogenous_series_in_logs" type="series" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Return input series in natural logs if specified. */
if self.endogenous_in_logs == FALSE
  return y
endif
scalar code = y_has_zero_negative_vals(y, &amp;self)
if self.endogenous_in_logs == TRUE &amp;&amp; code == TRUE
  Error(&quot;Endogenous series includes zero or negative values. You cannot compute logs.&quot;)
  self.error = TRUE
  return y
elif self.endogenous_in_logs == TRUE &amp;&amp; code == FALSE
  return log(y)
endif
</code>
</gretl-function>
<gretl-function name="print_dropped_series" type="void" private="1">
 <params count="3">
  <param name="old" type="list" const="true"/>
  <param name="new" type="list" const="true"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* */
list dropped = old - new
if nelem(dropped) &amp;&amp; self.verbose
  printf &quot;Warning: The following regressors were droppped as they include only zeros:\n           %s&quot;, varname(dropped)
endif
</code>
</gretl-function>
<gretl-function name="series_isconst" type="scalar" private="1">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Check whether series is constant. If so, return TRUE, else FALSE. */
if isconst(y) == TRUE
  Warn(sprintf(&quot;Series '%s' is a constant for the selected sample. Forecasts and associated standard-errors are set to NA.&quot;, argname(y)))
  return TRUE
endif
return FALSE
</code>
</gretl-function>
<gretl-function name="series_is_always_zero" type="scalar" private="1">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Check whether values on comprise zeros.
return: 1 if y includes only zeros, otherweise 0. */
return (sum(y) == 0) ? 1 : 0
</code>
</gretl-function>
<gretl-function name="drop_zero_series_from_list" type="list" private="1">
 <params count="1">
  <param name="L" type="list" const="true"/>
 </params>
<code>/* Drop all series from L which include only zero values.
return: list of non-zero series. */
list R = null
loop foreach i L -q
  if !series_is_always_zero(L.$i)
    list R += L.$i
  endif
endloop
return R
</code>
</gretl-function>
<gretl-function name="yaxis_ranges" type="void" private="1">
 <params count="3">
  <param name="plotlist" type="list" const="true"/>
  <param name="ylo" type="scalarref"/>
  <param name="yup" type="scalarref"/>
 </params>
<code>/* */
scalar mini = min(min(plotlist))
scalar maxi = max(max(plotlist))
scalar ylo = mini - 0.05 * abs(mini)
scalar yup = maxi + 0.05 * abs(maxi)
</code>
</gretl-function>
<gretl-function name="list_of_forecasts" type="list" private="1">
 <params count="3">
  <param name="self" type="bundle" const="true"/>
  <param name="horizons" type="matrix" const="true"/>
  <param name="suffix" type="string" const="true"/>
 </params>
<code>/* Wrapper actually calling specific functions. */
list R = null
strings models = getkeys(self.forecast_results)
loop i=1..nelem(models) -q
  if self.type_moving_window == &quot;static&quot;
    list R += get_static_forecast_list(self, models[i], suffix)
  else
    list R += get_movwindow_forecast_list(horizons, self, models[i], suffix)
  endif
endloop
return R
</code>
</gretl-function>
<gretl-function name="get_movwindow_forecast_list" type="list" private="1">
 <params count="4">
  <param name="horizons" type="matrix" const="true"/>
  <param name="self" type="bundle" const="true"/>
  <param name="model" type="string" const="true"/>
  <param name="suffix" type="string" const="true"/>
 </params>
<code>/* Return sascade of h-step forecast_results. For 'rolling'
and 'recursive' cases. */
list R = null
loop i=1..rows(horizons) -q
  scalar shift_periods = $i - 1
  R += genseries(sprintf(&quot;low_h%d_%s%s&quot;, horizons[i], model, suffix), mlag(self.forecast_results[model].forecasts_lower_bound[i,]', shift_periods, NA) )
  R += genseries(sprintf(&quot;point_h%d_%s%s&quot;, horizons[i], model, suffix), mlag(self.forecast_results[model].forecasts_point[i,]', shift_periods, NA) )
  R += genseries(sprintf(&quot;up_h%d_%s%s&quot;, horizons[i], model, suffix), mlag(self.forecast_results[model].forecasts_upper_bound[i,]', shift_periods, NA) )
endloop
return R
</code>
</gretl-function>
<gretl-function name="get_static_forecast_list" type="list" private="1">
 <params count="3">
  <param name="self" type="bundle" const="true"/>
  <param name="model" type="string" const="true"/>
  <param name="suffix" type="string" const="true"/>
 </params>
<code>/* Return single multi-step forecast_results for 'static'
case. */
list R = null
R += genseries(sprintf(&quot;low_h1to%d_%s%s&quot;, self.horizon, model, suffix), self.forecast_results[model].forecasts_lower_bound)
R += genseries(sprintf(&quot;point_h1to%d_%s%s&quot;, self.horizon, model, suffix), self.forecast_results[model].forecasts_point)
R += genseries(sprintf(&quot;up_h1to%d_%s%s&quot;, self.horizon, model, suffix), self.forecast_results[model].forecasts_upper_bound)
return R
</code>
</gretl-function>
<gretl-function name="horizons_isok" type="scalar" private="1">
 <params count="2">
  <param name="self" type="bundle" const="true"/>
  <param name="horizons" type="matrix" const="true"/>
 </params>
<code>/* Check the vector 'horizons' is ok. Relevant for
get_naive_forecasts().
: return: 1 if ok, 0 otherwise */
if self.type_moving_window != &quot;static&quot;
  if minc(horizons) &lt;= 0
    Error(&quot;You cannot select a negative forecast horizon.&quot;)
    return 0
  endif
  if maxc(horizons) &gt; self.horizon
    Error(sprintf(&quot;The maximum forecast horizon you \n               selected (=%d) does exceed the horizon set before (=%d).&quot;, maxc(horizons), self.horizon))
    return 0
  endif
endif
return 1
</code>
</gretl-function>
<gretl-function name="sufficient_future_obs" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* */
scalar tdiff = $tmax + self.n_sampleend_obs_replaced - self.t2_obsnum_y
if tdiff &lt; self.horizon
  Error(sprintf(&quot;Requested maximum forecast horizon exceeds\n           the number of available future periods. Either add observations\n           or decrease the maximum forecast horizon to %d&quot;, self.horizon - (self.horizon - tdiff)))
  self.error = 1
  return 1
endif
return 0
</code>
</gretl-function>
<gretl-function name="get_sample_end" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>scalar sample_end = obsnum(self.t2_date_y)
if self.type_moving_window == &quot;static&quot;
  scalar sample_end += self.horizon
endif
return sample_end
</code>
</gretl-function>
<gretl-function name="replace_nan_value_by" type="scalar" private="1">
<code>/* Set value for replacing future unknown values
of series to be forecasted by a specific value. Number should be positive
to avoid problems in case the endogenous is transformed to logarithms. */
return abs(98765432107)
</code>
</gretl-function>
<gretl-function name="repl_sampleend_missings_of_y" type="scalar" private="1">
 <params count="2">
  <param name="y" type="seriesref"/>
  <param name="verbose" type="bool" const="true"/>
 </params>
<code>/* Replace missing values of y at the sample end. */
smpl y --no-missing
scalar n_sampleend_obs_replaced = $tmax - $t2
if n_sampleend_obs_replaced &gt; 0
  smpl (1 + $t2) $tmax
  series y = replace_nan_value_by()
  smpl full
endif
if verbose
  printInfo(sprintf(&quot;Replaced %d missing values at the sample end of 'y'.&quot;, n_sampleend_obs_replaced))
endif
return n_sampleend_obs_replaced
</code>
</gretl-function>
<gretl-function name="valid_dates_of_y_and_xlist" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Check that sufficient future values of exogenous variables exist. */
if !nelem(self.xlist)
  return 0
endif
scalar tdiff_y_xlist = self.t2_obsnum_y - self.t2_obsnum_xlist
if tdiff_y_xlist &gt;= 0
  if tdiff_y_xlist &gt; 0
    Error(sprintf(&quot;Sample ends earlier for exogenous regressors ('%s')\n               than for the endogenous %s ('%s').&quot;, self.t2_date_xlist, self.name_endo, self.t2_date_y))
  else
    Error(sprintf(&quot;Sample ends for both the exogenous regressors\n               and for the endogenous %s at observation '%s'.&quot;, self.name_endo, self.t2_date_y))
  endif
  Error(&quot;List of exogenous has insufficient future values.&quot;)
  self.error = 1
  return 1
endif
if tdiff_y_xlist &lt; 0 &amp;&amp; (abs(tdiff_y_xlist) &lt;  self.horizon)
  Error(sprintf(&quot;You set the maximum forecast horizon to %d periods but\n           the sample of the exogenous regressors has only %d future\n           values left after period %s.\n           Either restrict the maximum forecast horizon to 'horizon = %d'\n           or add %d additional future values to the exogenous variables.&quot;, self.horizon, abs(tdiff_y_xlist), self.t2_date_xlist, abs(tdiff_y_xlist), self.horizon-abs(tdiff_y_xlist)))
  self.error = 1
  return 1
endif
return 0
</code>
</gretl-function>
<gretl-function name="print_estimation_error_msg" type="void" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>if self.verbose
  Error(&quot;Model estimation failed. Forecast values are set to            NA for the current test set.&quot;)
endif
</code>
</gretl-function>
<gretl-function name="print_forecast_error_msg" type="void" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>if self.verbose
  Error(&quot;Failed executing forecast command.&quot;)
endif
</code>
</gretl-function>
<gretl-function name="estimate_and_forecast_structism" type="matrix" private="1">
 <params count="4">
  <param name="est_command" type="string" const="true"/>
  <param name="y" type="series" const="true"/>
  <param name="train_obsnums" type="bundle" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Estimate StrucTiSM type of model and execute forecasting command. Return zero on success, otherwise zero. */
matrix fc = mshape(NA, self.horizon, 2)
bundle model = null
smpl train_obsnums.t1_obsnum train_obsnums.t2_obsnum
@est_command
scalar error = STSM_fcast(&amp;model, self.horizon_current, self.verbose)
if error == TRUE
  print_forecast_error_msg(self)
  scalar self.error = TRUE
  return fc
endif
fc = model.fcast ~ sqrt(model.fcastvar)
return fc
</code>
</gretl-function>
<gretl-function name="estimate_and_forecast_gretl" type="matrix" private="1">
 <params count="7">
  <param name="est_command" type="string" const="true"/>
  <param name="fcast_command" type="string" const="true"/>
  <param name="y" type="series" const="true"/>
  <param name="xlist" type="list" const="true"/>
  <param name="train_obsnums" type="bundle" const="true"/>
  <param name="test_obsnums" type="bundle" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Estimate built-in gretl models and execute forecasting command. Return zero on success, otherwise zero. */
matrix fc = mshape(NA, self.horizon, 2)
smpl train_obsnums.t1_obsnum train_obsnums.t2_obsnum
catch @est_command
if $error
  print_estimation_error_msg(self)
  scalar self.error = TRUE
  return fc
endif
smpl full
if sample_is_valid(test_obsnums.t1_test_obsnum, test_obsnums.t2_test_obsnum) == FALSE
  scalar self.error = TRUE
  return fc
endif
catch fcast test_obsnums.t1_test_obsnum test_obsnums.t2_test_obsnum @fcast_command
if $error
  print_forecast_error_msg(self)
  scalar self.error = TRUE
  return fc
endif
fc = $fcast ~ $fcse
return fc
</code>
</gretl-function>
<gretl-function name="compute_avgerage_forecast" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Compute avgerage forecast combination across all models
estimated. This is done foreach horizon and each moving
window, respectively. We also compute averages of forecast
intervals. */
bundle avgfc = null
if !inbundle(self, &quot;forecast_results&quot;)
  Error(&quot;Bundle 'forecast_results' does not exist.&quot;)
  scalar self.error = 1
endif
if nelem(self.forecast_results) &lt; 2
  Error(&quot;Average forecast combination requires at least two forecasting models.&quot;)
  scalar self.error = 1
endif
strings keys = get_name_of_intval_matrices(self)
if !self.error
  bundle avgfc = initialize_avgfc_bundle(self)
  # Compute for lower ~ point ~ upper separate matrices
  # holding respective values across models
  loop i=1..nelem(keys) -q
    string key_name = keys[i]		# lower ~ point ~ upper
    # return array of n matrices holding interval_part for n models
    matrices @key_name = get_interval_forecast_matrices(keys[i], self)
  endloop
  loop i=1..nelem(keys) -q
    string key_name = keys[i]		# lower ~ point ~ upper
    avgfc[keys[i]] = avg_across_matrices(@key_name)
  endloop
endif
return avgfc
</code>
</gretl-function>
<gretl-function name="avg_across_matrices" type="matrix" private="1">
 <params count="1">
  <param name="mats" type="matrices" const="true"/>
 </params>
<code>/* */
scalar n_rows = rows(mats[1])	# equivalent to self.horizon
scalar n_cols = cols(mats[1])	# equivalent to self.n_folds
matrix averages = NA * zeros(n_rows, n_cols)
loop i=1..n_rows -q
  matrix drilled = drill(mats, i)		# rows=models; cols=moving_window
  averages[i,] = meanc(drilled)		# avg. for horizon 'h' across all moving_windows
endloop
return averages
</code>
</gretl-function>
<gretl-function name="get_interval_forecast_matrices" type="matrices" private="1">
 <params count="2">
  <param name="interval_part" type="string" const="true"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Retrieve from forecast_results for all models estimated
one of the matrices holding the interval forecast results: either
lower bound, point fc, or upper bound. */
matrices ret = array(nelem(self.models))
loop i=1..nelem(self.models) -q
  ret[i] = self.forecast_results[self.models[i]][&quot;@interval_part&quot;]
endloop
return ret
</code>
</gretl-function>
<gretl-function name="get_name_of_intval_matrices" type="strings" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Name of matrices holding interval forecasts. */
return getkeys(self.forecast_results[self.models[1]])
</code>
</gretl-function>
<gretl-function name="initialize_avgfc_bundle" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* */
strings keys = get_name_of_intval_matrices(self)
bundle avgfc = null
loop i=1..nelem(keys) -q
  string key_name = keys[i]		# lower ~ point ~ upper
  matrix avgfc[keys[i]] = NA * ones(self.horizon, self.n_folds)
endloop
return avgfc
</code>
</gretl-function>
<gretl-function name="attach_column_labels" type="void" private="1">
 <params count="2">
  <param name="interval_forecasts" type="bundleref"/>
  <param name="self" type="bundle"/>
 </params>
<code>/* Add date strings as column labels for indicating the date on
which the estimates are conditioned on. */
string date_first_trainset_end = obslabel(obsnum(self.t1_forecast_date) - 2)
strings date_strings = future_date_strings(date_first_trainset_end, self.n_folds)
strings keys = getkeys(interval_forecasts)
loop i=1..nelem(keys) -q
  cnameset(interval_forecasts[keys[i]], date_strings)
endloop
</code>
</gretl-function>
<gretl-function name="attach_row_labels" type="void" private="1">
 <params count="2">
  <param name="interval_forecasts" type="bundleref"/>
  <param name="self" type="bundle"/>
 </params>
<code>/* Add date strings as row labels for 'static' forecasts,
or indicate the forecast horizon for moving-window
forecasts. */
if self.type_moving_window == &quot;static&quot;
  strings row_labels = future_date_strings(self.t2_train_date, self.horizon)
else
  strings row_labels = array_of_horizon_labels(self.horizon)
endif
strings keys = getkeys(interval_forecasts)
loop i=1..nelem(keys) -q
  rnameset(interval_forecasts[keys[i]], row_labels)
endloop
</code>
</gretl-function>
<gretl-function name="array_of_horizon_labels" type="strings" private="1">
 <params count="1">
  <param name="horizon" type="int" min="1" const="true"/>
 </params>
<code>/* Construct string array for indicating the forecast horizons. */
strings r = array(horizon)
loop i=1..horizon -q
  r[i] = sprintf(&quot;h=%d&quot;, i)
endloop
return r
</code>
</gretl-function>
<gretl-function name="future_date_strings" type="strings" private="1">
 <params count="2">
  <param name="date_of_information_str" type="string" const="true">
<description>Obs. before 1st h=1 forecast</description>
  </param>
  <param name="n_future_periods" type="int" min="1" const="true"/>
 </params>
<code>/* Construct date strings refering to the date for which a the
h-step ahead forecast was made for.*/
strings future_dates = array(n_future_periods)
scalar date_of_information_num = obsnum(date_of_information_str)
loop i=1..n_future_periods -q
  future_dates[i] = obslabel(date_of_information_num + $i)
endloop
return future_dates
</code>
</gretl-function>
<gretl-function name="point_fc_and_factor_as_arrays" type="bundle" private="1">
 <params count="2">
  <param name="collected_point_fc_and_sderr" type="matrices" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Using each model's point forecast and forecast standard errors, compute
the forecast interval assuming standard normal. */
bundle bout
scalar m = nelem(collected_point_fc_and_sderr)
matrices point_forecasts = array(m)
matrices factors = array(m)
loop i=1..m -q
  point_forecasts[i] = collected_point_fc_and_sderr[i][,1]
  factors[i] = fc_interval_width(collected_point_fc_and_sderr[i][,2], self.level)
endloop
bout.point_forecasts = point_forecasts
bout.factors = factors
return bout
</code>
</gretl-function>
<gretl-function name="fc_interval_width" type="matrix" private="1">
 <params count="2">
  <param name="fc_sd" type="matrix" const="true">
<description>Std. error of forecast</description>
  </param>
  <param name="level" type="scalar" min="0.001" max="0.999" const="true">
<description>confidence level</description>
  </param>
 </params>
<code>/* Compute width for a given condifdence level assuming standard normal. */
return fc_sd * critical(z, (1 - level) / 2 )
</code>
</gretl-function>
<gretl-function name="x_train_test_mats_static_case" type="void" private="1">
 <params count="2">
  <param name="cv" type="bundleref"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* For the static case we only need the first fold returned by
CvDataSplitter(). */
if self.type_moving_window == &quot;static&quot;
  matrices cv.X_train = defarray(cv.X_train[1])
  matrices cv.X_test = defarray(cv.X_test[1])
  cv.n_folds = nelem(cv.X_test)
endif
</code>
</gretl-function>
<gretl-function name="prep_and_get_cv_folds" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Prepare bundle for CvDataSplitter() and compute folds. */
bundle cv					# Tried to put this into a bundle, but git issues with index series
# y includes the additional n=horizon newly added observations for
# the very last cv-dataset
series y = self.y
list xlist = self.xlist
string cv.cv_type = (self.type_moving_window==&quot;rolling&quot;) ? &quot;rolwin&quot; : &quot;recwin&quot;
scalar cv.win_size = self.window_length
list cv.X = y xlist
CvDataSplitter(&amp;cv)
x_train_test_mats_static_case(&amp;cv, self)
return cv
</code>
</gretl-function>
<gretl-function name="valid_window_length" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Returns zero of window_length is valid. */
if smplspan(self.t1_date_y, self.t2_date_y, $pd) &lt; self.window_length
  Error(sprintf(&quot;The window size you selected (wsize=%d) exceeds the\n           number of valid observations in '%s'.&quot;, self.window_length, self.name_endo))
  return 1
endif
return 0
</code>
</gretl-function>
<gretl-function name="get_estimator_names" type="strings" private="1">
 <params count="1">
  <param name="is_seas" type="bool" const="true">
<description>0=data has no seasonality, 1=it has</description>
  </param>
 </params>
<code>/* Obtain names of methods going to apply. */
strings methods = strdrop(get_supported_nonseas_methods(), &quot;avgfc&quot;)
if is_seas
  methods += get_supported_seas_methods()
endif
return methods
</code>
</gretl-function>
<gretl-function name="obslabels_and_nobs_to_bundle" type="void" private="1">
 <params count="2">
  <param name="y" type="list" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>smpl y --contiguous
string self.t1_date = obslabel($t1)
string self.t2_date = obslabel($t2)
scalar self.T = $nobs
</code>
</gretl-function>
<gretl-function name="printInfo" type="void" private="1">
 <params count="1">
  <param name="s" type="string" const="true"/>
 </params>
<code>printf &quot;\nInfo: %s\n&quot;, s
</code>
</gretl-function>
<gretl-function name="Warn" type="void" private="1">
 <params count="1">
  <param name="s" type="string" const="true"/>
 </params>
<code>printf &quot;\nWarning: %s\n&quot;, s
</code>
</gretl-function>
<gretl-function name="Error" type="void" private="1">
 <params count="1">
  <param name="s" type="string" const="true"/>
 </params>
<code>printf &quot;\nError: %s\n&quot;, s
</code>
</gretl-function>
<gretl-function name="set_bundle" type="bundle" private="1">
 <params count="3">
  <param name="y" type="series" const="true"/>
  <param name="which" type="string"/>
  <param name="opts" type="bundle" optional="true"/>
 </params>
<code>/* Compile self bundle by merging eventual information
from opts-bundle. */
if !exists(opts)
  bundle opts = null
endif
bundle self = default_values(y)
self = opts + self			# override defaults
self.which = tolower(which)
if self.which != &quot;avgfc&quot;
  strings self.models = defarray(self.which)
else
  strings self.models = self.supported_estimators
endif
self.forecast_results = prepare_forecast_bundles(&amp;self)
self.type_moving_window = tolower(self.type_moving_window)
self.name_endo = argname(y)
return self
</code>
</gretl-function>
<gretl-function name="model_is_ucm" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Check whether the selected/ active model is an unobserved component model (UCM) from the StrucTiSM package. */
scalar r = FALSE
strings ucm = get_supported_structism_methods()
matrix pos = instrings(ucm, self.active_model)
if nelem(pos) &gt; 0
  return TRUE
endif
return r
</code>
</gretl-function>
<gretl-function name="get_supported_structism_methods" type="strings" private="1">
<code>/* List all methods supported by the StrucTiSM package. */
return defarray(&quot;bsmfc&quot;, &quot;lltfc&quot;)
</code>
</gretl-function>
<gretl-function name="get_supported_seas_methods" type="strings" private="1">
<code>/* List all seasonal supported methods here. */
return defarray(&quot;smeanfc&quot;, &quot;smedianfc&quot;, &quot;snaivefc&quot;, &quot;snaivedriftfc&quot;, &quot;airlinefc&quot;) + get_supported_structism_methods()
</code>
</gretl-function>
<gretl-function name="get_supported_nonseas_methods" type="strings" private="1">
<code>/* List all non-seasonal supported methods here. */
return defarray(&quot;meanfc&quot;, &quot;medianfc&quot;, &quot;rwfc&quot;, &quot;rwdriftfc&quot;, &quot;ar1fc&quot;, &quot;ar1trendfc&quot;, &quot;avgfc&quot;, &quot;ar1ma1fc&quot;)
</code>
</gretl-function>
<gretl-function name="data_has_seasonality" type="scalar" private="1">
<code>/* Flag seasonality of data set */
return ($pd &gt; 1) ? 1 : 0
</code>
</gretl-function>
<gretl-function name="gen_column_names" type="strings" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Construct column names */
strings s = defarray(self.which)
if self.which != &quot;avgfc&quot;
  s += sprintf(&quot;Lo (%.1f)&quot;, (1-self.level) / 2 * 100 )
  s += sprintf(&quot;Up (%.1f)&quot;, ( 1-(1-self.level)/2 ) * 100 )
endif
return s
</code>
</gretl-function>
<gretl-function name="print_no_bootstrap_support" type="void" private="1">
<code>Error(&quot;Bootstrap confidence intervals are not supported, yet&quot;)
</code>
</gretl-function>
<gretl-function name="get_test_start_end_obsnums" type="bundle" private="1">
 <params count="2">
  <param name="train_obsnums" type="bundle" const="true"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Compute start and end date of test sample based. */
bundle ret = null
scalar ret.t1_test_obsnum = 1 + train_obsnums.t2_obsnum
scalar ret.t2_test_obsnum = ret.t1_test_obsnum + self.horizon_current - 1
return ret
</code>
</gretl-function>
<gretl-function name="get_train_start_end_obsnums" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Return obs. numbers for trainings set. */
bundle ret = null
if self.type_moving_window == &quot;static&quot;
  # these are simply in-sample dates
  ret.t1_obsnum = obsnum(self.t1_date_y)
  ret.t2_obsnum = obsnum(self.t2_date_y)
else
  scalar ret.t2_obsnum = $t2 - self.horizon_current
  scalar ret.t1_obsnum = 1 + ret.t2_obsnum - self.window_length
endif
return ret
</code>
</gretl-function>
<gretl-function name="get_highest_period_series" type="series" private="1">
<code>/* Return series holding highest available frequency. */
catch series period = $obsmicro
if $error
  catch series period = $obsminor
  if $error
    series period = $obsmajor
  endif
endif
return period
</code>
</gretl-function>
<gretl-function name="add_intercept_to_list" type="list" private="1">
<code>/* Add intercept to list. */
list xlist = const
return xlist
</code>
</gretl-function>
<gretl-function name="add_ohe_periods_to_list" type="list" private="1">
<code>/* Add list of dummyfied frequency components to list. */
series period = get_highest_period_series()
list xlist = dummify(period)
return xlist
</code>
</gretl-function>
<gretl-function name="add_linear_trend_to_list" type="list" private="1">
<code>/* Add linear trend to list. */
genr time
list xlist = time
return xlist
</code>
</gretl-function>
<gretl-function name="window_length_is_ok" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Check that sample length fits window length. Return TRUE if so, otherwise FALSE. */
if self.type_moving_window != &quot;static&quot; &amp;&amp; ($nobs &gt; self.window_length)
  Error(sprintf(&quot;The training sample (T=%d) is longer than the\n           specified window length (T=%d).&quot;, $nobs, self.window_length))
  return FALSE
endif
return TRUE
</code>
</gretl-function>
<gretl-function name="sample_is_valid" type="scalar" private="1">
 <params count="2">
  <param name="start" type="scalar" const="true"/>
  <param name="ende" type="scalar" const="true"/>
 </params>
<code>/* Check that sample is valid. If so return TRUE, else FALSE.*/
catch smpl start ende
if $error
  Error(&quot;Sample cannot be set.&quot;)
  return FALSE
endif
return TRUE
</code>
</gretl-function>
<gretl-function name="dict_models" type="bundle" private="1">
<code>/* Dictionary including stuff for calling estimation
command and fcast command. */
bundle dict_models
dict_models.meanfc = defbundle( &quot;forecast_arg&quot;, &quot;--static&quot;, &quot;command&quot;, &quot;ols y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.medianfc = defbundle( &quot;forecast_arg&quot;, &quot;--static&quot;, &quot;command&quot;, &quot;quantreg 0.5 y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.smeanfc = defbundle( &quot;forecast_arg&quot;, &quot;--static&quot;, &quot;command&quot;, &quot;ols y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 1 )
dict_models.smedianfc = defbundle( &quot;forecast_arg&quot;, &quot;--static&quot;, &quot;command&quot;, &quot;quantreg 0.5 y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 1 )
dict_models.snaivefc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;arima 0 0 0 ; 0 1 0 ; y xlist --nc&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.snaivedriftfc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;arima 0 0 0 ; 0 1 0 ; y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.rwfc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;arima 0 1 0 ; y xlist --nc&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 0, &quot;add_ohe_periods&quot;, 0 )
dict_models.rwdriftfc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;arima 0 1 0 ; y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 0, &quot;add_ohe_periods&quot;, 0 )
dict_models.ar1fc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;ols y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 1, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.ar1trendfc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;ols y xlist&quot;, &quot;add_linear_trend&quot;, 1, &quot;add_first_lag&quot;, 1, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.ar1ma1fc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;arima 1 0 1 ; y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
# Harvey (1989, sect. 2.5.5) has shown that the autocorrelation structure of the airline model is similar to that of an UCM composed by LLT and stochastic seasonals.
dict_models.airlinefc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;arima 0 1 1 ; 0 1 1 ; y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.bsmfc = defbundle( &quot;forecast_arg&quot;, &quot;&quot;, &quot;command&quot;, &quot;BSM(y, 0, &amp;model)&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 0, &quot;add_ohe_periods&quot;, 0 )
dict_models.lltfc = defbundle( &quot;forecast_arg&quot;, &quot;&quot;, &quot;command&quot;, &quot;LLT(y, 0, &amp;model)&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 0, &quot;add_ohe_periods&quot;, 0 )
return dict_models
</code>
</gretl-function>
<gretl-function name="default_values" type="bundle" private="1">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Set default values */
bundle self = null
scalar self.error = FALSE
scalar self.y_is_constant = FALSE
list self.xlist = null
scalar self.endogenous_in_logs = FALSE
scalar self.horizon = 10				# maximum forecast horizon
scalar self.level = 0.9					# probability level for forecast interval
scalar self.fan = FALSE						# plot fan chart  (not supported yet)
scalar self.nboot = 0					# no. of bootstrap replications  (not supported yet)
scalar self.blength = 4					# Block length bootstrap  (not supported yet)
scalar self.is_seas = data_has_seasonality()
strings self.supported_estimators = get_estimator_names(self.is_seas)
scalar self.verbose = 1
genr index
series self.index = index
string self.type_moving_window = &quot;static&quot; 			# &quot;static&quot;, &quot;rolling&quot; or &quot;recursive&quot;
scalar self.window_length = ceil(0.25 * nobs(y))	# default window length for moving-windows
# For naivePlot()
string self.title = &quot;&quot;
string self.ylab = &quot;&quot;
string self.xlab = &quot;&quot;
string self.filename = &quot;display&quot;
scalar self.pre_fc_periods_to_plot = int(0.25 * nobs(y))
return self
</code>
</gretl-function>
<gretl-function name="prepare_xlist" type="list" private="1">
 <params count="2">
  <param name="model_settings" type="bundle" const="true"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Prepare list of additional regressors. */
list xlist = null
if model_settings.add_ohe_periods
  xlist += add_ohe_periods_to_list()
endif
if model_settings.add_intercept
  xlist += add_intercept_to_list()
endif
if model_settings.add_linear_trend
  xlist += add_linear_trend_to_list()
endif
if inbundle(self, &quot;xlist&quot;)
  xlist += self.xlist
endif
xlist = add_lagged_y_to_xlist(self.y, xlist, model_settings)
# TODO: check for duplicates in xlist
return xlist
</code>
</gretl-function>
<gretl-function name="add_quiet_str_to_command" type="string" private="1">
 <params count="2">
  <param name="self" type="bundle" const="true"/>
  <param name="model_settings" type="bundle" const="true"/>
 </params>
<code>/* Retrieve command string for estimation and optionally attache &quot;quiet&quot; string. */
string command = model_settings.command
command += (self.verbose &lt; 2 &amp;&amp; model_is_ucm(self) == FALSE) ? &quot; --quiet&quot; : &quot;&quot;  # estimation details only for detailed verbosity
return command
</code>
</gretl-function>
<gretl-function name="add_quiet_str_to_fcast_arg" type="string" private="1">
 <params count="2">
  <param name="self" type="bundle" const="true"/>
  <param name="model_settings" type="bundle" const="true"/>
 </params>
<code>/* Retrieve command string for getting forecast values and optionally attache &quot;quiet&quot; string. */
string fcast_arg = model_settings.forecast_arg
fcast_arg += (self.verbose &lt; 2 &amp;&amp; model_is_ucm(self) == FALSE) ? &quot; --quiet&quot; : &quot;&quot;
return fcast_arg
</code>
</gretl-function>
<gretl-function name="add_lagged_y_to_xlist" type="list" private="1">
 <params count="3">
  <param name="y" type="series" const="true"/>
  <param name="xlist" type="list"/>
  <param name="model_settings" type="bundle" const="true"/>
 </params>
<code>/* Conditionally add 1st lag of endogenous to xlist. */
if model_settings.add_first_lag == TRUE
  xlist += y(-1)
endif
return xlist
</code>
</gretl-function>
<gretl-function name="set_xlist_and_forecast" type="matrix" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Set list of regressors, estimate model and compute point forecast and forecast standard errors. */
matrix forecast_results = mshape(NA, self.horizon, 2)
series y = self.y         # length: window_length + horizon
bundle model_settings = dict_models()[self.active_model]
string command = add_quiet_str_to_command(self, model_settings)
string fcast_arg = add_quiet_str_to_fcast_arg(self, model_settings)
list xlist = prepare_xlist(model_settings, self)
# &quot;(train_obsnums.t2_obsnum - train_obsnums.t1_obsnum)&quot;
# is not the effective sample length but (window_length-max(lags))
bundle train_obsnums = get_train_start_end_obsnums(self)
bundle test_obsnums = get_test_start_end_obsnums(train_obsnums, self)
# Check training and test samples
if sample_is_valid(train_obsnums.t1_obsnum, train_obsnums.t2_obsnum) == FALSE
  scalar self.error = TRUE
  return forecast_results
endif
smpl train_obsnums.t1_obsnum train_obsnums.t2_obsnum
# TODO: Can this happen, and if so why -- otherwise drop
if window_length_is_ok(self) == FALSE
  scalar self.error = TRUE
  return forecast_results
endif
# Check series
scalar self.y_is_constant = series_isconst(y)
if self.y_is_constant == TRUE
  return forecast_results
endif
list xlist_new = drop_zero_series_from_list(xlist)
print_dropped_series(xlist, xlist_new, self)
list xlist = xlist_new
if model_is_ucm(self) == TRUE
  forecast_results[1:self.horizon_current,] = estimate_and_forecast_structism(command, y, train_obsnums, &amp;self)
else
  smpl full     # samples are set within function
  forecast_results[1:self.horizon_current,] = estimate_and_forecast_gretl(command, fcast_arg, y, xlist, train_obsnums, test_obsnums, &amp;self)
endif
return forecast_results
</code>
</gretl-function>
<gretl-function name="do_initial_checks" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Helper function perfoming some initial checks */
pkg query extra --quiet
if $result.version &lt; 0.6
  Error(&quot;You need at least version 0.6 of the 'extra' package.&quot;)
  Error(&quot;Update by executing 'pkg install extra'&quot;)
endif
strings methods = get_supported_nonseas_methods()
strings seas_methods = get_supported_seas_methods()
# Check whether called method exists
if !nelem(instrings(methods, self.which)) &amp;&amp; !nelem(instrings(seas_methods, self.which))
  Error(&quot;The forecasting method you selected does not exist.&quot;)
  self.error = 1
endif
if !self.is_seas &amp;&amp; nelem(instrings(seas_methods, self.which))
  Error(&quot;The method you requested is not available for non-seasonal data.&quot;)
  self.error = 1
endif
# TODO: Why is this necessary??
if self.window_length &lt; $pd
  Error(sprintf(&quot;Window size = %d&quot;, self.window_length))
  Error(sprintf(&quot;Periodicity = %d\n&quot;, $pd))
  Error(&quot;The size of the moving window cannot be smaller than the underlying periodicity.&quot;)
  #        self.error = 1		# TODO: don't return error as long as it is not clear why/ when this case matters
endif
if self.nboot
  print_no_bootstrap_support()
  self.error = 1
endif
</code>
</gretl-function>
<gretl-function name="xlist_is_valid" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Flag whether the requested method supports exogenous variables. */
strings not_valid_for = defarray(&quot;rwfc&quot;, &quot;rwdriftfc&quot;, &quot;snaivefc&quot;, &quot;snaivedriftfc&quot;, &quot;bsmfc&quot;, &quot;lltfc&quot;)
matrix not_supported = instrings(not_valid_for, self.which)
if nelem(self.xlist) &gt; 0 &amp;&amp; nelem(not_supported) &gt; 0
  Warn(sprintf(&quot;No exogenous variables can be included for the selected model '%s'.&quot;, self.which))
  printInfo(&quot;List of exogenous will be cleared. Proceed.&quot;)
  list self.xlist = null
endif
</code>
</gretl-function>
<gretl-function name="t1_and_t2_of_y_and_xlist" type="void" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Check valid start and end dates of y and xlist. */
list xlist = self.xlist
scalar t1_curr = $t1
scalar t2_curr = $tmax
bundle obsdetails_y
bundle obsdetails_x
obslabels_and_nobs_to_bundle(y, &amp;obsdetails_y)
string self.t1_date_y = obsdetails_y.t1_date
string self.t2_date_y = obslabel(obsnum(obsdetails_y.t2_date) - self.n_sampleend_obs_replaced)
scalar self.t1_obsnum_y = obsnum(self.t1_date_y)
scalar self.t2_obsnum_y = obsnum(self.t2_date_y)
scalar t1_diff_y = self.t1_obsnum_y - t1_curr
scalar t2_diff_y = t2_curr - self.t2_obsnum_y
if t1_diff_y &gt; 0
  Warn(sprintf(&quot;Found %d missing initial observations for %s.&quot;, t1_diff_y, self.name_endo))
endif
if nelem(xlist)
  obslabels_and_nobs_to_bundle(xlist, &amp;obsdetails_x)
  scalar self.t1_obsnum_xlist = obsnum(obsdetails_x.t1_date)
  scalar self.t2_obsnum_xlist = obsnum(obsdetails_x.t2_date)
  string self.t1_date_xlist = obsdetails_x.t1_date
  string self.t2_date_xlist = obsdetails_x.t2_date
  scalar t1_diff_x = self.t1_obsnum_xlist - t1_curr
  scalar t2_diff_x = t2_curr - self.t2_obsnum_xlist
  if t1_diff_x &gt; 0
    Warn(sprintf(&quot;Found %d missing initial observations for exogenous.&quot;, t1_diff_x))
  endif
  if t2_diff_x &gt; 0
    Warn(sprintf(&quot;Found %d missing observations at sample end for exogenous.&quot;, t2_diff_x))
  endif
endif
</code>
</gretl-function>
<gretl-function name="cleanup_bundle" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Delete some elements before returning to user. */
delete self.fan
delete self.blength
delete self.nboot
if inbundle(self,&quot;obs_season&quot;)
  delete self.obs_season
endif
delete self.supported_estimators
delete self.index
delete self.active_model
delete self.horizon_current
delete self.t1_date_y
delete self.t2_date_y
delete self.xlist
</code>
</gretl-function>
<gretl-function name="prepare_forecast_bundles" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Prepare for each estimator a dictionary for point
interval forecast results to be stored in matrices. */
bundle forecast_results
loop i=1..nelem(self.models) -q
  string model = self.models[i]
  bundle forecast_results[&quot;@model&quot;] = null
endloop
return forecast_results
</code>
</gretl-function>
<gretl-function name="do_naive_forecasting" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Wrapper function actually calling procedures. */
strings models = getkeys(self.forecast_results)
loop i=1..nelem(self.forecast_results) -q	# loop over models
  self.active_model = models[i]
  bundle interval_forecasts = execute_forecasting(&amp;self)
  attach_row_labels(&amp;interval_forecasts, self)
  attach_column_labels(&amp;interval_forecasts, self)
  self.forecast_results[self.active_model] = interval_forecasts
endloop
</code>
</gretl-function>
<gretl-function name="summarize_naive_fc_results" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Print summarising information */
if self.verbose
  printf &quot;\n-------------------------------------------------------------------\n&quot;
  printf &quot;\t\tSummary of naive forecasting\n&quot;
  printf &quot;\nForecasting method: \t\t\t%s\n&quot;, self.which
  printf &quot;Endogenous: \t\t\t\t%s\n&quot;, self.name_endo
  if self.endogenous_in_logs
    printf &quot;Estimates based on logarithms of %s\n&quot;, self.name_endo
  endif
  printf &quot;Number of additional regressors: \t%d\n&quot;, nelem(self.xlist)
  printf &quot;In-Sample: \t\t\t\t%s to %s (T = %d)\n&quot;, self.t1_date_y, self.t2_date_y, nobs(self.y) - self.horizon
  printf &quot;Max. forecast horizon: \t\t\t%d\n&quot;, self.horizon
  if self.type_moving_window == &quot;static&quot;
    printf &quot;Last in-sample observation: \t\t%s\n&quot;, self.t2_train_date
  elif self.type_moving_window == &quot;rolling&quot;
    printf &quot;Moving window length: \t\t\t%d\n&quot;, self.window_length
  else
    printf &quot;Initial window length: \t\t\t%d\n&quot;, self.window_length
  endif
  if self.type_moving_window != &quot;static&quot;
    printf &quot;Number of '%s' multi-step forecasts: %d\n&quot;, self.type_moving_window, self.n_folds
    printf &quot;First observation forecasted: \t\t%s\n&quot;, self.t1_forecast_date
    printf &quot;Last observation forecasted: \t\t%s\n&quot;, self.t2_forecast_date
  else
    printf &quot;First observation forecasted (h=1): \t%s\n&quot;, self.t1_forecast_date
    printf &quot;Last observation forecasted (h=%d): \t%s\n&quot;, self.horizon, self.t2_forecast_date
  endif
  if self.type_moving_window == &quot;static&quot;
    printf &quot;Width forecast interval: \t\t%d pct.\n&quot;, self.level * 100
  else
  endif
  printf &quot;-------------------------------------------------------------------\n\n&quot;
endif
</code>
</gretl-function>
<gretl-function name="execute_forecasting" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* This function estimates the point forecasts either in (i) a rolling or
(ii) a recursive manner and stores sequences of interval forecasts. */
bundle cv = prep_and_get_cv_folds(self)
self.n_folds = cv.n_folds
# Loop over training sets, run estimation and retrieve interval forecasts.
# returns an n_folds-dimensional array comprising h by 2 (point~sderr) matrices.
matrices collected_point_fc_and_sderr = set_model_estimate_and_forecast(&amp;cv, &amp;self)
bundle forecasts_and_factors = point_fc_and_factor_as_arrays(collected_point_fc_and_sderr, &amp;self)
# Retrieve moving-window point_forecasts from array,
# compute forecast intervals and put stuff to bundle
if self.endogenous_in_logs == FALSE || self.y_is_constant == TRUE
  return compute_intval_forecasts(forecasts_and_factors)
elif self.endogenous_in_logs == TRUE &amp;&amp; self.y_is_constant == FALSE
  bundle interval_forecasts = compute_intval_forecasts(forecasts_and_factors)
  bundle intval_fc_in_levels = intval_forecasts_to_levels(interval_forecasts, collected_point_fc_and_sderr, self)
  return intval_fc_in_levels
endif
</code>
</gretl-function>
<gretl-function name="compute_intval_forecasts" type="bundle" private="1">
 <params count="1">
  <param name="forecasts_and_factors" type="bundle" const="true"/>
 </params>
<code>/* Generate arrays holding interval forecasts for each model based
on respective point forecasts and estimated standard derrors. */
bundle interval_forecasts
matrix interval_forecasts.forecasts_point = flatten(forecasts_and_factors.point_forecasts) # rows: horizons, cols: sample period
matrix factors_flattened = flatten(forecasts_and_factors.factors)
matrix interval_forecasts.forecasts_lower_bound = interval_forecasts.forecasts_point .- factors_flattened
matrix interval_forecasts.forecasts_upper_bound = interval_forecasts.forecasts_point .+ factors_flattened
return interval_forecasts
</code>
</gretl-function>
<gretl-function name="intval_forecasts_to_levels" type="bundle" private="1">
 <params count="3">
  <param name="interval_forecasts" type="bundle" const="true"/>
  <param name="collected_point_fc_and_sderr" type="matrices" const="true"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Once interval forecasts are computed but the endogenous was transformed to
logarithms, we need to compute the levels of the interval forecasts. */
bundle in_levels
scalar m = nelem(collected_point_fc_and_sderr)	# number of moving-windows
matrix in_levels.forecasts_point = NA * zeros(self.horizon, m)
matrix in_levels.forecasts_lower_bound = NA * zeros(self.horizon, m)
matrix in_levels.forecasts_upper_bound = NA * zeros(self.horizon, m)
loop i=1..m -q
  in_levels.forecasts_point[,i] = log_linear_to_levels(interval_forecasts.forecasts_point[,i], collected_point_fc_and_sderr[i][,2])
  in_levels.forecasts_lower_bound[,i] = log_linear_to_levels(interval_forecasts.forecasts_lower_bound[,i], collected_point_fc_and_sderr[i][,2])
  in_levels.forecasts_upper_bound[,i] = log_linear_to_levels(interval_forecasts.forecasts_upper_bound[,i], collected_point_fc_and_sderr[i][,2])
endloop
return in_levels
</code>
</gretl-function>
<gretl-function name="log_linear_to_levels" type="matrix" private="1">
 <params count="2">
  <param name="forecast" type="matrix" const="true">
<description>Point forecast</description>
  </param>
  <param name="forecast_stderr" type="matrix" const="true">
<description>Forecast standard error</description>
  </param>
 </params>
<code>/* In case the endogenous was transformed to logarithms, retrieve the level.
Important assumptions made:
1) You want to forecast via conditional expectation (ie with quadratic loss)
2) Data are at least approximately normal
Read: https://davegiles.blogspot.com/2013/08/forecasting-from-log-linear-regressions.html
*/
return exp( forecast + 0.5 * forecast_stderr.^2 )
</code>
</gretl-function>
<gretl-function name="set_model_estimate_and_forecast" type="matrices" private="1">
 <params count="2">
  <param name="cv" type="bundleref"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Loop over training sets, run estimation and retrieve
interval forecasts. */
matrices collected_point_fc_and_sderr = array(cv.n_folds)
loop lwin=1..cv.n_folds -q
  matrix date_idx = cv.X_train[lwin]
  # time index of the training set = self.window_length + self.horizon
  # As the last rolling samples may inlude only a sample set less than self.horizon
  # observations, we still can compute forecasts for $Ttest &lt; self.horizon
  scalar obs_left = $tmax - maxc(date_idx[,1])
  scalar self.horizon_current = xmin(self.horizon, obs_left)
  if self.horizon_current == 0
    break
  endif
  smpl minc(date_idx[,1]) (maxc(date_idx[,1]) + self.horizon_current)
  if lwin == 1
    # CV series holds &quot;window_length+horizon&quot; observations: subtract &quot;horizon&quot;
    self.t1_train_date = obslabel($t1)
    string self.t2_train_date = obslabel($t2 - self.horizon_current)
    string self.t1_forecast_date = obslabel($t2 - self.horizon_current + 1)	# Date of 1st h=1 ahead forecast
  elif lwin == (cv.n_folds - 1) &amp;&amp; self.type_moving_window != &quot;static&quot;
    self.t2_forecast_date = self.t2_date_y		# Date of last h-step ahead forecast
  endif
  collected_point_fc_and_sderr[lwin] = set_xlist_and_forecast(&amp;self)	# h by 2 matrix (point_fc ~ sderr)
endloop
if self.type_moving_window == &quot;static&quot;
  string self.t2_forecast_date = obslabel(obsnum(self.t2_train_date) + self.horizon)	# Date of last h-step ahead forecast
endif
return collected_point_fc_and_sderr
</code>
</gretl-function>
<gretl-function name="get_specific_model_for_avgfc" type="list" private="1">
 <params count="3">
  <param name="self" type="bundle" const="true"/>
  <param name="plotlist" type="list" const="true"/>
  <param name="model" type="string"/>
 </params>
<code>/* In case of &quot;avgfc&quot; we only plot the results for a specific model
but not for all in a single plot. */
if self.which == &quot;avgfc&quot;
  string model = tolower(model)
  list plotlist = get_model_forecasts_from_list(plotlist, model)
  if nelem(plotlist) == 0
    funcerr &quot;Model requested is not supported.&quot;
  endif
endif
return plotlist
</code>
</gretl-function>
<gretl-function name="get_model_forecasts_from_list" type="list" private="1">
 <params count="2">
  <param name="plotlist" type="list" const="true"/>
  <param name="model" type="string" const="true"/>
 </params>
<code>/* Retrieve from list only those series which include
model in its serie's name. */
list new = null
loop foreach i plotlist -q
  if instring(varname(plotlist.$i), sprintf(&quot;_%s&quot;, model))
    list new += $i
  endif
endloop
return new
</code>
</gretl-function>
<gretl-function name="call_plot" type="void" private="1">
 <params count="2">
  <param name="plotlist" type="list" const="true"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* */
string filename = self.filename
scalar ylo
scalar yup
yaxis_ranges(plotlist, &amp;ylo, &amp;yup)
plot plotlist
  options with-lp time-series single-yaxis
  literal set linetype 1 lc rgb &quot;black&quot; lw 1 pt 0 ps 0
  literal set linetype 3 lc rgb &quot;red&quot; lw 1.5 ps 0
  literal set linetype 2 lc rgb &quot;grey&quot; lw 1.5 ps 0
  literal set linetype 4 lc rgb &quot;grey&quot; lw 1.5 ps 0
  literal set key left bottom below
  #literal set key inside left bottom
  #put the border more to the background by applying it
  # only on the left and bottom part and put it and the tics in gray
  literal set style line 11 lc rgb &quot;#808080&quot; lt 1
  literal set border 3 back ls 11			# get rid of upper + left border
  literal set tics nomirror
  #add a slight grid to make it easier to follow the exact position of the curves
  literal set style line 12 lc rgb &quot;#808080&quot; lt 0 lw 1	# light grey color
  literal set grid back ls 12
  printf &quot;set yrange[%g:%g]&quot;, ylo, yup
  printf &quot;set ylabel \&quot;%s\&quot;&quot;, self.ylab
  printf &quot;set xlabel \&quot;%s\&quot;&quot;, self.xlab
  printf &quot;set title \&quot;%s\&quot;&quot;, self.title
end plot --output=&quot;@filename&quot;
</code>
</gretl-function>
<sample-script>
clear
set verbose off
#set debug 0

include StrucTiSM.gfn
#include naiveFC.gfn --force				# TODO:

if $sysinfo.hostname == &quot;dsb&quot;
    string WD = &quot;/home/ninja/repo/naiveFC/gretl&quot;
elif $sysinfo.hostname == &quot;bipower6&quot;
    string WD = &quot;/home/atarasso/git/naiveFC/gretl&quot;
else
    string WD = &quot;/home/at/git/naiveFC/gretl&quot;
endif
set workdir @WD

# TODO: can be dropped once gfn compiled
include string_utils.gfn			# already added to spec
include CvDataSplitter.gfn			# already added to spec
include extra.gfn					# already added to spec

include &quot;./src/naiveFC.inp&quot; --force
include &quot;./src/naiveFC_helper.inp&quot; --force


# Load data
#open AWM.gdt -q
#series y = GCR_YER * 100

open &quot;../tests/daily_data.gdt&quot; -q
series y = target

#=======================
# Static naive forecasts
#=======================
/*
   # Forecast combination
   # smpl ; -1					# FIXME: In case the dataset is restricted, internal addobs does not work!
   bundle b = null
   b = naiveFC(y, &quot;avgFC&quot;)				# compute forecasts
   print b
   matrix fc_method1_lb = b.forecasts_lower_bound[2]
   fc_method1_lb
   naivePlot(&amp;b)						# plot forecast results
   stop

   # Forecast combination but up to h=15 forecast periods
   bundle opt = null					# set specific options
   scalar opt.horizon = 10
   #list opt.xlist = D743 FDD			# list of additional regressors for conditioning on (must have at least 'h' future valid obs!)
   bundle b = naiveFC(y, &quot;avgFC&quot;, opt)
   matrix fc_avgfc_pt = b.forecasts_point[10]
   b.pre_fc_periods_to_plot = 15					# optional: set no. of pre.-forecast periods obs. to plot
   naivePlot(&amp;b)

   # Mean forecast
   bundle opt = null					# set specific options
   scalar opt.horizon = 10
   bundle b = naiveFC(y, &quot;meanFC&quot;, opt)
   print b
   eval b.forecasts_point[1]
   stop
   naivePlot(&amp;b)
   eval b.fc

   # Median forecast
   bundle b = naiveFC(y, &quot;medianFC&quot;, opt)
   eval b.forecasts_point[1]

   naivePlot(&amp;b)
   eval b.fc

   # Random-Walk
   bundle b = naiveFC(y, &quot;rwFC&quot;, opt)
   eval b.forecasts_point[1]
   naivePlot(&amp;b)
   eval b.fc

   # Random-Walk + Drift
   bundle b = naiveFC(y, &quot;rwdriftFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # AR(1)
   bundle b = naiveFC(y, &quot;ar1FC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # AR(1) + Trend
   bundle b = naiveFC(y, &quot;ar1trendFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # Seasonal mean
   bundle b = naiveFC(y, &quot;smeanFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # Seasonal median
   bundle b = naiveFC(y, &quot;smedianFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # Seasonal naive without drift
   bundle b = naiveFC(y, &quot;snaiveFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # Seasonal naive with drift
   bundle b = naiveFC(y, &quot;snaivedriftFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc
*/

#/* ACTIVATE IF WANTED: may take a while
#=========================
# Moving-window forecasts
#=========================
bundle opts = null					# setup additional options
opts.horizon = 10
opts.type_moving_window = &quot;rolling&quot; #/ &quot;recursive&quot; -&gt; type of moving-window forecasting  (optional)
scalar opts.endogenous_in_logs = TRUE
opts.window_length = 700 #xmax($pd, 90) 	# moving window length (optional)
# opts.window_length = $tmax
catch list opts.xlist = budget #D743 FDD		# optional additional regressors
opts.verbose = 1						# print details (optional)

# TODO: in case of moving-window fc, xlist does not need to have additional oos valid data
# TODO as we forecast only to the last valid obs of y in this case anyway!
# FIXME: moving-window fc with &quot;avgfc&quot;

strings methods = defarray(&quot;lltfc&quot;, &quot;bsmfc&quot;, &quot;airlinefc&quot;, &quot;ar1ma1fc&quot;, &quot;meanFC&quot;, &quot;medianFC&quot;, &quot;rwFC&quot;, &quot;rwdriftFC&quot;, \
  &quot;smeanFC&quot;, &quot;smedianFC&quot;, &quot;snaiveFC&quot;, &quot;snaivedriftFC&quot;, &quot;ar1FC&quot;, &quot;ar1trendFC&quot;, &quot;avgfc&quot;)

bundle b = null
bundle b = naiveFC(y, methods[3], opts)
b
bundle forecast_results = b.forecast_results

#eval forecast_results.smeanfc
#eval forecast_results.smeanfc.forecasts_point

list FC = get_naive_forecasts(b, {1,2})

b.pre_fc_periods_to_plot = 60					# set no. of pre.-forecast periods obs. to plot
plot_naive_forecasts(b, {1}, b.which)
</sample-script>
</gretl-function-package>
</gretl-functions>
