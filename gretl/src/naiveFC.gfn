<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="naiveFC" needs-time-series-data="true" minver="2019b" lives-in-subdir="true">
<author email="atecon@posteo.de">Artur Tarassow</author>
<version>0.9</version>
<date>2020-03-04</date>
<description>Simple forecasting methods</description>
<tags>C53</tags>
<label>naive forecast(s)</label>
<menu-attachment>MAINWIN/Model/TSModels</menu-attachment>
<help>
pdfdoc:naiveFC.pdf
</help>
<depends count="3">
CvDataSplitter string_utils extra </depends>
<gretl-function name="naiveFC" type="bundle">
 <params count="3">
  <param name="y" type="series" const="true"/>
  <param name="which" type="string">
<description>Select forecasting method</description>
  </param>
  <param name="opts" type="bundle" optional="true">
<description>Bundle incl. optional parameters</description>
  </param>
 </params>
<code>/* Main package function */
if !exists(opts)
  bundle opts = null
endif
bundle self = set_bundle(y, which, opts)
do_initial_checks(&amp;self)	# TODO: return scalar capturing error!
if self.error
  return self
endif
# Replace of missing at the sample end
# must be done here before 't1_and_t2_of_y_and_xlist'
self.n_sampleend_obs_replaced = repl_sampleend_missings_of_y(&amp;y, self.verbose)
t1_and_t2_of_y_and_xlist(y, &amp;self)
if self.type_moving_window == &quot;static&quot;
  # &quot;self.t2_date_y&quot; refers to in-sample end date of &quot;y&quot;
  scalar self.window_length = smplspan(self.t1_date_y, self.t2_date_y, $pd)
endif
scalar check = valid_dates_of_y_and_xlist(&amp;self)
if check
  printError(&quot;Problem with dating for y and/ or xlist.&quot;)
  return self
endif
scalar check = sufficient_future_obs(&amp;self)
if check
  return self
endif
smpl obsnum(self.t1_date_y) get_sample_end(self)		# get_sample_end(self) = in-sample end plus max(horizon)
series self.y = y
do_naive_forecasting(&amp;self)
if self.which == &quot;avgfc&quot;
  self.forecast_results.avgfc = compute_avgerage_forecast(&amp;self)
endif
summarize_naive_fc_results(&amp;self)
cleanup_bundle(&amp;self)
return self
</code>
</gretl-function>
<gretl-function name="plot_naive_forecasts" type="void">
 <params count="3">
  <param name="self" type="bundle" const="true">
<description>Bundle returned from naiveFC()</description>
  </param>
  <param name="horizons" type="matrix" optional="true" const="true">
<description>Select only specific horizons</description>
  </param>
  <param name="model" type="string" optional="true" const="true">
<description>Select a model in case of avgfc</description>
  </param>
 </params>
<code>/* Function for plotting realizations and interval forecasts. */
if self.which == &quot;avgfc&quot; &amp;&amp; !exists(model)
  funcerr &quot;You must specify for which model to plot the forecasts.&quot;
endif
series y = self.y
setinfo y --graph-name=&quot;Actuals&quot;
# re-set missing values back to NA
series y = (y == replace_nan_value_by() &amp;&amp; self.type_moving_window == &quot;static&quot;) ? NA : y
if !exists(horizons)
  matrix horizons = seq(1, self.horizon)
endif
list plotlist = y get_naive_forecasts(self, horizons)
list plotlist = get_specific_model_for_avgfc(self, plotlist, model)
# incl. some pre-forecast periods obs. for plotting
scalar start = xmax(obsnum(self.t1_forecast_date) - self.pre_fc_periods_to_plot, 1)
smpl start obsnum(self.t2_forecast_date)
call_plot(plotlist, self)
</code>
</gretl-function>
<gretl-function name="get_naive_forecasts" type="list">
 <params count="3">
  <param name="self" type="bundle" const="true"/>
  <param name="horizons" type="matrix" optional="true">
<description>Select specific horizons (moving-window only)</description>
  </param>
  <param name="suffix" type="string" optional="true" const="true">
<description>Suffix for series' names</description>
  </param>
 </params>
<code>/* Transform interval forecasts into a list of series and return this. */
list R = null
series y = self.y
if !exists(suffix)
  string suffix = &quot;&quot;
endif
if !exists(horizons)
  matrix horizons = seq(1, self.horizon)
endif
matrix horizons = vec(horizons)
scalar err = horizons_isok(self, horizons)
if !err
  return R
endif
smpl obsnum(self.t1_forecast_date) obsnum(self.t2_forecast_date)	# don't drop
return list_of_forecasts(self, horizons, suffix)
</code>
</gretl-function>
<gretl-function name="GUI_naiveFC" type="matrix" menu-only="1" pkg-role="gui-main">
 <params count="5">
  <param name="y" type="series" const="true">
<description>Dependent variable</description>
  </param>
  <param name="xlist" type="list" optional="true" const="true">
<description>Additional exogenous (future values must be known)</description>
  </param>
  <param name="which" type="int" min="1" max="11" default="1">
<description>Model type</description>
<labels count="11">
"meanFC" "medianFC" "rwFC" "rwdriftFC" "ar1FC" "ar1trendFC" "smeanFC" "smedianFC" "snaiveFC" "snaivedriftFC" "avgFC" </labels>
  </param>
  <param name="h" type="int" min="1" default="10">
<description>Forecast horizon</description>
  </param>
  <param name="Plot" type="bool" default="1">
<description>Plot forecast</description>
  </param>
 </params>
<code>/* Helper function for GUI access. */
# map integer value to string
strings methods = get_supported_nonseas_methods()
bundle opts = null
bundle self = null
opts.h = h
opts.xlist = xlist
self = naiveFC(y, methods[which], opts)
# output
printf &quot;%12.4f\n&quot;, self.fc
if Plot
  naivePlot(&amp;self)
endif
return self.fc
</code>
</gretl-function>
<gretl-function name="stack_moving_window_forecasts" type="matrix">
 <params count="1">
  <param name="FC" type="list" const="true">
<description>List of forecast; each series refers to specific horizon</description>
  </param>
 </params>
<code>/* list FC includes fc_h1 fc_h2, fc_hN were N refers to the maximum forecast
horizon. Stack h-period forecasts into a single vector.
return: vector of stacked results. */
matrix stacked_fc = {}
if nelem(FC) == 0
  printf &quot;\nError: List of forecast≈õ is empty.\n&quot;
  return stacked_fc
endif
scalar max_horizon = nelem(FC)
smpl FC --no-all-missing
# Date index refers to the 'date being forecasted' T+h
# This means that the 'date of information' is h-period back in time,
# and thus [= (T+h) - h]
matrix date_of_informations = stack_info_dates($obsdate, max_horizon)
matrix stacked_forecasts = stack_multiperiod_forecasts(FC)
if rows(date_of_informations) != rows(stacked_forecasts)
  funcerr(sprintf(&quot;Dimensions do not fit:\n           rows(date_of_informations) = %d\n           rows(stacked_forecasts) = %d&quot;, rows(date_of_informations), rows(stacked_forecasts)))
endif
return concat_mats_add_names_and_sort(date_of_informations, stacked_forecasts)
</code>
</gretl-function>
<gretl-function name="concat_mats_add_names_and_sort" type="matrix" private="1">
 <params count="2">
  <param name="date_of_informations" type="matrix" const="true"/>
  <param name="stacked_forecasts" type="matrix" const="true"/>
 </params>
<code>matrix ret = msortby(date_of_informations ~ stacked_forecasts, 1)
cnameset(ret, &quot;info_date forecast_date horizon forecast_results&quot;)
return ret
</code>
</gretl-function>
<gretl-function name="stack_multiperiod_forecasts" type="matrix" private="1">
 <params count="1">
  <param name="FC" type="list" const="true"/>
 </params>
<code>/* Now stack series of forecasts. Each series refers to some
specific multi-period forecast horizon. 1st series--&gt;h=1, last series--&gt;h=max_hor. */
matrix mat = {}
series obsdate = $obsdate
loop i=1..nelem(FC) -q
  series foo = NA
  series foo = FC[i]
  smpl obsdate foo --no-missing
  mat |=  {isodate(epochday(obsdate))} ~ $i ~ {foo}	# date_forecasted ~ horizon ~ forecast_value
endloop
return mat
</code>
</gretl-function>
<gretl-function name="stack_info_dates" type="matrix" private="1">
 <params count="2">
  <param name="obsdate" type="series" const="true"/>
  <param name="max_horizon" type="int" min="1" const="true"/>
 </params>
<code>/* Vector of date_of_information from T to T+R-h
where T is the first date_of_information, R the number of
moving-window sequences and 'h' forecast horizon. Date is
returned in ISO8601 format.
return: Column vector of dates. */
matrix mat = {}
loop i=1..max_horizon -q
  mat |= { isodate(epochday($obsdate) -1) }
  catch smpl ; -1
endloop
return mat
</code>
</gretl-function>
<gretl-function name="yaxis_ranges" type="void" private="1">
 <params count="3">
  <param name="plotlist" type="list" const="true"/>
  <param name="ylo" type="scalarref"/>
  <param name="yup" type="scalarref"/>
 </params>
<code>/* */
scalar mini = min(min(plotlist))
scalar maxi = max(max(plotlist))
scalar ylo = mini - 0.05 * abs(mini)
scalar yup = maxi + 0.05 * abs(maxi)
</code>
</gretl-function>
<gretl-function name="list_of_forecasts" type="list" private="1">
 <params count="3">
  <param name="self" type="bundle" const="true"/>
  <param name="horizons" type="matrix" const="true"/>
  <param name="suffix" type="string" const="true"/>
 </params>
<code>/* Wrapper actually calling specific functions. */
list R = null
strings models = getkeys(self.forecast_results)
loop i=1..nelem(models) -q
  if self.type_moving_window == &quot;static&quot;
    list R += get_static_forecast_list(self, models[i], suffix)
  else
    list R += get_movwindow_forecast_list(horizons, self, models[i], suffix)
  endif
endloop
return R
</code>
</gretl-function>
<gretl-function name="get_movwindow_forecast_list" type="list" private="1">
 <params count="4">
  <param name="horizons" type="matrix" const="true"/>
  <param name="self" type="bundle" const="true"/>
  <param name="model" type="string" const="true"/>
  <param name="suffix" type="string" const="true"/>
 </params>
<code>/* Return sascade of h-step forecast_results. For 'rolling'
and 'recursive' cases. */
list R = null
loop i=1..rows(horizons) -q
  scalar shift_periods = $i - 1
  R += genseries(sprintf(&quot;low_h%d_%s%s&quot;, horizons[i], model, suffix), mlag(self.forecast_results[model].forecasts_lower_bound[i,]', shift_periods, NA) )
  R += genseries(sprintf(&quot;point_h%d_%s%s&quot;, horizons[i], model, suffix), mlag(self.forecast_results[model].forecasts_point[i,]', shift_periods, NA) )
  R += genseries(sprintf(&quot;up_h%d_%s%s&quot;, horizons[i], model, suffix), mlag(self.forecast_results[model].forecasts_upper_bound[i,]', shift_periods, NA) )
endloop
return R
</code>
</gretl-function>
<gretl-function name="get_static_forecast_list" type="list" private="1">
 <params count="3">
  <param name="self" type="bundle" const="true"/>
  <param name="model" type="string" const="true"/>
  <param name="suffix" type="string" const="true"/>
 </params>
<code>/* Return single multi-step forecast_results for 'static'
case. */
list R = null
R += genseries(sprintf(&quot;low_h1to%d_%s%s&quot;, self.horizon, model, suffix), self.forecast_results[model].forecasts_lower_bound)
R += genseries(sprintf(&quot;point_h1to%d_%s%s&quot;, self.horizon, model, suffix), self.forecast_results[model].forecasts_point)
R += genseries(sprintf(&quot;up_h1to%d_%s%s&quot;, self.horizon, model, suffix), self.forecast_results[model].forecasts_upper_bound)
return R
</code>
</gretl-function>
<gretl-function name="horizons_isok" type="scalar" private="1">
 <params count="2">
  <param name="self" type="bundle" const="true"/>
  <param name="horizons" type="matrix" const="true"/>
 </params>
<code>/* Check the vector 'horizons' is ok. Relevant for
get_naive_forecasts().
: return: 1 if ok, 0 otherwise */
if self.type_moving_window != &quot;static&quot;
  if minc(horizons) &lt;= 0
    printError(&quot;You cannot select a negative forecast horizon.&quot;)
    return 0
  endif
  if maxc(horizons) &gt; self.horizon
    printError(sprintf(&quot;The maximum forecast horizon you \n               selected (=%d) does exceed the horizon set before (=%d).&quot;, maxc(horizons), self.horizon))
    return 0
  endif
endif
return 1
</code>
</gretl-function>
<gretl-function name="sufficient_future_obs" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* */
scalar tdiff = $tmax + self.n_sampleend_obs_replaced - self.t2_obsnum_y
if tdiff &lt; self.horizon
  printError(sprintf(&quot;Requested maximum forecast horizon exceeds\n           the number of available future periods. Either add observations\n           or decrease the maximum forecast horizon to %d&quot;, self.horizon - (self.horizon - tdiff)))
  self.error = 1
  return 1
endif
return 0
</code>
</gretl-function>
<gretl-function name="get_sample_end" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>scalar sample_end = obsnum(self.t2_date_y)
if self.type_moving_window == &quot;static&quot;
  scalar sample_end += self.horizon
endif
return sample_end
</code>
</gretl-function>
<gretl-function name="replace_nan_value_by" type="scalar" private="1">
<code>/* Set value for replacing future unknown values
of series to be forecasted by a specific value. */
return -9876543210
</code>
</gretl-function>
<gretl-function name="repl_sampleend_missings_of_y" type="scalar" private="1">
 <params count="2">
  <param name="y" type="seriesref"/>
  <param name="verbose" type="bool" const="true"/>
 </params>
<code>/* Replace missing values of y at the sample end. */
smpl y --no-missing
scalar n_sampleend_obs_replaced = $tmax - $t2
if n_sampleend_obs_replaced &gt; 0
  smpl (1 + $t2) $tmax
  series y = replace_nan_value_by()
  smpl full
endif
if verbose
  printInfo(sprintf(&quot;Replaced %d missing values at the sample end of 'y'.&quot;, n_sampleend_obs_replaced))
endif
return n_sampleend_obs_replaced
</code>
</gretl-function>
<gretl-function name="valid_dates_of_y_and_xlist" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Check that sufficient future values of exogenous variables exist. */
if !nelem(self.xlist)
  return 0
endif
scalar tdiff_y_xlist = self.t2_obsnum_y - self.t2_obsnum_xlist
if tdiff_y_xlist &gt;= 0
  if tdiff_y_xlist &gt; 0
    printError(sprintf(&quot;Sample ends earlier for exogenous regressors ('%s')\n               than for the endogenous %s ('%s').&quot;, self.t2_date_xlist, self.name_endo, self.t2_date_y))
  else
    printError(sprintf(&quot;Sample ends for both the exogenous regressors\n               and for the endogenous %s at observation '%s'.&quot;, self.name_endo, self.t2_date_y))
  endif
  printError(&quot;List of exogenous has insufficient future values.&quot;)
  self.error = 1
  return 1
endif
if tdiff_y_xlist &lt; 0 &amp;&amp; (abs(tdiff_y_xlist) &lt;  self.horizon)
  printError(sprintf(&quot;You set the maximum forecast horizon to %d periods but\n           the sample of the exogenous regressors has only %d future\n           values left after period %s.\n           Either restrict the maximum forecast horizon to 'horizon = %d'\n           or add %d additional future values to the exogenous variables.&quot;, self.horizon, abs(tdiff_y_xlist), self.t2_date_xlist, abs(tdiff_y_xlist), self.horizon-abs(tdiff_y_xlist)))
  self.error = 1
  return 1
endif
return 0
</code>
</gretl-function>
<gretl-function name="estimate_model_and_forecast" type="scalar" private="1">
 <params count="6">
  <param name="est_command" type="string" const="true"/>
  <param name="fcast_command" type="string" const="true"/>
  <param name="y" type="series" const="true"/>
  <param name="xlist" type="list" const="true"/>
  <param name="train_obsnums" type="bundle" const="true"/>
  <param name="test_obsnums" type="bundle" const="true"/>
 </params>
<code>/* Estimate model and return oos-forecast. */
smpl train_obsnums.t1_obsnum train_obsnums.t2_obsnum
catch @est_command
if $error
  printError(&quot;Model estimation failed. Forecast values are set to            NA for the current sample.&quot;)
  return 1
endif
catch fcast test_obsnums.t1_test_obsnum test_obsnums.t2_test_obsnum @fcast_command
if $error
  printError(&quot;Failed executing forecast command.&quot;)
  return 1
endif
return 0
</code>
</gretl-function>
<gretl-function name="compute_avgerage_forecast" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Compute avgerage forecast combination across all models
estimated. This is done foreach horizon and each moving
window, respectively. We also compute averages of forecast
intervals. */
bundle avgfc = null
if !inbundle(self, &quot;forecast_results&quot;)
  printError(&quot;Bundle 'forecast_results' does not exist.&quot;)
  scalar self.error = 1
endif
if nelem(self.forecast_results) &lt; 2
  printError(&quot;Average forecast combination requires at least two forecasting models.&quot;)
  scalar self.error = 1
endif
strings keys = get_name_of_intval_matrices(self)
if !self.error
  bundle avgfc = initialize_avgfc_bundle(self)
  # Compute for lower ~ point ~ upper separate matrices
  # holding respective values across models
  loop i=1..nelem(keys) -q
    string key_name = keys[i]		# lower ~ point ~ upper
    # return array of n matrices holding interval_part for n models
    matrices @key_name = get_interval_forecast_matrices(keys[i], self)
  endloop
  loop i=1..nelem(keys) -q
    string key_name = keys[i]		# lower ~ point ~ upper
    avgfc[keys[i]] = avg_across_matrices(@key_name)
  endloop
endif
return avgfc
</code>
</gretl-function>
<gretl-function name="avg_across_matrices" type="matrix" private="1">
 <params count="1">
  <param name="mats" type="matrices" const="true"/>
 </params>
<code>/* */
scalar n_rows = rows(mats[1])	# equivalent to self.horizon
scalar n_cols = cols(mats[1])	# equivalent to self.n_folds
matrix averages = NA * zeros(n_rows, n_cols)
loop i=1..n_rows -q
  matrix drilled = drill(mats, i)		# rows=models; cols=moving_window
  averages[i,] = meanc(drilled)		# avg. for horizon 'h' across all moving_windows
endloop
return averages
</code>
</gretl-function>
<gretl-function name="get_interval_forecast_matrices" type="matrices" private="1">
 <params count="2">
  <param name="interval_part" type="string" const="true"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Retrieve from forecast_results for all models estimated
one of the matrices holding the interval forecast results: either
lower bound, point fc, or upper bound. */
matrices ret = array(nelem(self.models))
loop i=1..nelem(self.models) -q
  ret[i] = self.forecast_results[self.models[i]][&quot;@interval_part&quot;]
endloop
return ret
</code>
</gretl-function>
<gretl-function name="get_name_of_intval_matrices" type="strings" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Name of matrices holding interval forecasts. */
return getkeys(self.forecast_results[self.models[1]])
</code>
</gretl-function>
<gretl-function name="initialize_avgfc_bundle" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* */
strings keys = get_name_of_intval_matrices(self)
bundle avgfc = null
loop i=1..nelem(keys) -q
  string key_name = keys[i]		# lower ~ point ~ upper
  matrix avgfc[keys[i]] = NA * ones(self.horizon, self.n_folds)
endloop
return avgfc
</code>
</gretl-function>
<gretl-function name="attach_column_labels" type="void" private="1">
 <params count="2">
  <param name="interval_forecasts" type="bundleref"/>
  <param name="self" type="bundle"/>
 </params>
<code>/* Add date strings as column labels for indicating the date on
which the estimates are conditioned on. */
string date_first_trainset_end = obslabel(obsnum(self.t1_forecast_date) - 2)
strings date_strings = future_date_strings(date_first_trainset_end, self.n_folds)
strings keys = getkeys(interval_forecasts)
loop i=1..nelem(keys) -q
  cnameset(interval_forecasts[keys[i]], date_strings)
endloop
</code>
</gretl-function>
<gretl-function name="attach_row_labels" type="void" private="1">
 <params count="2">
  <param name="interval_forecasts" type="bundleref"/>
  <param name="self" type="bundle"/>
 </params>
<code>/* Add date strings as row labels for 'static' forecasts,
or indicate the forecast horizon for moving-window
forecasts. */
if self.type_moving_window == &quot;static&quot;
  strings row_labels = future_date_strings(self.t2_train_date, self.horizon)
else
  strings row_labels = array_of_horizon_labels(self.horizon)
endif
strings keys = getkeys(interval_forecasts)
loop i=1..nelem(keys) -q
  rnameset(interval_forecasts[keys[i]], row_labels)
endloop
</code>
</gretl-function>
<gretl-function name="array_of_horizon_labels" type="strings" private="1">
 <params count="1">
  <param name="horizon" type="int" min="1" const="true"/>
 </params>
<code>/* Construct string array for indicating the forecast horizons. */
strings r = array(horizon)
loop i=1..horizon -q
  r[i] = sprintf(&quot;h=%d&quot;, i)
endloop
return r
</code>
</gretl-function>
<gretl-function name="future_date_strings" type="strings" private="1">
 <params count="2">
  <param name="date_of_information_str" type="string" const="true">
<description>Obs. before 1st h=1 forecast</description>
  </param>
  <param name="n_future_periods" type="int" min="1" const="true"/>
 </params>
<code>/* Construct date strings refering to the date for which a the
h-step ahead forecast was made for.*/
strings future_dates = array(n_future_periods)
scalar date_of_information_num = obsnum(date_of_information_str)
loop i=1..n_future_periods -q
  future_dates[i] = obslabel(date_of_information_num + $i)
endloop
return future_dates
</code>
</gretl-function>
<gretl-function name="point_fc_and_factor_as_arrays" type="bundle" private="1">
 <params count="2">
  <param name="collected_point_fc_and_sderr" type="matrices" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Using each model's point forecast and standard error, compute
the forecast interval assuming standard normal. */
bundle bout
scalar m = nelem(collected_point_fc_and_sderr)
matrices point_forecasts = array(m)
matrices factors = array(m)
loop i=1..m -q
  point_forecasts[i] = collected_point_fc_and_sderr[i][,1]
  factors[i] = fc_interval_width(collected_point_fc_and_sderr[i][,1], self.level)
endloop
bout.point_forecasts = point_forecasts
bout.factors = factors
return bout
</code>
</gretl-function>
<gretl-function name="x_train_test_mats_static_case" type="void" private="1">
 <params count="2">
  <param name="cv" type="bundleref"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* For the static case we only need the first fold returned by
CvDataSplitter(). */
if self.type_moving_window == &quot;static&quot;
  matrices cv.X_train = defarray(cv.X_train[1])
  matrices cv.X_test = defarray(cv.X_test[1])
  cv.n_folds = nelem(cv.X_test)
endif
</code>
</gretl-function>
<gretl-function name="prep_and_get_cv_folds" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Prepare bundle for CvDataSplitter() and compute folds. */
bundle cv					# Tried to put this into a bundle, but git issues with index series
# y includes the additional n=horizon newly added observations for
# the very last cv-dataset
series y = self.y
list xlist = self.xlist
string cv.cv_type = (self.type_moving_window==&quot;rolling&quot;) ? &quot;rolwin&quot; : &quot;recwin&quot;
scalar cv.win_size = self.window_length
list cv.X = y xlist
CvDataSplitter(&amp;cv)
x_train_test_mats_static_case(&amp;cv, self)
return cv
</code>
</gretl-function>
<gretl-function name="valid_window_length" type="scalar" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Returns zero of window_length is valid. */
if smplspan(self.t1_date_y, self.t2_date_y, $pd) &lt; self.window_length
  printError(sprintf(&quot;The window size you selected (wsize=%d) exceeds the\n           number of valid observations in '%s'.&quot;, self.window_length, self.name_endo))
  return 1
endif
return 0
</code>
</gretl-function>
<gretl-function name="get_estimator_names" type="strings" private="1">
 <params count="1">
  <param name="is_seas" type="bool" const="true">
<description>0=data has no seasonality, 1=it has</description>
  </param>
 </params>
<code>/* Obtain names of methods going to apply. */
strings methods = strdrop(get_supported_nonseas_methods(), &quot;avgfc&quot;)
if is_seas
  methods += get_supported_seas_methods()
endif
return methods
</code>
</gretl-function>
<gretl-function name="obslabels_and_nobs_to_bundle" type="void" private="1">
 <params count="2">
  <param name="y" type="list" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>smpl y --contiguous
string self.t1_date = obslabel($t1)
string self.t2_date = obslabel($t2)
scalar self.T = $nobs
</code>
</gretl-function>
<gretl-function name="printInfo" type="void" private="1">
 <params count="1">
  <param name="s" type="string" const="true"/>
 </params>
<code>printf &quot;\nInfo: %s\n&quot;, s
</code>
</gretl-function>
<gretl-function name="printWarning" type="void" private="1">
 <params count="1">
  <param name="s" type="string" const="true"/>
 </params>
<code>printf &quot;\nWarning: %s\n&quot;, s
</code>
</gretl-function>
<gretl-function name="printError" type="void" private="1">
 <params count="1">
  <param name="s" type="string" const="true"/>
 </params>
<code>printf &quot;\nError: %s\n&quot;, s
</code>
</gretl-function>
<gretl-function name="set_bundle" type="bundle" private="1">
 <params count="3">
  <param name="y" type="series" const="true"/>
  <param name="which" type="string"/>
  <param name="opts" type="bundle" optional="true"/>
 </params>
<code>/* Compile self bundle by merging eventual information
from opts-bundle. */
if !exists(opts)
  bundle opts = null
endif
bundle self = default_values(y)
self = opts + self			# override defaults
self.which = tolower(which)
if self.which != &quot;avgfc&quot;
  strings self.models = defarray(self.which)
else
  strings self.models = self.supported_estimators
endif
self.forecast_results = prepare_forecast_bundles(&amp;self)
self.type_moving_window = tolower(self.type_moving_window)
self.name_endo = argname(y)
return self
</code>
</gretl-function>
<gretl-function name="get_supported_seas_methods" type="strings" private="1">
<code>/* List all seasonal supported methods here. */
return defarray(&quot;smeanfc&quot;, &quot;smedianfc&quot;, &quot;snaivefc&quot;, &quot;snaivedriftfc&quot;)
</code>
</gretl-function>
<gretl-function name="get_supported_nonseas_methods" type="strings" private="1">
<code>/* List all non-seasonal supported methods here. */
return defarray(&quot;meanfc&quot;, &quot;medianfc&quot;, &quot;rwfc&quot;, &quot;rwdriftfc&quot;, &quot;ar1fc&quot;, &quot;ar1trendfc&quot;, &quot;avgfc&quot;)
</code>
</gretl-function>
<gretl-function name="data_has_seasonality" type="scalar" private="1">
<code>/* Flag seasonality of data set */
return ($pd &gt; 1) ? 1 : 0
</code>
</gretl-function>
<gretl-function name="fc_interval_width" type="matrix" private="1">
 <params count="2">
  <param name="fc_sd" type="matrix" const="true">
<description>Std. error of forecast</description>
  </param>
  <param name="level" type="scalar" min="0.001" max="0.999" const="true">
<description>confidence level</description>
  </param>
 </params>
<code>/* Compute width for a given condifdence level assuming standard normal. */
return fc_sd * critical(z, (1 - level) / 2 )
</code>
</gretl-function>
<gretl-function name="gen_column_names" type="strings" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Construct column names */
strings s = defarray(self.which)
if self.which != &quot;avgfc&quot;
  s += sprintf(&quot;Lo (%.1f)&quot;, (1-self.level) / 2 * 100 )
  s += sprintf(&quot;Up (%.1f)&quot;, ( 1-(1-self.level)/2 ) * 100 )
endif
return s
</code>
</gretl-function>
<gretl-function name="print_no_bootstrap_support" type="void" private="1">
<code>printError(&quot;Bootstrap confidence intervals are not supported, yet&quot;)
</code>
</gretl-function>
<gretl-function name="get_test_start_end_obsnums" type="bundle" private="1">
 <params count="2">
  <param name="train_obsnums" type="bundle" const="true"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Compute start and end date of test sample based. */
bundle ret = null
scalar ret.t1_test_obsnum = 1 + train_obsnums.t2_obsnum
scalar ret.t2_test_obsnum = ret.t1_test_obsnum + self.horizon_current - 1
return ret
</code>
</gretl-function>
<gretl-function name="get_train_start_end_obsnums" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Return obs. numbers for trainings set. */
bundle ret = null
if self.type_moving_window == &quot;static&quot;
  # these are simply in-sample dates
  ret.t1_obsnum = obsnum(self.t1_date_y)
  ret.t2_obsnum = obsnum(self.t2_date_y)
else
  scalar ret.t2_obsnum = $t2 - self.horizon_current
  scalar ret.t1_obsnum = 1 + ret.t2_obsnum - self.window_length
endif
return ret
</code>
</gretl-function>
<gretl-function name="get_highest_period_series" type="series" private="1">
<code>/* Return series holding highest available frequency. */
catch series period = $obsmicro
if $error
  catch series period = $obsminor
  if $error
    series period = $obsmajor
  endif
endif
return period
</code>
</gretl-function>
<gretl-function name="add_intercept_to_list" type="list" private="1">
<code>/* Add intercept to list. */
list xlist = const
return xlist
</code>
</gretl-function>
<gretl-function name="add_ohe_periods_to_list" type="list" private="1">
<code>/* Add list of dummyfied frequency components to list. */
series period = get_highest_period_series()
list xlist = dummify(period)
return xlist
</code>
</gretl-function>
<gretl-function name="add_linear_trend_to_list" type="list" private="1">
<code>/* Add linear trend to list. */
genr time
list xlist = time
return xlist
</code>
</gretl-function>
<gretl-function name="dict_models" type="bundle" private="1">
<code>/* Dictionary including stuff for calling estimation
command and fcast command. */
bundle dict_models
dict_models.meanfc = defbundle( &quot;forecast_arg&quot;, &quot;--static&quot;, &quot;command&quot;, &quot;ols y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.medianfc = defbundle( &quot;forecast_arg&quot;, &quot;--static&quot;, &quot;command&quot;, &quot;quantreg 0.5 y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.smeanfc = defbundle( &quot;forecast_arg&quot;, &quot;--static&quot;, &quot;command&quot;, &quot;ols y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 1 )
dict_models.smedianfc = defbundle( &quot;forecast_arg&quot;, &quot;--static&quot;, &quot;command&quot;, &quot;quantreg 0.5 y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 1 )
dict_models.snaivefc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;arima 0 0 0 ; 0 1 0 ; y xlist --nc&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.snaivedriftfc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;arima 0 0 0 ; 0 1 0 ; y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.rwfc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;arima 0 1 0 ; y xlist --nc&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 0, &quot;add_ohe_periods&quot;, 0 )
dict_models.rwdriftfc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;arima 0 1 0 ; y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 0, &quot;add_intercept&quot;, 0, &quot;add_ohe_periods&quot;, 0 )
dict_models.ar1fc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;ols y xlist&quot;, &quot;add_linear_trend&quot;, 0, &quot;add_first_lag&quot;, 1, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
dict_models.ar1trendfc = defbundle( &quot;forecast_arg&quot;, &quot;--dynamic&quot;, &quot;command&quot;, &quot;ols y xlist&quot;, &quot;add_linear_trend&quot;, 1, &quot;add_first_lag&quot;, 1, &quot;add_intercept&quot;, 1, &quot;add_ohe_periods&quot;, 0 )
return dict_models
</code>
</gretl-function>
<gretl-function name="default_values" type="bundle" private="1">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Set default values */
bundle self = null
scalar self.error = 0
list self.xlist = null
scalar self.horizon = 10				# maximum forecast horizon
scalar self.level = 0.9					# probability level for forecast interval
scalar self.fan = 0						# plot fan chart  (not supported yet)
scalar self.nboot = 0					# no. of bootstrap replications  (not supported yet)
scalar self.blength = 4					# Block length bootstrap  (not supported yet)
scalar self.is_seas = data_has_seasonality()
strings self.supported_estimators = get_estimator_names(self.is_seas)
scalar self.verbose = 1
genr index
series self.index = index
string self.type_moving_window = &quot;static&quot; 			# &quot;static&quot;, &quot;rolling&quot; or &quot;recursive&quot;
scalar self.window_length = ceil(0.25 * nobs(y))	# default window length for moving-windows
# For naivePlot()
string self.title = &quot;&quot;
string self.ylab = &quot;&quot;
string self.xlab = &quot;&quot;
string self.filename = &quot;display&quot;
scalar self.pre_fc_periods_to_plot = int(0.25 * nobs(y))
return self
</code>
</gretl-function>
<gretl-function name="prepare_xlist" type="list" private="1">
 <params count="2">
  <param name="model_settings" type="bundle" const="true"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* Prepare list of additional regressors. */
list xlist = null
if model_settings.add_ohe_periods
  xlist += add_ohe_periods_to_list()
endif
if model_settings.add_intercept
  xlist += add_intercept_to_list()
endif
if model_settings.add_linear_trend
  xlist += add_linear_trend_to_list()
endif
if inbundle(self, &quot;xlist&quot;)
  xlist += self.xlist
endif
# TODO: check for duplicates in xlist
return xlist
</code>
</gretl-function>
<gretl-function name="set_xlist_and_forecast" type="matrix" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Set list of regressors, estimate model and compute
point forecast and forecast standard errors. */
bundle model_settings = dict_models()[self.active_model]
string fcast_arg = model_settings.forecast_arg
string command = model_settings.command
# TODO: consider 3 verbose levels: silent, normal, detailed
if self.verbose &lt; 2
  command += &quot; --quiet&quot;	# estimation details only for detailed verbosity level
  fcast_arg += &quot; --quiet&quot;
endif
matrix forecast_results = zeros(self.horizon, 2) * NA
series y = self.y					# length: window_length + horizon
# &quot;(train_obsnums.t2_obsnum - train_obsnums.t1_obsnum)&quot;
# is not the effective sample length but (window_length-max(lags))
bundle train_obsnums = get_train_start_end_obsnums(self)
bundle test_obsnums = get_test_start_end_obsnums(train_obsnums, self)
list xlist = prepare_xlist(model_settings, self)
if model_settings.add_first_lag
  xlist += y(-1)
endif
catch smpl train_obsnums.t1_obsnum train_obsnums.t2_obsnum
if $error
  printError(&quot;Failed to set training sample. Check your sample and window size.&quot;)
  scalar self.error = 1
  return forecast_results
endif
# TODO: Can this happen, and if so why -- otherwise drop
if self.type_moving_window != &quot;static&quot; &amp;&amp; ($nobs &gt; self.window_length)
  printError(sprintf(&quot;You training sample (T=%d) is longer than the\n           specified window length (T=%d).&quot;, $nobs, self.window_length))
  scalar self.error = 1
  return forecast_results
endif
self.error = estimate_model_and_forecast(command, fcast_arg, y, xlist, train_obsnums, test_obsnums)
if self.error == 0
  forecast_results[1:self.horizon_current,] = $fcast ~ $fcse
endif
return forecast_results
</code>
</gretl-function>
<gretl-function name="do_initial_checks" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Helper function perfoming some initial checks */
pkg query extra --quiet
# FIXME: This fails
/*
if atof($result.version) &lt; 0.6
  printError(&quot;You need at least version 0.6 of the 'extra' package.&quot;)
  printError(&quot;Update by executing 'pkg install extra'&quot;)
endif
*/
strings methods = get_supported_nonseas_methods()
strings seas_methods = get_supported_seas_methods()
# Check whether called method exists
if !nelem(strpos(methods, self.which)) &amp;&amp; !nelem(strpos(seas_methods, self.which))
  printError(&quot;The forecasting method you selected does not exist.&quot;)
  self.error = 1
endif
if !self.is_seas &amp;&amp; nelem(strpos(seas_methods, self.which))
  printError(&quot;The method you requested is not available for non-seasonal data.&quot;)
  self.error = 1
endif
if self.window_length &lt; $pd
  printError(&quot;Periodicity cannot be negative.&quot;)
  printError(sprintf(&quot;Window size = %d&quot;, self.window_length))
  printError(sprintf(&quot;Periodicity = %d\n&quot;, $pd))
  printError(&quot;The size of the moving window cannot be smaller than the underlying periodicity.&quot;)
  self.error = 1
endif
if self.nboot
  print_no_bootstrap_support()
  self.error = 1
endif
if nelem(self.xlist) &gt; 0 &amp;&amp; (self.which == &quot;rwfc&quot; || self.which == &quot;rwdriftfc&quot; || self.which == &quot;snaivefc&quot; || self.which == &quot;snaivedriftfc&quot;)
  printError(sprintf(&quot;No exogenous variables can be included for the selected model '%s'.&quot;, self.which))
  self.error = 1
endif
</code>
</gretl-function>
<gretl-function name="t1_and_t2_of_y_and_xlist" type="void" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Check valid start and end dates of y and xlist. */
list xlist = self.xlist
scalar t1_curr = $t1
scalar t2_curr = $tmax
bundle obsdetails_y
bundle obsdetails_x
obslabels_and_nobs_to_bundle(y, &amp;obsdetails_y)
string self.t1_date_y = obsdetails_y.t1_date
string self.t2_date_y = obslabel(obsnum(obsdetails_y.t2_date) - self.n_sampleend_obs_replaced)
scalar self.t1_obsnum_y = obsnum(self.t1_date_y)
scalar self.t2_obsnum_y = obsnum(self.t2_date_y)
scalar t1_diff_y = self.t1_obsnum_y - t1_curr
scalar t2_diff_y = t2_curr - self.t2_obsnum_y
if t1_diff_y &gt; 0
  printWarning(sprintf(&quot;Found %d missing initial observations for %s.&quot;, t1_diff_y, self.name_endo))
endif
if nelem(xlist)
  obslabels_and_nobs_to_bundle(xlist, &amp;obsdetails_x)
  scalar self.t1_obsnum_xlist = obsnum(obsdetails_x.t1_date)
  scalar self.t2_obsnum_xlist = obsnum(obsdetails_x.t2_date)
  string self.t1_date_xlist = obsdetails_x.t1_date
  string self.t2_date_xlist = obsdetails_x.t2_date
  scalar t1_diff_x = self.t1_obsnum_xlist - t1_curr
  scalar t2_diff_x = t2_curr - self.t2_obsnum_xlist
  if t1_diff_x &gt; 0
    printWarning(sprintf(&quot;Found %d missing initial observations for exogenous.&quot;, t1_diff_x))
  endif
  if t2_diff_x &gt; 0
    printWarning(sprintf(&quot;Found %d missing observations at sample end for exogenous.&quot;, t2_diff_x))
  endif
endif
</code>
</gretl-function>
<gretl-function name="cleanup_bundle" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Delete some elements before returning to user. */
delete self.fan
delete self.blength
delete self.nboot
if inbundle(self,&quot;obs_season&quot;)
  delete self.obs_season
endif
delete self.supported_estimators
delete self.index
delete self.active_model
delete self.horizon_current
delete self.t1_date_y
delete self.t2_date_y
delete self.xlist
</code>
</gretl-function>
<gretl-function name="prepare_forecast_bundles" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Prepare for each estimator a dictionary for point
interval forecast results to be stored in matrices. */
bundle forecast_results
loop i=1..nelem(self.models) -q
  string model = self.models[i]
  bundle forecast_results[&quot;@model&quot;] = null
endloop
return forecast_results
</code>
</gretl-function>
<gretl-function name="do_naive_forecasting" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Wrapper function actually calling procedures. */
strings models = getkeys(self.forecast_results)
loop i=1..nelem(self.forecast_results) -q	# loop over models
  self.active_model = models[i]
  bundle interval_forecasts = execute_forecasting(&amp;self)
  attach_row_labels(&amp;interval_forecasts, self)
  attach_column_labels(&amp;interval_forecasts, self)
  self.forecast_results[self.active_model] = interval_forecasts
endloop
</code>
</gretl-function>
<gretl-function name="summarize_naive_fc_results" type="void" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* Print summarising information */
if self.verbose
  printf &quot;-------------------------------------------------------------------\n&quot;
  printf &quot;\t\tSummary of naive forecasting\n&quot;
  printf &quot;\nForecasting method: \t\t\t%s\n&quot;, self.which
  printf &quot;Endogenous: \t\t\t\t%s\n&quot;, self.name_endo
  printf &quot;Number of additional regressors: \t%d\n&quot;, nelem(self.xlist)
  printf &quot;In-Sample: \t\t\t\t%s to %s (T = %d)\n&quot;, self.t1_date_y, self.t2_date_y, nobs(self.y) - self.horizon
  printf &quot;Max. forecast horizon: \t\t\t%d\n&quot;, self.horizon
  if self.type_moving_window == &quot;static&quot;
    printf &quot;Last in-sample observation: \t\t%s\n&quot;, self.t2_train_date
  elif self.type_moving_window == &quot;rolling&quot;
    printf &quot;Moving window length: \t\t\t%d\n&quot;, self.window_length
  else
    printf &quot;Initial window length: \t\t\t%d\n&quot;, self.window_length
  endif
  if self.type_moving_window != &quot;static&quot;
    printf &quot;Number of '%s' multi-step forecasts: %d\n&quot;, self.type_moving_window, self.n_folds
    printf &quot;First observation forecasted: \t\t%s\n&quot;, self.t1_forecast_date
    printf &quot;Last observation forecasted: \t\t%s\n&quot;, self.t2_forecast_date
  else
    printf &quot;First observation forecasted (h=1): \t%s\n&quot;, self.t1_forecast_date
    printf &quot;Last observation forecasted (h=%d): \t%s\n&quot;, self.horizon, self.t2_forecast_date
  endif
  if self.type_moving_window == &quot;static&quot;
    printf &quot;Width forecast interval: \t\t%d pct.\n&quot;, self.level * 100
  else
  endif
  printf &quot;-------------------------------------------------------------------\n\n&quot;
endif
</code>
</gretl-function>
<gretl-function name="execute_forecasting" type="bundle" private="1">
 <params count="1">
  <param name="self" type="bundleref"/>
 </params>
<code>/* This function estimates the point forecasts either in (i) a rolling or
(ii) a recursive manner and stores sequences of interval forecasts. */
bundle cv = prep_and_get_cv_folds(self)
self.n_folds = cv.n_folds
# Loop over training sets, run estimation and retrieve interval forecasts.
# returns an n_folds-dimensional array comprising h by 2 (point~sderr) matrices.
matrices collected_point_fc_and_sderr = set_model_estimate_and_forecast(&amp;cv, &amp;self)
bundle forecasts_and_factors = point_fc_and_factor_as_arrays(collected_point_fc_and_sderr, &amp;self)
# Retrieve moving-window point_forecasts from array,
# compute forecast intervals and put stuff to bundle
return compute_intval_forecasts(forecasts_and_factors)
</code>
</gretl-function>
<gretl-function name="compute_intval_forecasts" type="bundle" private="1">
 <params count="1">
  <param name="forecasts_and_factors" type="bundle" const="true"/>
 </params>
<code>/* Generate for each model based on respective point forecasts and
estimated standard derrors, arrays holding interval forecasts. */
bundle interval_forecasts
matrix interval_forecasts.forecasts_point = flatten(forecasts_and_factors.point_forecasts) # rows: horizons, cols: sample period
matrix factors_flattened = flatten(forecasts_and_factors.factors)
matrix interval_forecasts.forecasts_lower_bound = interval_forecasts.forecasts_point .- factors_flattened
matrix interval_forecasts.forecasts_upper_bound = interval_forecasts.forecasts_point .+ factors_flattened
return interval_forecasts
</code>
</gretl-function>
<gretl-function name="set_model_estimate_and_forecast" type="matrices" private="1">
 <params count="2">
  <param name="cv" type="bundleref"/>
  <param name="self" type="bundleref"/>
 </params>
<code>/* Loop over training sets, run estimation and retrieve
interval forecasts. */
matrices collected_point_fc_and_sderr = array(cv.n_folds)
loop lwin=1..cv.n_folds -q
  matrix date_idx = cv.X_train[lwin]
  # time index of the training set = self.window_length + self.horizon
  # As the last rolling samples may inlude only a sample set less than self.horizon
  # observations, we still can compute forecasts for $Ttest &lt; self.horizon
  scalar obs_left = $tmax - maxc(date_idx[,1])
  scalar self.horizon_current = xmin(self.horizon, obs_left)
  if self.horizon_current == 0		# FIXME: Why is n_folds=81 but only n_folds=80 would work!
    break
  endif
  smpl minc(date_idx[,1]) (maxc(date_idx[,1]) + self.horizon_current)
  if lwin == 1
    # CV series holds &quot;window_length+horizon&quot; observations: subtract &quot;horizon&quot;
    self.t1_train_date = obslabel($t1)
    string self.t2_train_date = obslabel($t2 - self.horizon_current)
    string self.t1_forecast_date = obslabel($t2 - self.horizon_current + 1)	# Date of 1st h=1 ahead forecast
  elif lwin == (cv.n_folds - 1) &amp;&amp; self.type_moving_window != &quot;static&quot;
    self.t2_forecast_date = self.t2_date_y		# Date of last h-step ahead forecast
  endif
  collected_point_fc_and_sderr[lwin] = set_xlist_and_forecast(&amp;self)	# h by 2 matrix (point_fc ~ sderr)
endloop
if self.type_moving_window == &quot;static&quot;
  string self.t2_forecast_date = obslabel(obsnum(self.t2_train_date) + self.horizon)	# Date of last h-step ahead forecast
endif
return collected_point_fc_and_sderr
</code>
</gretl-function>
<gretl-function name="get_specific_model_for_avgfc" type="list" private="1">
 <params count="3">
  <param name="self" type="bundle" const="true"/>
  <param name="plotlist" type="list" const="true"/>
  <param name="model" type="string"/>
 </params>
<code>/* In case of &quot;avgfc&quot; we only plot the results for a specific model
but not for all in a single plot. */
if self.which == &quot;avgfc&quot;
  string model = tolower(model)
  list plotlist = get_model_forecasts_from_list(plotlist, model)
  if nelem(plotlist) == 0
    funcerr &quot;Model requested is not supported.&quot;
  endif
endif
return plotlist
</code>
</gretl-function>
<gretl-function name="get_model_forecasts_from_list" type="list" private="1">
 <params count="2">
  <param name="plotlist" type="list" const="true"/>
  <param name="model" type="string" const="true"/>
 </params>
<code>/* Retrieve from list only those series which include
model in its serie's name. */
list new = null
loop foreach i plotlist -q
  if instring(varname(plotlist.$i), sprintf(&quot;_%s&quot;, model))
    list new += $i
  endif
endloop
return new
</code>
</gretl-function>
<gretl-function name="call_plot" type="void" private="1">
 <params count="2">
  <param name="plotlist" type="list" const="true"/>
  <param name="self" type="bundle" const="true"/>
 </params>
<code>/* */
string filename = self.filename
scalar ylo
scalar yup
yaxis_ranges(plotlist, &amp;ylo, &amp;yup)
plot plotlist
  options with-lp time-series single-yaxis
  literal set linetype 1 lc rgb &quot;black&quot; lw 1 pt 0 ps 0
  literal set linetype 3 lc rgb &quot;red&quot; lw 1.5 ps 0
  literal set linetype 2 lc rgb &quot;grey&quot; lw 1.5 ps 0
  literal set linetype 4 lc rgb &quot;grey&quot; lw 1.5 ps 0
  literal set key left bottom below
  #literal set key inside left bottom
  #put the border more to the background by applying it
  # only on the left and bottom part and put it and the tics in gray
  literal set style line 11 lc rgb &quot;#808080&quot; lt 1
  literal set border 3 back ls 11			# get rid of upper + left border
  literal set tics nomirror
  #add a slight grid to make it easier to follow the exact position of the curves
  literal set style line 12 lc rgb &quot;#808080&quot; lt 0 lw 1	# light grey color
  literal set grid back ls 12
  printf &quot;set yrange[%g:%g]&quot;, ylo, yup
  printf &quot;set ylabel \&quot;%s\&quot;&quot;, self.ylab
  printf &quot;set xlabel \&quot;%s\&quot;&quot;, self.xlab
  printf &quot;set title \&quot;%s\&quot;&quot;, self.title
end plot --output=&quot;@filename&quot;
</code>
</gretl-function>
<sample-script>
clear
set verbose off
#set debug 0

#include naiveFC.gfn --force				# TODO:

string WD = &quot;/home/at/git/naiveFC/gretl&quot;
set workdir @WD

# TODO: can be dropped once gfn compiled
include string_utils.gfn			# already added to spec
include CvDataSplitter.gfn			# already added to spec
include extra.gfn					# already added to spec

include &quot;./src/naiveFC.inp&quot; --force
include &quot;./src/naiveFC_helper.inp&quot; --force


# Load data
#open AWM.gdt -q
#series y = YGA

open &quot;../tests/daily_data.gdt&quot; -q
series y = target

#=======================
# Static naive forecasts
#=======================
/*
   # Forecast combination
   # smpl ; -1					# FIXME: In case the dataset is restricted, internal addobs does not work!
   bundle b = null
   b = naiveFC(y, &quot;avgFC&quot;)				# compute forecasts
   print b
   matrix fc_method1_lb = b.forecasts_lower_bound[2]
   fc_method1_lb
   naivePlot(&amp;b)						# plot forecast results
   stop

   # Forecast combination but up to h=15 forecast periods
   bundle opt = null					# set specific options
   scalar opt.horizon = 10
   #list opt.xlist = D743 FDD			# list of additional regressors for conditioning on (must have at least 'h' future valid obs!)
   bundle b = naiveFC(y, &quot;avgFC&quot;, opt)
   matrix fc_avgfc_pt = b.forecasts_point[10]
   b.pre_fc_periods_to_plot = 15					# optional: set no. of pre.-forecast periods obs. to plot
   naivePlot(&amp;b)

   # Mean forecast
   bundle opt = null					# set specific options
   scalar opt.horizon = 10
   bundle b = naiveFC(y, &quot;meanFC&quot;, opt)
   print b
   eval b.forecasts_point[1]
   stop
   naivePlot(&amp;b)
   eval b.fc

   # Median forecast
   bundle b = naiveFC(y, &quot;medianFC&quot;, opt)
   eval b.forecasts_point[1]

   naivePlot(&amp;b)
   eval b.fc

   # Random-Walk
   bundle b = naiveFC(y, &quot;rwFC&quot;, opt)
   eval b.forecasts_point[1]
   naivePlot(&amp;b)
   eval b.fc

   # Random-Walk + Drift
   bundle b = naiveFC(y, &quot;rwdriftFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # AR(1)
   bundle b = naiveFC(y, &quot;ar1FC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # AR(1) + Trend
   bundle b = naiveFC(y, &quot;ar1trendFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # Seasonal mean
   bundle b = naiveFC(y, &quot;smeanFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # Seasonal median
   bundle b = naiveFC(y, &quot;smedianFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # Seasonal naive without drift
   bundle b = naiveFC(y, &quot;snaiveFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc

   # Seasonal naive with drift
   bundle b = naiveFC(y, &quot;snaivedriftFC&quot;, opt)
   eval b.forecasts_lower_bound[1] ~ b.forecasts_point[1] ~ b.forecasts_upper_bound[1]
   naivePlot(&amp;b)
   eval b.fc
*/

#/* ACTIVATE IF WANTED: may take a while
#=========================
# Moving-window forecasts
#=========================
bundle opts = null					# setup additional options
opts.horizon = 10
opts.type_moving_window = &quot;rolling&quot; 		# &quot;rolling&quot; / &quot;recursive&quot; -&gt; type of moving-window forecasting  (optional)
# opts.window_length = 400 #xmax($pd, 90) 	# moving window length (optional)
# opts.window_length = $tmax
catch list opts.xlist = kracher budget #D743 FDD		# optional additional regressors
#opts.verbose = 1						# print details (optional)

# TODO: in case of moving-window fc, xlist does not need to have additional oos valid data
# TODO as we forecast only to the last valid obs of y in this case anyway!
# FIXME: moving-window fc with &quot;avgfc&quot;

strings methods = defarray(&quot;meanFC&quot;, &quot;medianFC&quot;, &quot;rwFC&quot;, &quot;rwdriftFC&quot;, \
  &quot;smeanFC&quot;, &quot;smedianFC&quot;, &quot;snaiveFC&quot;, &quot;snaivedriftFC&quot;, &quot;ar1FC&quot;, &quot;ar1trendFC&quot;, &quot;avgfc&quot;)

bundle b = null
bundle b = naiveFC(y, methods[1], opts)

bundle forecast_results = b.forecast_results
#eval forecast_results.smeanfc
#eval forecast_results.smeanfc.forecasts_point

list FC = get_naive_forecasts(b, {1,2})

b.pre_fc_periods_to_plot = 60					# set no. of pre.-forecast periods obs. to plot
plot_naive_forecasts(b, {1}, &quot;meanfc&quot;)
plot_naive_forecasts(b, {1}, &quot;ar1FC&quot;)
plot_naive_forecasts(b, {1}, &quot;avgfc&quot;)
</sample-script>
</gretl-function-package>
</gretl-functions>
