function bundle point_fc_and_factor_as_arrays (const matrices fc_and_sd,
                                               bundle *self)
    /* Using each model's point forecast and standard error, compute
    the forecast interval assuming standard normal. */

    bundle bout = null

    scalar m = nelem(fc_and_sd)
    matrices point_forecasts = array(m)
    matrices factors = array(m)

    loop i=1..m -q
        point_forecasts[i] = fc_and_sd[i][,1]
        factors[i] = fc_interval_width(fc_and_sd[i][,1], self.level)
    endloop

    bout.point_forecasts = point_forecasts
    bout.factors = factors

    return bout
end function


function void get_point_low_up_bound_arrays (bundle *bout, bundle *self)
/* Generate for each model based on respective point forecasts and
    estimated standard derrors, arrays holding the interval forecasts. */

    if !inbundle(bout, "point_forecasts")
        funcerr "Could not find item 'point_forecasts' in bundle"
    endif
    if !inbundle(bout, "factors")
        funcerr "Could not find item 'factors' in bundle"
    endif

    scalar n = nelem(bout.point_forecasts)
    if n != nelem(bout.factors)
        funcerr "Number of matrices does not equal.
    endif

    matrices self.forecasts_point = array(n)
    matrices self.forecasts_lower_bound = array(n)
    matrices self.forecasts_upper_bound = array(n)

    loop i=1..n -q
        self.forecasts_point[i] = bout.point_forecasts[i]
        self.forecasts_lower_bound[i] = bout.point_forecasts[i] - bout.factors[i]
        self.forecasts_upper_bound[i] = bout.point_forecasts[i] + bout.factors[i]
    endloop

end function


function strings get_dates_forecasted (const string t2_label,
                                       const int horizon)
    /* Construct date strings refering to the date for which a the
    h-step ahead forecast was made for. For 'static' forecasts only. */

    strings dates_forecasted = array(horizon)

    scalar init_day_forecasted = 1 + obsnum(t2_label)
    scalar last_day_forecasted = init_day_forecasted + horizon - 1

    loop i=1..horizon -q
        smpl (init_day_forecasted+$i-1) (init_day_forecasted+$i-1)
        dates_forecasted[i] = obslabel($t1)
    endloop

    return dates_forecasted
end function

# FIXME: Merge with get_dates_forecasted()
function strings array_of_condition_dates (bundle *self)
/* Construct date strings refering to the date based on which a
    forecasting model was estimated. */

    if self.type_moving_window == "static"
        strings dates = array(1)		# for 'static' case, only on a single date is conditioned
    else
        strings dates = array(self.n_folds)
    endif

    # Here we explicitly consider the case when the last obs are missings
    # TODO: Check dates for correctness!
    scalar first_condition_date = obsnum(self.t1_forecast_date) - 1
    if self.type_moving_window == "static"
        #scalar first_condition_date = obsnum(self.t2_label)
        scalar last_condition_date = first_condition_date
    else
        scalar last_condition_date = first_condition_date + self.n_folds - 1	# TODO: -1 ???
    endif
    matrix conditioning_dates = {$obsdate}[first_condition_date:last_condition_date]

    strings r = array(rows(conditioning_dates))

    # TODO: Consolidate with loop in get_dates_forecasted()
    loop i=1..rows(conditioning_dates) -q
        string sdate = sprintf("%d", conditioning_dates[i])

        if $pd == 1
            r[i] = sprintf("%s", substr(sdate,1,4))
        elif $pd==4
            r[i] = sprintf("%s:%s", substr(sdate,1,4),
              substr(sdate,5,6))
        else
            r[i] = sprintf("%s-%s-%s", substr(sdate,1,4),
              substr(sdate,5,6), substr(sdate,7,8))
        endif
    endloop

    return r
end function



function bundle default_values (const series y)
    /* Set default values */

    bundle self = null
    scalar self.error = 0
    list self.xlist = null
    scalar self.horizon = 10				# maximum forecast horizon
    scalar self.level = 0.9					# probability level for forecast interval
    scalar self.fan = 0						# plot fan chart  (not supported yet)
    scalar self.nboot = 0					# no. of bootstrap replications  (not supported yet)
    scalar self.blength = 4					# Block length bootstrap  (not supported yet)
    scalar self.is_seas = data_has_seasonality()
    strings self.estimator_names = get_estimator_names(self.is_seas)
    scalar self.verbose = 1

    # For get_moving_window_forecasts()
    string self.type_moving_window = "static" 			# "static", "rolling" or "recursive"
    scalar self.window_length = ceil(0.25 * nobs(y))		# default window length

    # For naivePlot()
    string self.title = ""
    string self.ylab = ""
    string self.xlab = ""
    string self.filename = "display"
    scalar self.pre_fc_periods_to_plot = int(0.25 * nobs(y))

    return self
end function



function void get_static_forecasts (bundle *self)
/* Estimate model 'static' and compute interval h-multistep forecast,
      store results. */

    matrices fc_and_sd = call_method(&self)
    if !self.error
        bundle bout = point_fc_and_factor_as_arrays(fc_and_sd, &self)
        get_point_low_up_bound_arrays(&bout, &self)
    endif
end function


function matrices call_method (bundle *self)
/* Wrapper for calling method. Returns p-dimension array where
   each matrix is of size h by 2 holding point forecasts and forecast
    standard errors. */

    # Returned array includes m matrices. Each matrix is of dimension h by 2 (point~sderr)
    if self.which != "avgfc"	# m=1
        matrices fc_and_sd = defarray(forecast_and_get_fc_sd(&self, self.which))	# 1-dim array incl. single h by 2 matrix
    else								# currently m=10 incl. avg. forecast
        matrices fc_and_sd = avg_forecast_and_get_fc_sd(&self)	# function already transforms into array
    endif

    return fc_and_sd
end function


function matrix forecast_and_get_fc_sd (bundle *self, const string method)
    /* Compute point forecast and forecast standard errors. */

    scalar dynamic_fc =
    if is_dynamic_model(method)
        string fcast_arg = "--dynamic"
    else
        string fcast_arg = "--static"
    endif
    matrix forecast_results = zeros(self.horizon, 2) * NA
    list xlist = null
    series y = self.y					# length: window_length + horizon

    xlist += add_ohe_periods_to_list(method, xlist)
    xlist += add_linear_trend_to_list(&self, method, xlist)
    xlist += add_intercept_to_list(method, xlist)
    xlist += self.xlist
    if method == "ar1fc" || method == "ar1trendfc"
        xlist += y(-1)
    endif

    # Select sample comprising both training and test set
    bundle train_obsnums = get_train_start_end_obsnums(&self)
    catch smpl train_obsnums.t1_obsnum train_obsnums.t2_obsnum

    if $error
        printError("Failed to set training set. Check your sample and window size.")

        scalar self.error = 1
        return forecast_results
    endif

    if self.type_moving_window != "static" && ($nobs > self.window_length)
        printError(sprintf("You training sample (T=%d) is longer than the\n\
          specified window length (T=%d).", $nobs, self.window_length))

        scalar self.error = 1
        return forecast_results
    endif


    # Estimation
    if method == "meanfc"
        catch ols y xlist --quiet

    elif method == "medianfc"
        catch quantreg 0.5 y xlist --quiet

    elif method == "smeanfc"
        catch ols y xlist --quiet

    elif method == "smedianfc"
        catch quantreg 0.5 y xlist --quiet

    elif method == "snaivefc" || method == "snaivedriftfc"
        string arima_opt = (method == "snaive") ? "--nc" : ""
        catch arima 0 0 0 ; 0 1 0 ; y xlist @arima_opt --quiet

    elif method == "rwfc" || method == "rwdriftfc"
        string arima_opt = (method == "rwfc") ? "--nc" : ""
        catch arima 0 1 0 ; y xlist @arima_opt --quiet

    elif method == "ar1fc" || method == "ar1trendfc"
        catch ols y xlist --quiet
    endif

    if $error
        printError("Error: Model estimation failed.\n\
          Forecast values are set to NA for the current sample.")
    else
        fcast ($t2+1) ($t2+self.horizon) @fcast_arg --quiet
    endif

    #    *** HIER WEITERMACHEN
    if self.type_moving_window == "static"
        gen_t1_forecast_date($t2, &self)			# adds to self
        gen_t2_forecast_date($t2, &self)			# adds to self
    endif

    if !model_error
        fc_and_sd_matrix = $fcast ~ $fcse
    endif

    return fc_and_sd_matrix
end function




# TODO: put checks into separate functions
function void do_initial_checks (bundle *self)
    /* Helper function perfoming some initial checks */

    strings methods = get_supported_nonseas_methods()
    strings seas_methods = get_supported_seas_methods()

    # Check whether called method exists
    if !nelem(strpos(methods, self.which)) && !nelem(strpos(seas_methods, self.which))
        printError("The forecasting method you selected does not exist.")
        self.error = 1
    endif
    
    if !self.is_seas && nelem(strpos(seas_methods, self.which))
        printError("The method you requested is not available for non-seasonal data.")
        self.error = 1
    endif

    if self.window_length < $pd
        printError("Periodicity cannot be negative.")
        printError(sprintf("Window size = %d", self.window_length))
        printError(sprintf("Periodicity = %d\n", $pd))
        printError("The size of the moving window cannot be smaller than the underlying periodicity.")
        self.error = 1
    endif

    if self.nboot
        print_no_bootstrap_support()
        self.error = 1
    endif

    if (self.type_moving_window == "rolling" || self.type_moving_window=="recursive") \
          && self.which == "avgfc"

        printError("Automatic forecast averaging ('avgfc') is\n\
          currently not compatible with moving forecasts.\n\
          Re-specify")
        self.error = 1
    endif
end function


function bundle naiveFC (const series y,
                         string which "Select forecasting method",
                         bundle opts[null] "Bundle incl. optional parameters")
    /* Main package function */

    if !exists(opts)
        bundle opts = null
    endif
    bundle self = set_bundle(y, which, opts)

    do_initial_checks(&self)
    if self.error
        return self
    endif

    catch include CvDataSplitter.gfn
    if !$error
        printInfo("Necessary package 'CvDataSplitter' succesfully loaded.")
    endif

    # Drop missings + determine number of valid observations
    valid_sample_and_obs_details(y, &self)
    if self.error
        return self
    endif
    
    # Add obs for forecasting
    self.obs_added = nobs_to_add_to_dataset(y, self.horizon)
    if self.obs_added
        dataset addobs self.obs_added	# TODO: check that this can be done in a function
        series self.y = misszero(y)		# new obs are set as NA
        printInfo(sprintf("Added %d additional observations at the sample end.", \
          self.obs_added))
    endif
    
    do_naive_forecasting(&self)

    if self.verbose
        summarize_naive_fc_results(&self)
    endif

    # Drop some elements from self
    delete self.fan
    delete self.blength
    delete self.nboot
    if inbundle(self,"obs_season")
        delete self.obs_season
    endif

    return self
end function


function void prepare_forecast_bundles (bundle *self)
/* Prepare for each estimator a dictionary for point
    interval forecast results to be stored in matrices. */

    bundle self.forecast_results = null
eval self
    loop i=1..nelem(self.estimator_names) -q
        bundle self.forecast_results[self.estimator_names[i]] \
          = defbundle("point_fc", {}, "lower_fc", {}, "upper_fc", {})
    endloop
end function


function void do_naive_forecasting (bundle *self)
/* Wrapper function actually calling static or
    moving-window procedures. */

    prepare_forecast_bundles(&self)

    if self.type_moving_window == "static"
        get_static_forecasts(&self)
    else
        get_moving_window_forecasts(&self)
    endif

    attach_column_labels(&self)
    attach_row_labels(&self)
end function


function void attach_row_labels (bundle *self)
/* Add date strings as row labels for 'static' forecasts,
   or indicate the forecast horizon for moving-window
    forecasts. */

    if self.type_moving_window == "static"
        strings row_labels = get_dates_forecasted(self.t2_label, self.horizon)
    else
        strings row_labels = array_of_horizon_labels(self.horizon)
    endif

    loop i=1..nelem(self.forecasts_point) -q
        rnameset(self.forecasts_point[i], row_labels)
        rnameset(self.forecasts_lower_bound[i], row_labels)
        rnameset(self.forecasts_upper_bound[i], row_labels)
    endloop
end function


function void attach_column_labels (bundle *self)
/* Add date strings as column labels for indicating the date on
    which the estimates are conditioned on. */

    strings conditioning_dates = array_of_condition_dates(&self)

    loop i=1..nelem(self.forecasts_point) -q
        cnameset(self.forecasts_point[i], conditioning_dates)
        cnameset(self.forecasts_lower_bound[i], conditioning_dates)
        cnameset(self.forecasts_upper_bound[i], conditioning_dates)
    endloop
end function


function void summarize_naive_fc_results (bundle *self)
    /* Print summarising information */
    printf "****************************************************\n"
    printf "\t\tNaive Forecasting Method\n"
    printf "\nEndogenous: \t\t\t\t%s\n", self.name_endo
    printf "Number of additional exogenous: \t%d\n", nelem(self.xlist)
    printf "Forecasting method: \t\t\t%s\n", self.which
    printf "Start valid data set: \t\t\t%s\n", self.t1_label
    printf "End valid data set: \t\t\t%s\n", self.t2_label
    printf "Number of observations: \t\t%d\n", obsnum(self.t2_label)-obsnum(self.t1_label)
    printf "Forecast horizon: \t\t\t%d\n", self.horizon
    printf "First observation forecasted (h=1): \t%s\n", self.t1_forecast_date
    printf "Last observation forecasted (h=%d): \t%s\n", self.horizon, self.t2_forecast_date
    if self.type_moving_window == "static"
        if self.which != "avgFC"
            printf "Width forecast interval: \t\t%d pct.\n", self.level*100
        endif
    else
        printf "Moving window length: \t\t\t%d\n", self.window_length
        printf "Number of %s forecasts: \t\t%d\n", self.type_moving_window, self.n_folds
    endif
    printf "****************************************************\n"
    printf "\n"
end function




# TODO: untested
function void valid_sample_and_obs_details (const series y, bundle *self)
    /* Drop missing values + construct a contiguous data set. */

    self.T_all = $nobs  # no. of obs of the original dataset passed, may incl. missings

    if inbundle(self, "xlist")
        list xlist = self.xlist
    else
        list xlist = null
    endif

    self.error = samples_for_y_and_xlist_match(y, xlist, &self)

    if self.error == 0
        obslabels_and_nobs_to_bundle(y, &self)		# add labels of valid dates to self

        scalar tdiff = self.T_all - self.T

        if tdiff > 0 && self.verbose
            printWarning(sprintf("The time-series sample has been restricted\n\
              due to %d missing values in series %s.", tdiff, self.name_endo))

            printWarning(sprintf("Information on the new contiguous \n\
              set for series '%s':\n\
              Start date: %s\n\
              End date: %s", self.name_endo, self.t1_label, self.t2_label))
        endif
    endif

    self.error = valid_window_length(&self)
end function


function matrices do_avgfcs_and_get_fc_sd_array (bundle *self)
/* Compute forecasts for each method. For each mezthod we obtain a matrix
    of size h by 2 holding point forecasts and associated standard errors. */

    scalar m = nelem(self.estimator_names)
    matrices fc_and_sd = array(m)

    loop i=1..m -q
        fc_and_sd[i] = forecast_and_get_fc_sd(&self, self.estimator_names[i])
    endloop

    return fc_and_sd
end function


function matrices avg_forecast_and_get_fc_sd (bundle *self)
/* Compute forecasts using different methods supported, and return array of point
    forecasts and associated standard errors. */

    return do_avgfcs_and_get_fc_sd_array(&self)
end function


# FIXME: Unfinished function and not used, yet!
function bundle get_mean_fc_and_mean_sd (const matrices fc_and_sd)
    /* */

    scalar n = nelem(fc_and_sd)
    scalar h = rows(fc_and_sd[1])
    matrix point_fc_avg = NA * zeros(h, n)	# avg. point forecast across all models
    matrix sd_fc_avg = NA * zeros(h, n)		# avg. std. error of forecasts across all models

    loop i=1..n -q			# TODO: Future drill() may replace this
        point_fc_avg[,i] = fc_and_sd[i][,1]
        sd_fc_avg[,i] = fc_and_sd[i][,2]
    endloop

    return defbundle("fc_point_avg", meanr(point_fc_avg), "fc_sd_avg", meanr(sd_fc_avg))
end function


function void get_moving_window_forecasts (bundle *self)
/* This function estimates the point forecasts either in (i) a rolling or
    (ii) a recursive manner and stores sequences of interval forecasts. */

    # TODO: to initial checks??
    if $nobs < self.window_length
        printf "\nError: The window size you selected (wsize=%d) exceeds the\n\
          number of valid observations.\n", self.window_length
        funcerr "Re-specify."
    endif

    series y = self.y			# y includes the additional n=horizon newly added observations for the very last cv-dataset

    bundle cv = null					# Tried to put this into a bundle, but git issues with index series
    list cv.X = 	y					# CvDataSplitter() expects a list
    string cv.cv_type = (self.type_moving_window=="rolling") ? "rolwin" : "recwin"
    scalar cv.win_size = self.window_length + self.horizon		# The last self.horizon rows are reserved for the OoS evaluation
    CvDataSplitter(&cv)
    cv
    stop
    # As CvDataSplitter() doesn't consider the very last obs in
    # the final training set for 'rolwin' and 'recwin', this must be added.
    cv.X_train += cv.X_train[cv.n_folds] | ({$t2, y[$t2]})
    cv.n_folds++
    self.n_folds = cv.n_folds

    # Loop over training sets, run estimation and retrieve interval forecasts
    # returns an n_folds-dimensional array comprising h by 2 (point~sderr) matrices.
    matrices fc_and_sd_from_all_cv = get_cv_fc_and_sd_array(&cv, &self)
    bundle bout = point_fc_and_factor_as_arrays(fc_and_sd_from_all_cv, &self)	# stuff stored in an array in bout

    # Retrieve moving-window point_forecasts from array,
    # and compute and get associated intervals.
    matrices pt_lb_up = ret_movwin_point_lb_up_matrices(&bout, &self)

    # --> For the 'static' case, point, lower and upper bound results
    # are stored in separate matrix arrays, as multiple models can be
    # estimated 'at once' in case the avgFC is called.
    # For compatibility reasons, we do the same here.
    matrices self.forecasts_point = defarray(pt_lb_up[1])		# rows: horizon, cols: date based on which h-steap ahead forecast is made for
    matrices self.forecasts_lower_bound = defarray(pt_lb_up[2])
    matrices self.forecasts_upper_bound = defarray(pt_lb_up[3])

end function


function matrices ret_movwin_point_lb_up_matrices (bundle *bout,
                                                   bundle *self)
    /* Retrieve miving-window point_forecasts from array,
      and compute and get associated intervals. */
    matrices out = array(3)

    out[1] = flatten(bout.point_forecasts)		# rows: horizon, cols: sample period
    matrices get_movwin_low_up_matrices = get_movwin_low_up_matrices(out[1], \
      flatten(bout.factors))
    out[2] = get_movwin_low_up_matrices[1]
    out[3] = get_movwin_low_up_matrices[2]

    return out
end function


function matrices get_cv_fc_and_sd_array (bundle *cv, bundle *self)
/* Loop over training sets, run estimation and retrieve
    interval forecasts. */

    matrices fc_and_sd_from_all_cv = array(cv.n_folds)

    loop lwin=1..cv.n_folds -q
        matrix mat = cv.X_train[lwin]
        smpl minc(mat[,1]) (maxc(mat[,1]))		# time index of the training set: T=self-window_length + self-horizon

        if lwin == 1
            # Note: As the series for cross-validation holds "window_length+horizon" observations, we need to
            # subtract "horizon" here.
            gen_t1_forecast_date($t2-self.horizon, &self)	# Date for which the 1st 1-step ahead forecast is made for
        elif lwin == cv.n_folds
            gen_t2_forecast_date(obsnum(self.t2_label), &self)				# Date for which the last h-step ahead forecast is made for
        endif

        fc_and_sd_from_all_cv[lwin] = call_method(&self)[1]
    endloop

    return fc_and_sd_from_all_cv
end function


function list getNaiveForecastsList (bundle *self,
                                     const matrix horizons[null] "Select only specific horizons",
                                     const string suffix[null] "Suffix for series' names")
    /* Transform interval forecasts into a list of series and return this. */

    # Initial settings
    list R = null
    matrix hor = seq(1, self.horizon)'
    hor = (exists(horizons)) ? horizons : hor
    hor = vec(hor)
    
    # FIXME: 'methods_used' still needed? All names stored in self.estimator_names    
#    strings methods_used = defarray(self.which)	# TODO: Do this already in naiveFC()
#    strings methods_used = (inbundle(self, "methods_used")) ? self.estimator_names : methods_used

    if !exists(suffix)
        string suffix = ""
    endif

    if maxc(hor) > self.horizon
        printf "\nError: The maximum forecast horizon you selected (%d) does not exist.\n\
          Empty list returned.", maxc(hor)
        return R
    elif minc(hor) <= 0
        printf "\nError: The minimum forecast horizon you selected (%d) does not exist.\n\
          Empty list returned.", minc(hor)
        return R
    endif

    if self.obs_added > 0
        dataset addobs self.obs_added
    endif

    series y = self.y
    if self.obs_added > 0				# The last h observations were added and set to zero
        smpl (obsnum(self.t2_label)+1) $tmax
        series y = NA
        smpl full
    endif

    loop j=1..nelem(methods_used) -q
        loop i=1..rows(hor) -q
            scalar start = obsnum(self.t1_forecast_date) + hor[i] - 1
            scalar ende = start + self.n_folds - 1
            smpl start ende

            R += genseries(sprintf("fc_pt_h_%d_%s%s", hor[i], methods_used[j], suffix), \
              self.forecasts_point[j][i,]')
            R += genseries(sprintf("fc_lo_h_%d_%s%s", hor[i], methods_used[j], suffix), \
              self.forecasts_lower_bound[j][i,]')
            R += genseries(sprintf("fc_up_h_%d_%s%s", hor[i], methods_used[j], suffix), \
              self.forecasts_upper_bound[j][i,]')
        endloop
    endloop

    return R
end function



function void naivePlot (bundle *self "Bundle returned from naiveFC()",
      const matrix horizons[null] "Select only specific horizons")

    /* Function for plotting actual and forecast values over time. */

    string out = self.filename

    scalar pre_fc_periods_to_plot = inbundle(self, "pre_fc_periods_to_plot") ? \
      self.pre_fc_periods_to_plot : pre_fc_periods_to_plot

    if self.obs_added > 0
        dataset addobs self.obs_added
    endif

    series y = self.y
    setinfo y --graph-name="Actuals"
    if self.obs_added > 0				# The last h observations were added and set to zero
        # Note, eventual missings at the beginning of the data passed to naiveFC() aren't considered.
        smpl (obsnum(self.t2_label)+1) $tmax
        series y = NA
        smpl full
    endif

    list forecasts = y

    if exists(horizons)
        list forecasts += getNaiveForecastsList(&self, horizons)
    else
        list forecasts += getNaiveForecastsList(&self)
    endif
    if nelem(forecasts)
        printf "\nError: Received empty list from getNaiveForecastsList(). Stop.\n"
        stop
    endif

    /*
       if self.type_moving_window!="static"						# rolling/ recursive window
       scalar start = self.initfc - 1
       smpl start start
       # Loop over diff. training sets; each produces h-step ahead forecasts
       loop i=1..rows(self.fc) -q
       start++
       smpl start (start+self.horizon-1)
       series fc_$i = fcmat[i,]
       str = sprintf("TrainSet=%d", $i)
       setinfo fc_$i --graph-name="@str"
       lplot += fc_$i
       endloop

       elif self.type_moving_window=="static"
       self.initfc = self.T+1

       loop i=1..cols(self.fc) -q
       series fc_$i = fcmat[,i]

       if self.which=="avgFC"
       if i!=2
       str = sprintf("%s", self.method_names[i])
       setinfo fc_$i --graph-name="@str"
       endif
       else
       string meth = self.which
       setinfo fc_$i --graph-name="@meth"	#"Point-Fc"
       if cols(self.fc)==3
       if i==2
       string s = sprintf("%.1f", (1-self.level)/2*100 )
       setinfo fc_$i --graph-name="@s"
       elif i==3
       string s = sprintf("%.1f", (1-(1-self.level)/2)*100 )
       setinfo fc_$i --graph-name="@s"
       endif
       endif
       endif
       lplot += fc_$i
       if self.which=="avgFC" && i==2
       lplot -= fc_$i		# drop cross-sectional std. statistics
       endif
       endloop
       endif
    */

    # incl. some pre-forecast periods obs. for plotting
    smpl xmax((obsnum(self.t2_forecast_date) - pre_fc_periods_to_plot), 1) $tmax

    # y-range
    scalar mini = min(min(forecasts))
    scalar maxi = max(max(forecasts))
    scalar ylo = mini-0.05*abs(mini)
    scalar yup = maxi+0.05*abs(maxi)
    # TODO: lplot may become A VERY long list -- think about a restriction showing
    # only the k last forecasts

    /*
       if cols(self.fc) != 3
       plot lplot
       options with-lp time-series single-yaxis
       literal set linetype 1 lc rgb "black" lw 1 pt -1
       literal set linetype 2 lc rgb "red" lw 1.25 pt 2 ps 0.5
       literal set linetype 3 lc rgb "blue" lw 1#.25
       literal set linetype 4 lc rgb "black" lw 1#.25
       literal set linetype 5 lc rgb "grey" lw 1#.25
       literal set linetype 6 lc rgb "violet" lw 1#.25 #pt 3 ps 0.5
       literal set linetype 7 lc rgb "brown" lw 1#.25 #pt 4 ps 0.5
       literal set linetype 8 lc rgb "yellow" lw 1#.25 #pt 5 ps 0.5
       literal set linetype 9 lc rgb "red" lw 1#.25 #pt 1 ps 0.5
       literal set linetype 10 lc rgb "green" lw 1#.25
       literal set linetype 10 lc rgb "black" lw 1#.25
       literal set key left bottom below
       #literal set key inside left bottom
       #put the border more to the background by applying it
       # only on the left and bottom part and put it and the tics in gray
       literal set style line 11 lc rgb "#808080" lt 1
       literal set border 3 back ls 11			# get rid of upper + left border
       literal set tics nomirror
       #add a slight grid to make it easier to follow the exact position of the curves
       literal set style line 12 lc rgb "#808080" lt 0 lw 1	# light grey color
       literal set grid back ls 12
       printf "set yrange[%g:%g]", ylo, yup
       printf "set ylabel \"%s\"", self.ylab
       printf "set xlabel \"%s\"", self.xlab
       printf "set title \"%s\"", self.title
       end plot --output="@out"

       else
    */
    plot forecasts
        options with-lp time-series single-yaxis
        literal set linetype 1 lc rgb "black" lw 1.5 pt 7 ps 1
        literal set linetype 2 lc rgb "red" lw 1.5 ps 0
        literal set linetype 3 lc rgb "blue" lw 1.5 ps 0
        literal set linetype 4 lc rgb "blue" lw 1.5 ps 0
        literal set key left bottom below
        #literal set key inside left bottom
        #put the border more to the background by applying it
        # only on the left and bottom part and put it and the tics in gray
        literal set style line 11 lc rgb "#808080" lt 1
        literal set border 3 back ls 11			# get rid of upper + left border
        literal set tics nomirror
        #add a slight grid to make it easier to follow the exact position of the curves
        literal set style line 12 lc rgb "#808080" lt 0 lw 1	# light grey color
        literal set grid back ls 12
        printf "set yrange[%g:%g]", ylo, yup
        printf "set ylabel \"%s\"", self.ylab
        printf "set xlabel \"%s\"", self.xlab
        printf "set title \"%s\"", self.title
    end plot --output="@out"
    #    endif
end function


function matrix GUI_naiveFC (const series y "Dependent variable",
                             const list xlist[null] "Additional exogenous (future values must be known)",
      int which[1:11:1] "Model type" {"meanFC", "medianFC", "rwFC", "rwdriftFC", \
      "ar1FC", "ar1trendFC", "smeanFC", "smedianFC", "snaiveFC", "snaivedriftFC", "avgFC"},
      int h[1::10] "Forecast horizon",
      bool Plot[1] "Plot forecast")
    /* Helper function for GUI access. */

    # map integer value to string
    strings methods = get_supported_nonseas_methods()

    bundle opts = null
    bundle self = null
    opts.h = h
    opts.xlist = xlist
    self = naiveFC(y, methods[which], opts)

    # output
    printf "%12.4f\n", self.fc
    if Plot
        naivePlot(&self)
    endif

    return self.fc
end function

