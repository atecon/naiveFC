function string gen_colnames (matrix ci)
    # construct column names
    string c = "point"
    loop i=1..cols(ci) -q
        c += sprintf(" q%d", ci[i]*100)
    endloop
    return c
end function

function string rownam (scalar h)
    # construct row names (horizons)
    string r = "h=1"
    loop i=2..h -q
        r += sprintf(" h=%d", i)
    endloop
    return r
end function


function matrix get_last_obsminor (const series y, int h)
    # obtain last k (quarterly=4, monthly=12, etc. obs)
    smpl ($t2-$pd+1) $t2	# last $pd values
    return stack_fc({y}, h)
end function

/*
   function matrix re_sample (const matrix y, int nboot, int blength)
   # NOTE: requires SB.gfn package
   # not considered yet

   matrix bb=zeros(nobs(y),nboot)
   loop boot=1..nboot --quiet
   bb[,boot]=SB(y,blength)
   endloop
   return bb
   end function
*/

function matrix genci (scalar level[1:99:90] "confidence sign. level",
                       bool fan[0])
    # generate confidence interval(s)
    if !fan
        scalar lo = (100-level)/2
        matrix ci = { lo, 100-lo }./100
    else
        matrix ci = seq(2,99,3)/100
    endif
    return ci
end function

function matrix stack_fc (matrix fc "Forecast(s)",
      int h "Forecast horizon")
    # construct h-step ahdead forecasts
    matrix fc = vec(fc)
    # stack forecasts
    if h>rows(fc)
        loop i=1..ceil(h/rows(fc)) -q
            fc |= fc
        endloop
        fc = fc[1:h]
    else
        fc = fc[1:h]
    endif
    return fc
end function

function matrix get_mean_obsminor (const series y, int h)
    # obtain last k (quarterly=4, monthly=12, etc. obs)
    series omin = $obsminor
    scalar n = max(uniq(omin))
    matrix ymeans = zeros(n, 1)

    loop i=1..n -q	# filter by $obsminor
        smpl omin==$i --restrict --replace
        ymeans[i] = mean(y)
    endloop
    return stack_fc(ymeans, h)
end function


function void fcplot (const series y, matrix fc,
                      string title[null],
                      string ylab[null],
                      string xlab[null])

    # Plot point forecast and quantiles
    string title = !exists(title) ? "" : title
    string ylab = !exists(ylab) ? "" : ylab
    string xlab = !exists(xlab) ? "" : xlab

    set warnings off
    matrix mplot = {y}
    loop i=1..cols(fc) -q
        mplot ~= NA
    endloop
    mplot |= (NA ~ fc)
    colnames(mplot, "Actuals PointFC Low High")
    set warnings on

    ylo = min(y)-0.05*min(y)
    yup = max(y)+0.05*max(y)
    plot mplot
        options with-lines time-series single-yaxis
        literal set linetype 1 lc rgb "grey"
        literal set linetype 2 lc rgb "red" lw 2
        literal set linetype 3 lc rgb "black" lw 1.5
        literal set linetype 4 lc rgb "black" lw 1.5
        literal set key bottom below
        printf "set yrange[%g:%g]", ylo, yup
        printf "set ylabel \"%s\"", ylab
        printf "set xlabel \"%s\"", xlab
        printf "set title \"%s\"", title
    end plot --output=display
end function

function void seas_check (const series y "Actuals")
    if $pd==1
        funcerr "The method you requested is not available for annual data."
    endif
end function


function matrix meanf (const series y "Actuals",
                       int h[1::10] "Forecast horizon",
                       scalar level[64:99:90] "Confidence level",
                       bool fan[0],
                       int nboot[0::0],
                       int blength[2::4] "Block lenght bootstrap")
    # forecasts of all future values are equal to the mean of the historical data
    # Returns forecasts and prediction intervals for an iid model applied to y
    /* R func:
       meanf(y, h = 10, level = c(80, 95), fan = FALSE, lambda = NULL,
       biasadj = FALSE, bootstrap = FALSE, npaths = 5000, x = y)
    */
    matrix ci = genci(level,fan)

    if nboot==0
        matrix ymean = ones(h,cols(ci)+1) .* ( mean(y) ~ NA ~ NA ) # ~ quantile({y},ci)' )

    else
        matrix yb = vec( re_sample({y}, nboot, blength) )
        matrix ymean = ones(h,cols(ci)+1) .* ( meanc(yb) ~ quantile(yb,ci)' )
    endif
    colnames(ymean, gen_colnames(ci))
    rownames(ymean, rownam(h))
    return ymean
end function


function matrix rwf (const series y "Actuals",
                     int h[1::10] "Forecast horizon",
                     bool drift[0] "0=Random-Walk wo drift, 1=w drift",
                     scalar level[64:99:90] "Confidence level",
                     bool fan[0],
                     int nboot[0::0],
                     int blength[2::4] "Block lenght bootstrap")

    # naÃ¯ve forecast is optimal when data follow a random walk
    # these are also called random walk forecasts
    /* R func:
       https://www.rdocumentation.org/packages/forecast/versions/8.4/topics/rwf
       rwf(y, h = 10, drift = FALSE, level = c(80, 95), fan = FALSE,
       lambda = NULL, biasadj = FALSE, bootstrap = FALSE, npaths = 5000,
       x = y)
    */

    matrix ci = genci(level,fan)

    mat = ones(h,1) 					#TODO: construct intervals later
    matrix fc = mat .* ( y[$t2] ~ NA ~ NA )

    if drift
        # equivalent to an ARIMA(0,1,0) model with an optional drift coefficient
        scalar avg = (y[$t2]-y[$t1])/(nobs(y)-1)	# average growth rate (drift)
        fc[,1] = fc[,1] .+ cum(mat)*avg	# TODO: consider intervals later
    endif

    colnames(fc, gen_colnames(ci))
    rownames(fc, rownam(h))
    return fc
end function


function matrix snaive (const series y "Series",
                        int h[1::10] "Horizon",
                        scalar level[64:99:90] "Confidence level",
                        bool fan[0],
                        int nboot[0::0],
                        int blength[2::4] "Block lenght bootstrap")

    # returns forecasts and prediction intervals from an ARIMA(0,0,0)(0,1,0)
    # model where m is the seasonal period.
    /* R func:
       https://www.rdocumentation.org/packages/cv.ts/versions/0.0.0.90105/topics/snaiveForecast
       snaive(y, h = 2 * frequency(x), level = c(80, 95), fan = FALSE,
       lambda = NULL, biasadj = FALSE, bootstrap = FALSE, npaths = 5000, x = y)
    */

    seas_check(y)

    matrix ci = genci(level,fan)

    if fan==0
        # forecast simply equals last obs for each specific periodicity (month, quarter)
        fc = get_last_obsminor(y, h)
        matrix fc = ones(h,3) .* ( fc ~ NA ~ NA )
        colnames(fc, "Point NA NA")

    else
        funcerr "Confidence intervals are not available yet."
        /* NEEDS
           # forecast simply equals last obs for each specific periodicity (month, quarter)
           # FIXME: This destroys the seasonality structure
           matrix yb = re_sample({y}, nboot, blength)
           fc_b = zeros(h, nboot)
           loop i=1..nboot -q
           fc_b[,i] = snaive_stack(yb[,i], h)
           endloop
           #fc_mean:	 mean across each horizon
           #fc_ci:		quantiles across each horizon
           matrix fc = ones(h,cols(ci)+1) .* ( meanr(fc_b) ~ quantile(fc_b',ci)' )
        */
    endif
    colnames(fc, gen_colnames(ci))
    rownames(fc, rownam(h))
    return fc
end function


function matrix smeanf (const series y "Series",
                        int h[1::10] "Horizon",
                        scalar level[64:99:90] "Confidence level",
                        bool fan[0],
                        int nboot[0::0],
                        int blength[2::4] "Block lenght bootstrap")

    # forecasts of all future values are equal to the mean of season of the historical data
    # model where m is the seasonal period.

    seas_check(y)

    matrix ci = genci(level, fan)

    if fan==0
        # forecast simply equals the mean for each specific $obsminor periodicity (month, quarter etc.)
        fc = get_mean_obsminor(y, h)

        matrix fc = ones(h,3) .* ( fc ~ NA ~ NA )
        colnames(fc, "Point NA NA")
    else
        funcerr "Confidence intervals are not available yet."
        /* Not implemented yet
           # forecast simply equals last obs for each specific periodicity (month, quarter)
           # FIXME: This destroys the seasonality structure
           matrix yb = re_sample({y}, nboot, blength)
           fc_b = zeros(h, nboot)
           loop i=1..nboot -q
           fc_b[,i] = snaive_stack(yb[,i], h)
           endloop
           #fc_mean:	 mean across each horizon
           #fc_ci:		quantiles across each horizon
           matrix fc = ones(h,cols(ci)+1) .* ( meanr(fc_b) ~ quantile(fc_b',ci)' )
        */
    endif
    colnames(fc, gen_colnames(ci))
    rownames(fc, rownam(h))
    return fc
end function


function matrix ensemble_fc (const series y "Series",
                             int h[1::10] "Horizon",
                             scalar level[64:99:90] "Confidence level",
                             bool fan[0],
                             int nboot[0::0],
                             int blength[2::4] "Block lenght bootstrap")

    # Computes the mean and cross-sectional (across forecast methods)
    # standard deviation at each horizon using all simple forecast methods
    # available.

    # Base models
    strings M = defarray("meanf(y,h)", "rwf(y,h)", "rwf(y,h,1)")
    if $pd>1	# for seasonal data only
        M += "smeanf(y,h)"
        M += "snaive(y,h)"
    endif

    matrix fc = zeros(h,nelem(M))
    loop i=1..nelem(M) -q
        string s = sprintf("%s", M[i])
        fc[,i] = @s[,1]	# only point-fc
    endloop

    fc = meanr(fc) ~ sdc(fc')'
    colnames(fc, "Mean SD")
    rownames(fc, rownam(h))
    return fc
end function





