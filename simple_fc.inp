set verbose off


function string meanf_colnam(matrix ci)
    # construct column names
    string c = "point"
    loop i=1..cols(ci) -q
        c += sprintf(" q%d", ci[i]*100)
    endloop
    return c
end function


function string rownam(scalar h)
    # construct row names
    string r = "h=1"
    loop i=2..h -q
        r += sprintf(" h=%d", i)
    endloop
    return r
end function

function matrix meanf (const series y "Series",
                       int h[1::10] "Horizon",
                       scalar level[64:99:90] "Confidence level",
                       bool fan[0],
                       int nboot[0::99],
                       int blength[2::] "Block lenght bootstrap")
    # forecasts of all future values are equal to the mean of the historical data
    # Returns forecasts and prediction intervals for an iid model applied to y
    /* R func:
       meanf(y, h = 10, level = c(80, 95), fan = FALSE, lambda = NULL,
       biasadj = FALSE, bootstrap = FALSE, npaths = 5000, x = y)
    */
    matrix ci = genci(level,fan)
    
    if nboot==0
        matrix ymean = ones(h,cols(ci)+1) .* ( mean(y) ~ quantile({y},ci)' )
    else
        matrix yb = vec( re_sample({y}, nboot, blength) )
        matrix ymean = ones(h,cols(ci)+1) .* ( meanc(yb) ~ quantile(yb,ci)' )
    endif
    colnames(ymean, meanf_colnam(ci))
    rownames(ymean, rownam(h))
    return ymean
end function

function matrix re_sample ( const matrix y, int nboot, int blength)
    matrix bb=zeros(nobs(y),nboot)
    loop boot=1..nboot --quiet
        bb[,boot]=SB(y,blength)
    endloop
    return bb
end function

function matrix rwf (const series y "Series",
                     int h[1::10] "Horizon",
                     bool drift[0] "0=Random-Walk wo drift, 1=w drift",
                     scalar level[64:99:90] "Confidence level",
                     bool fan[0],
                     bool bootstrap[0], int npaths[99::5000])
    # naÃ¯ve forecast is optimal when data follow a random walk
    # these are also called random walk forecasts
    /* R func:
       https://www.rdocumentation.org/packages/forecast/versions/8.4/topics/rwf
       rwf(y, h = 10, drift = FALSE, level = c(80, 95), fan = FALSE,
       lambda = NULL, biasadj = FALSE, bootstrap = FALSE, npaths = 5000,
       x = y)
    */

    matrix ci = genci(level,fan)
    
    val = {y[$t2]}		# last actual realization
    mat = ones(h,1) ~ cum(ones(h,cols(ci)))	# TODO

    matrix fc = mat .* ( val ~ NA ~ NA )
    colnames(fc, colnam(ci))
    rownames(fc, rownam(h))
    return fc
end function

function void fcplot(const series y, matrix meanf,
                     string title[null],
                     string ylab[null],
                     string xlab[null])

    # Plot point forecast and quantiles
    string title = !exists(title) ? "" : title
    string ylab = !exists(ylab) ? "" : ylab
    string xlab = !exists(xlab) ? "" : xlab

    set warnings off
    matrix mplot = {y}
    loop i=1..cols(meanf) -q
        mplot ~= NA
    endloop
    mplot |= (NA ~ meanf)
    colnames(mplot, "Actuals PointFC Low High")
    set warnings on

    ylo = min(y)-0.05*min(y)
    yup = max(y)+0.05*max(y)
    plot mplot
        options with-lines time-series single-yaxis
        literal set linetype 1 lc rgb "grey"
        literal set linetype 2 lc rgb "red" lw 2
        literal set linetype 3 lc rgb "black" lw 1.5
        literal set linetype 4 lc rgb "black" lw 1.5
        literal set key bottom below
        printf "set yrange[%g:%g]", ylo, yup
        printf "set ylabel \"%s\"", ylab
        printf "set xlabel \"%s\"", xlab
        printf "set title \"%s\"", title
    end plot --output=display
end function

function matrix genci (scalar level[1:99:90] "confidence sign. level",
                       bool fan[0])
    if !fan
        scalar lo = (100-level)/2
        matrix ci = { lo, 100-lo }./100
    else
        matrix ci = seq(2,99,3)/100
    endif                       
    return ci
end function


function matrix snaive (const series y "Series",
                        int h[1::10] "Horizon",
                        scalar level[64:99:90] "Confidence level",
                        bool fan[0],
                        int nboot[0::99],
                        int blength[2::4] "Block lenght bootstrap")
    # returns forecasts and prediction intervals from an ARIMA(0,0,0)(0,1,0)
    # model where m is the seasonal period.
    /* R func:
       https://www.rdocumentation.org/packages/cv.ts/versions/0.0.0.90105/topics/snaiveForecast
       snaive(y, h = 2 * frequency(x), level = c(80, 95), fan = FALSE,
       lambda = NULL, biasadj = FALSE, bootstrap = FALSE, npaths = 5000, x = y)
       */
              
       matrix ci = genci(level,fan)

    if fan==0
        # forecast simply equals last obs for each specific periodicity (month, quarter)        
        fc = get_last_obsminor(y, h)
        matrix fc = ones(h,3) .* ( fc ~ NA ~ NA )
        colnames(fc, "Point NA NA")
        
    else
        funcerr "Confidence intervals are not available yet."
        /* NEEDS 
        # forecast simply equals last obs for each specific periodicity (month, quarter)
        # FIXME: This destroys the seasonality structure
        matrix yb = re_sample({y}, nboot, blength)
        fc_b = zeros(h, nboot)
        loop i=1..nboot -q
            fc_b[,i] = snaive_stack(yb[,i], h)
        endloop
        #fc_mean:	 mean across each horizon
        #fc_ci:		quantiles across each horizon
        matrix fc = ones(h,cols(ci)+1) .* ( meanr(fc_b) ~ quantile(fc_b',ci)' )
        */
    endif
    colnames(fc, meanf_colnam(ci))
    rownames(fc, rownam(h))
    return fc
end function

function matrix get_last_obsminor (const series y, int h)
    # obtain last k (quarterly=4, monthly=12, etc. obs)    
    smpl ($t2-$pd+1) $t2	# last $pd values
    matrix ylast = {y}
    
    # stack snaive forecasts
    if h>rows(ylast)
        loop i=1..ceil(h/rows(ylast)) -q
            ylast|=ylast
        endloop
        ylast = ylast[1:h]
    else
        ylast = ylast[1:h]
    endif
    return ylast
end function

function matrix smean (const series y "Series",
                        int h[1::10] "Horizon",
                        scalar level[64:99:90] "Confidence level",
                        bool fan[0],
                        int nboot[0::99],
                       int blength[2::4] "Block lenght bootstrap")
                       
    # forecasts of all future values are equal to the mean of season of the historical data
    # model where m is the seasonal period.
              
    matrix ci = genci(level, fan)

    if fan==0
        # forecast simply equals the mean for each specific $obsminor periodicity (month, quarter etc.)
        fc = get_mean_obsminor(y, h)
        matrix fc = ones(h,3) .* ( fc ~ NA ~ NA )
        colnames(fc, "Point NA NA")
        
    else
        funcerr "Confidence intervals are not available yet."
        /* NEEDS 
        # forecast simply equals last obs for each specific periodicity (month, quarter)
        # FIXME: This destroys the seasonality structure
        matrix yb = re_sample({y}, nboot, blength)
        fc_b = zeros(h, nboot)
        loop i=1..nboot -q
            fc_b[,i] = snaive_stack(yb[,i], h)
        endloop
        #fc_mean:	 mean across each horizon
        #fc_ci:		quantiles across each horizon
        matrix fc = ones(h,cols(ci)+1) .* ( meanr(fc_b) ~ quantile(fc_b',ci)' )
        */
    endif
    colnames(fc, meanf_colnam(ci))
    rownames(fc, rownam(h))
    return fc
end function



open "/home/at/git/simple_forecasts/beer.gdt" --quiet
/*
   clear

   open "/home/at/git/simple_forecasts/beer.gdt" --quiet
*/
include SB.gfn
scalar h = 11

# SNAIVE:
snaiv = snaive(x, h)
snaiv
fcplot(x, snaiv, "TITLE", "nice ylabel", "nice xlabel")
stop

# SNAIVE: bootstrap doesn't work yet!
snaiv = snaive(x, h, , ,999, $pd)
snaiv
fcplot(x, snaiv, "TITLE", "nice ylabel", "nice xlabel")
stop

# MEANFC
xmean = meanf(x, h, , ,999,$pd)
xmean
fcplot(x, xmean, "TITLE", "nice ylabel", "nice xlabel")
stop

# RW wo drift
rw = rwf(x, h)
rw
fcplot(x, rw)












